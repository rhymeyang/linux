<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.15" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme')
      const systemDarkMode =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (userMode === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (userMode === 'dark' || systemDarkMode) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>Section 2.7 Redirection, Piping and Command Substitution | Security Pro</title><meta name="description" content="some description">
    <link rel="preload" href="/linux/assets/style-DY6JTdq5.css" as="style"><link rel="stylesheet" href="/linux/assets/style-DY6JTdq5.css">
    <link rel="modulepreload" href="/linux/assets/app-B0K3Hfci.js"><link rel="modulepreload" href="/linux/assets/07.html-C-jHnGyo.js">
    <link rel="prefetch" href="/linux/assets/index.html-pRZbA-Eb.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-B8M1IYdA.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-7FoEuEgi.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-BfDrnZ-G.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-Ij9y_FT1.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-KRYFe0Bn.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-B7687Tcl.js" as="script"><link rel="prefetch" href="/linux/assets/04.html-DCimbEZc.js" as="script"><link rel="prefetch" href="/linux/assets/05.html-DT6_QxEp.js" as="script"><link rel="prefetch" href="/linux/assets/06.html-DjApO8wG.js" as="script"><link rel="prefetch" href="/linux/assets/08.html-FUWskEtV.js" as="script"><link rel="prefetch" href="/linux/assets/09.html-CaAnht2d.js" as="script"><link rel="prefetch" href="/linux/assets/10.html-CQvzMKCQ.js" as="script"><link rel="prefetch" href="/linux/assets/11.html-uApN8AmX.js" as="script"><link rel="prefetch" href="/linux/assets/12.html-CSVYifOw.js" as="script"><link rel="prefetch" href="/linux/assets/13.html-DorA9OLx.js" as="script"><link rel="prefetch" href="/linux/assets/temp.html-tTjBOu7L.js" as="script"><link rel="prefetch" href="/linux/assets/404.html-Bw0s9y21.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/linux/"><img class="vp-site-logo" src="/linux/images/leaf.svg" alt="Security Pro"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">Security Pro</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../linux/" aria-label="Linux Pro"><!---->Linux Pro<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../security_pro/" aria-label="Security Pro"><!---->Security Pro<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../tools/" aria-label="Tools"><!---->Tools<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../english-starter/" aria-label="English"><!---->English<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../Se/" aria-label="Semester 3"><!---->Semester 3<!----></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../linux/" aria-label="Linux Pro"><!---->Linux Pro<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../security_pro/" aria-label="Security Pro"><!---->Security Pro<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../tools/" aria-label="Tools"><!---->Tools<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../english-starter/" aria-label="English"><!---->English<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../Se/" aria-label="Semester 3"><!---->Semester 3<!----></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">Info <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/" aria-label="Linux Pro"><!---->Linux Pro<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">0.0 Linux Pro Introduction <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/00/01.html" aria-label="Section 0.1 Course Introduction"><!---->Section 0.1 Course Introduction<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/00/02.html" aria-label="Section 0.2 The TestOut Lab Simulator"><!---->Section 0.2 The TestOut Lab Simulator<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">1.0 Linux Overview <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/01/01.html" aria-label="Section 1.1 Linux Introduction"><!---->Section 1.1 Linux Introduction<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading active">2.0 Using Linux <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/01.html" aria-label="Section 2.1 The Linux Shell"><!---->Section 2.1 The Linux Shell<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/02.html" aria-label="Section 2.2 Linux Help"><!---->Section 2.2 Linux Help<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/03.html" aria-label="Section 2.3 Text Editors"><!---->Section 2.3 Text Editors<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/04.html" aria-label="Section 2.4 Aliases"><!---->Section 2.4 Aliases<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/05.html" aria-label="Section 2.5 Environment Variables"><!---->Section 2.5 Environment Variables<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/06.html" aria-label="Section 2.6 Shell Configuration Files"><!---->Section 2.6 Shell Configuration Files<!----></a><!----></li><li><a class="route-link route-link-active auto-link vp-sidebar-item active" href="/linux/02/07.html" aria-label="Section 2.7 Redirection, Piping and Command Substitution"><!---->Section 2.7 Redirection, Piping and Command Substitution<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/08.html" aria-label="Section 2.8 Directories"><!---->Section 2.8 Directories<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/09.html" aria-label="Section 2.9 Files"><!---->Section 2.9 Files<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/10.html" aria-label="Section 2.10 Links"><!---->Section 2.10 Links<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/11.html" aria-label="Section 2.11 Filesystem Hierarchy Standard (FHS)"><!---->Section 2.11 Filesystem Hierarchy Standard (FHS)<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/12.html" aria-label="Section 2.12 Locating and Searching Files"><!---->Section 2.12 Locating and Searching Files<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/13.html" aria-label="Section 2.13 Text Stream Processing"><!---->Section 2.13 Text Stream Processing<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">3.0 Installation and Localization <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">4.0 Boot and Shutdown <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">5.0 Graphical User Interfaces and Desktops <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">6.0 Software Installation <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">7.0 Users and Groups <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">8.0 Disk and File System Management <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">9.0 Hardware Installation <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">10.0 Processes and System Services <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">11.0 System Monitoring <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">12.0 Networking <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">13.0 Cloud, Containers, and Virtualization <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">14.0 Scripting and Automation <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">15.0 Security <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">A0 Linux Pro - Practice Exams <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">B0 Linux Pro - CompTIA Linux+ <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">Glossary <!----></p><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div class="theme-default-content" vp-content><!--[--><!--]--><div><p>As you study this section, answer the following questions:</p><ul><li>What are the three default file descriptors that Linux uses to classify information for a command?</li><li>What is the difference between redirection and piping?</li><li>When might you choose to redirect the input of a command?</li><li>How can you overcome the 128 KB shell command size restriction?</li></ul><p>In this section, you will learn to:</p><ul><li>Use redirection</li><li>Use piping</li></ul><p>Key terms for this section include the following:</p><table class="terms"><thead><tr><td>Term</td><td>Definition</td></tr></thead><tbody><tr><td>Standard stream</td><td> Preconnected input and output communication channels available to Linux shells and processes. </td></tr><tr><td>stdin</td><td> A standard stream that provides data that is typically streamed from the keyboard. </td></tr><tr><td>stdout</td><td> A standard stream that accepts normal output information to be streamed to the console screen or shell window. </td></tr><tr><td>stderr</td><td> A standard stream that accepts normal error information to be streamed to the console screen or shell window. </td></tr><tr><td>Redirection</td><td> The process of modifying a shell command to divert the standard input, output, and error streams to locations other than the default. </td></tr><tr><td>Piping</td><td> The process of redirecting the output from one command to be the input of another command. </td></tr><tr><td>Here documents</td><td>A block of text that is redirected as input to a command.</td></tr><tr><td>Command substitution</td><td> A feature of the bash shell that substitutes the output of one shell command as the arguments for another shell command. </td></tr></tbody></table><p>This section helps you prepare for the following certification exam objectives:</p><table><thead><tr><td>Exam</td><td>Objective</td></tr></thead><tbody><tr><td>CompTIA Linux+ XK0-005</td><td> 1.1 Summarize Linux fundamentals <ul><li> Device types in /dev <ul><li> Special character devices <ul><li>/dev/null</li><li>/dev/zero</li><li>/dev/urandom</li></ul></li></ul></li></ul><p> 3.1 Given a scenario, create simple shell scripts to automate common tasks. <br></p><ul><li>Shell script elements</li><ul><li>Standard stream redirection</li><ul><li>|</li><li>||</li><li>&gt;</li><li>&gt;&gt;</li><li>&lt;</li><li>&lt;&lt;</li><li>&amp;</li><li>&amp;&amp;</li><li>Redirecting</li><ul><li>stderr</li><li>stdout</li></ul></ul><li>Here documents</li><li> Common script utilities <ul><li>xargs</li></ul></li></ul></ul></td></tr></tbody></table><h2 id="_2-7-1-redirection" tabindex="-1"><a class="header-anchor" href="#_2-7-1-redirection"><span>2.7.1 Redirection</span></a></h2><h3 id="redirection-00-00-00-22" tabindex="-1"><a class="header-anchor" href="#redirection-00-00-00-22"><span>Redirection 00:00-00:22</span></a></h3><p>Redirection provides a very powerful command line tool for data manipulation. In this lesson, we&#39;ll teach you three redirection file descriptors that control how data is input and output in Linux. Let&#39;s get started learning this exiting feature.</p><p>Input and Output File Descriptors 00:22-00:48 There are three main file descriptors for directing both input and output. First is stdin; stdin controls how data is input—like from a file, for example. stdout and stderr both control output. stdout can send normal screen output to a file. stderr controls error output and can send it to a file as well.</p><h3 id="file-descriptors-00-48-01-53" tabindex="-1"><a class="header-anchor" href="#file-descriptors-00-48-01-53"><span>File Descriptors 00:48-01:53</span></a></h3><p>The first file descriptor means standard input, or standard in. This is the input that&#39;s sent to a particular command for it to process. The standard in for any command is represented by the number 0. Typically, stdin is input via information stored in a file. But it can be input from the keyboard, too.</p><p>Next is standard output or standard out. This descriptor represents the normal screen output from a command. Standard out is identified with the number 1. Lastly, we have standard error, which is assigned the number 2. This is the output generated by a command if an error situation comes up. As an example, if I tried to use the ls command to list a file that doesn&#39;t exist, an error message would appear on screen. The Linux shell allows you to manipulate both the input and the two outputs for any given command. Using these three descriptors, you can manipulate where a command gets its input from and where it sends its output to.</p><h3 id="redirect-symbols-01-53-02-57" tabindex="-1"><a class="header-anchor" href="#redirect-symbols-01-53-02-57"><span>Redirect Symbols 01:53-02:57</span></a></h3><p>When we write scripts, it&#39;s common to redirect input from or output to a text file. There are a variety of reasons for this, such as the need to better analyze the two. There are quite a few combinations of numbers and symbols we can use to make this happen. For input, Linux uses the less-than symbol. It looks like an arrow that takes input and provides it to the command.</p><p>Next is the greater-than sign, which redirects output. This is used for both stdout and stderr. If you remember, stdout has a value of 1, and stderr has a value of 2. So, when you redirect stdout, you place a 1 before the output redirect symbol. Similarly, to redirect stderr, you place the number 2 before the redirect symbol. And there&#39;s another symbol for appending data, but we&#39;ll go over that later. Know that by default, Linux receives input from the keyboard and sends output to the screen.</p><h3 id="redirect-output-and-errors-02-57-03-28" tabindex="-1"><a class="header-anchor" href="#redirect-output-and-errors-02-57-03-28"><span>Redirect Output and Errors 02:57-03:28</span></a></h3><p>With commands, there are several reasons you&#39;d want to redirect output. Here, you can see that we&#39;re running the date command and storing the results in a file named date-and-time.txt. Also, the ls command is storing its error output in a file called errmsg.txt. Remember that by default, output is redirected, so in the top command—whether or not the number 1 is used—the output, stdout, is stored in the file.</p><h3 id="redirection-side-effects-03-28-04-08" tabindex="-1"><a class="header-anchor" href="#redirection-side-effects-03-28-04-08"><span>Redirection Side Effects 03:28-04:08</span></a></h3><p>So, there are a few things to consider when redirecting. First, the output file needs to be created if it doesn&#39;t already exist. If the file does exist, it&#39;ll be overwritten. This applies to both stdout and stderr. Also, if you&#39;re redirecting stdout, stderr messages will appear on the screen. Alternatively, if you&#39;re redirecting stderr, stdout will appear on the screen. Lastly, if there&#39;s no data to output, a file will still be created. If it exists, it&#39;ll be overwritten—and all the existing file data will be lost.</p><h3 id="append-data-to-existing-files-04-08-05-06" tabindex="-1"><a class="header-anchor" href="#append-data-to-existing-files-04-08-05-06"><span>Append Data to Existing Files 04:08-05:06</span></a></h3><p>At this point, you&#39;ve learned about redirection and how to create files with stdout or stderr. It&#39;s easy to see that data can easily be overwritten or lost with the information you have so far. Next, we&#39;ll show you how to preserve data during redirection. Say you run some command several times and want to see the changes over time. If you use simple redirection, the output file will be overwritten each time, or you&#39;d have to change the output filename. This can quickly become unwieldy and difficult to manage. Instead, we use another symbol to append.</p><p>There&#39;s one small change to make if you want to preserve data. Rather than using a single redirect symbol, utilize two greater-than signs. Linux will still create the file if it doesn&#39;t exist, but if it does, Linux will append the command&#39;s output to the end of the pre-existing file.</p><h3 id="redirect-output-and-errors-05-06-06-57" tabindex="-1"><a class="header-anchor" href="#redirect-output-and-errors-05-06-06-57"><span>Redirect Output and Errors 05:06-06:57</span></a></h3><p>Oftentimes, when we write shell scripts, the need to redirect both normal and error output is there. You&#39;ve already learned how to do these separately, so the question arises, &quot;What if I want to redirect both?&quot; There&#39;s a simple answer, and one that&#39;s more complex.</p><p>Suppose I run a command to list files. One of the files—in this case, file1—does exist, but file2 does not. When I execute the command, notice that I get both error and normal output. Also notice that the error output is displayed first. This is all normal behavior. But what if I want to redirect both of them?</p><p>The second command shows that both 1 and 2—stdout and stderr—are there for redirection. So in this case, normal output is stored in output.txt, and error output is stored in error.txt. If you were to use the cat command to list the contents of both files, you&#39;d receive something similar to what you see here. You may be asking the question, &quot;What&#39;s the command if I want both normal and error output redirected to the same file?&quot; That gets a bit trickier. Let&#39;s take a look.</p><p>We start off with the same command; we redirect normal output to the file. So far, so good. Now, though, we also want stderr output sent to the same file. In other words, we want stderr output redirected to the same place as stdout. We accomplish this by using a reference variable rather than a filename. The reference variable that contains the filename that stdout is using is &amp;1. Both stdout and stderr will be stored in output.txt.</p><h3 id="redirect-command-input-06-57-07-56" tabindex="-1"><a class="header-anchor" href="#redirect-command-input-06-57-07-56"><span>Redirect Command Input 06:57-07:56</span></a></h3><p>Okay, now you should have a good idea of how output redirection works. Redirecting input isn&#39;t much different. Rather than taking command output and saving it to a file, you can input the contents to create a new file or simply display the contents if you want.</p><p>For example, the employees.dat file contains a list of employees. As you can see, though, this list isn&#39;t in alphabetical order. By running the sort command with the less-than file redirection symbol, the contents of the employees.dat file will be sorted and displayed. If you wanted to save the sorted list to a new file, you could combine input and output redirection in the same command.</p><p>By adding an output redirection symbol and the new file&#39;s name to our previous command, sort will alphabetize the names and then output the results to the new file. You can see that here by displaying the new file&#39;s contents.</p><p>Great! So that wraps up this lesson.</p><h3 id="summary-07-56-08-14" tabindex="-1"><a class="header-anchor" href="#summary-07-56-08-14"><span>Summary 07:56-08:14</span></a></h3><p>We&#39;ve learned about Linux command redirection. We discussed the shell file descriptors and how the greater-than sign redirects output, while the less-than sign redirects input.</p><h2 id="_2-7-2-piping" tabindex="-1"><a class="header-anchor" href="#_2-7-2-piping"><span>2.7.2 Piping</span></a></h2><h3 id="piping-00-00-00-36" tabindex="-1"><a class="header-anchor" href="#piping-00-00-00-36"><span>Piping 00:00-00:36</span></a></h3><p>Piping is an extremely useful tool. Similar to redirection, piping takes the output from one command and uses it as input for another command. Pipes work with any command the produces output, and they&#39;re great when you want to save the results of something you redirected.</p><p>The symbol for piping is the vertical bar. It says to redirect the output from one command to another. The syntax is command 1, followed by the pipe, followed by command 2. Pipes can even be chained to further refine the output. They can also be redirected to save it as well. Let&#39;s look at some examples.</p><h3 id="piping-example-1-00-36-01-05" tabindex="-1"><a class="header-anchor" href="#piping-example-1-00-36-01-05"><span>Piping: Example 1 00:36-01:05</span></a></h3><p>Suppose you wanted to take a look at a log file. Usually, log files are quite large and might consist of several hundred lines. If you were to simply use the cat command, the results would scroll off the page. This obviously wouldn&#39;t work. Instead, you can page through the log file&#39;s contents.</p><p>By piping the output from the cat command to the more command, the output displays a single page and then waits for you to press a key. In other words, it&#39;s possible to view files that contain exorbitant amounts of information with piping.</p><h3 id="piping-example-2-01-05-02-02" tabindex="-1"><a class="header-anchor" href="#piping-example-2-01-05-02-02"><span>Piping: Example 2 01:05-02:02</span></a></h3><p>Whenever you&#39;re trying to diagnose an issue, viewing specific log pages really does help. But it&#39;s still going to be hard to find what you&#39;re looking for. Some log files are so long that it becomes virtually impossible to narrow anything down. Piping can help with this as well.</p><p>In this example, journalctl lists the contents of the systemd journal, which provides information on logins, logouts, access, and failures. Running the journalctl command by itself lists the contents of the entire journal, starting with the oldest entry. This will produce an output consisting of—in this example, at least—3,589 lines. Suppose that you&#39;re having trouble with your Ethernet interface, eth0. By adding grep—which is a content filter—to the mix, you&#39;ll only see journalctl entries that pertain to the eth0 interface. This is a huge help when you&#39;re trying to find what you&#39;re looking for. grep is a common piped command, so it&#39;s good to take note.</p><h3 id="multiple-pipes-in-one-command-02-02-02-48" tabindex="-1"><a class="header-anchor" href="#multiple-pipes-in-one-command-02-02-02-48"><span>Multiple Pipes in One Command 02:02-02:48</span></a></h3><p>Also, when piping, you&#39;re not limited to a single pipe. There may be situations where multiple pipes are required. Let&#39;s go back to the previous example and look at how we can do this.</p><p>In this example, we saw how piping to the grep command allowed us to see only the information that was specific to our needs. Suppose that that output contained too many lines, and it scrolled off the screen. We can fix that with multiple pipes. By adding another pipe and the more command, the scrolling will stop, and you&#39;ll be prompted to press a key to continue reading through the specific journalctl entries. Here, the journalctl output is produced as input for the grep command, which filters the output by specific information. That output is fed as input to the more command, which displays a single screen at a time.</p><h3 id="piping-to-the-tee-command-02-48-03-37" tabindex="-1"><a class="header-anchor" href="#piping-to-the-tee-command-02-48-03-37"><span>Piping to the tee Command 02:48-03:37</span></a></h3><p>There may be times when you want to take output from one command, display it on screen, and then write that information to a file in the file system at the same time. You do this with a command called tee. The syntax for tee is to first run whichever command it is that you&#39;re utilizing, and then you pipe the output from that command to the input of the tee command. Then you just specify the filename you want to write the output to.</p><p>Here, you can see that we simply used the ls –l command to display a file listing of the root directory. If we had used output redirection, the data would be redirected to a text file. In this case, though, we want the output going to both the screen and to an output file. The tee command does just that. It produces output that goes to both the screen and to the specified filename, which is rootdir.txt in this example</p><h3 id="summary-03-37-03-59" tabindex="-1"><a class="header-anchor" href="#summary-03-37-03-59"><span>Summary 03:37-03:59</span></a></h3><p>And that&#39;s all for now on piping. We learned a lot about how to utilize this feature in Linux. To sum it all up, a pipe redirects output from one command to another, and it&#39;s possible to use multiple pipes to refine the output even more. And the tee command is great for output as well, both to the screen and to a file.</p><h2 id="_2-7-3-use-redirection" tabindex="-1"><a class="header-anchor" href="#_2-7-3-use-redirection"><span>2.7.3 Use Redirection</span></a></h2><h3 id="using-redirection-00-00-00-35" tabindex="-1"><a class="header-anchor" href="#using-redirection-00-00-00-35"><span>Using Redirection 00:00-00:35</span></a></h3><p>In this demonstration, we&#39;re going to practice working with redirection with shell commands.</p><p>When you use redirection, you take either the input, the output, or the error messages used by a shell command, and you redirect them to a file in the file system (or from a file in the file system in the case of the input redirection).</p><p>I&#39;m first going to switch to my root user account.</p><p>We&#39;re going to use the boot log file. This file contains messages that are generated as the system boots up.</p><p>To view the last few lines of this file, run tail /var/log/boot.log.</p><h3 id="redirect-standard-out-overwrite-00-35-02-02" tabindex="-1"><a class="header-anchor" href="#redirect-standard-out-overwrite-00-35-02-02"><span>Redirect Standard Out - Overwrite 00:35-02:02</span></a></h3><p>Suppose we wanted to redirect the standard output from this tail command to a file in my home directory named lastboot, so we could save it and look at it later.</p><p>One way to do this is to run this same command again, but this time add a 1, followed by the greater-than sign (&gt;). This tells the command that instead of sending the output to the screen, we want to send the output somewhere else, the file named lastboot.</p><p>When I press Enter, nothing was displayed on the screen. That&#39;s because the standard output was moved from the default of the screen to a file. However, when I run ls, we see that the file named lastboot was created. When I run cat lastboot, we see that it contains the same information we saw earlier.</p><p>When redirecting the standard output, keep in mind that using the number 1 is optional. If you omit the 1, the shell is just going to assume that you want to write the output of the command to a file.</p><p>Let&#39;s run the same command again, but this time omit the 1 and change the filename to lastboot2. Once again, we run the ls command, and we see the lastboot2 file is there. Then we can use the cat command to view it, and we see it&#39;s the same as it was before.</p><p>When using redirection, if the file doesn&#39;t exist, it will be created, and the information written to the file as we just saw. If the file already exists, it will be overwritten with the results of the redirection.</p><h3 id="redirect-standard-out-append-02-02-02-45" tabindex="-1"><a class="header-anchor" href="#redirect-standard-out-append-02-02-02-45"><span>Redirect Standard Out - Append 02:02-02:45</span></a></h3><p>There may be situations where you want to redirect the standard out from a command to a file without overriding the existing contents of the existing file. This can be done using two greater-than symbols instead of one.</p><p>Let&#39;s enter tail /var/log/syslog to see the last few lines of this file. Next, we&#39;ll use two greater-than signs (&gt;&gt;) to append the output of the syslog instead of overwriting the file. To end the command, we need to specify the file we&#39;re appending to, which is the lastboot file.</p><p>When it&#39;s run, there&#39;s no output to the screen. We can run cat lastboot and see that the lines from the syslog have been added to the lastboot file.</p><h3 id="redirect-standard-error-02-45-03-55" tabindex="-1"><a class="header-anchor" href="#redirect-standard-error-02-45-03-55"><span>Redirect Standard Error 02:45-03:55</span></a></h3><p>We can also redirect the standard error of a command. This can only happen if an error message is generated for some reason, and by default, the standard error is written to the screen.</p><p>For example, let&#39;s run cat myfile. Because this file doesn&#39;t exist, an error message is generated and displayed on the screen.</p><p>To redirect the error message from the screen to a file, you run the same command, but this time add a 2 and then the greater-than sign (2&gt;). The number 2 is the value used to redirect output from the standard error, just like 1 was used for standard output. This is followed by the name of the file we want the error message sent to, which in this example, we&#39;ll use errorfile. When I press Enter, nothing is shown on the screen, but when I run ls, we see that the file was created.</p><p>We can also use the double greater-than signs to append the output, even when you&#39;re working with error messages.</p><p>When I run this same command again, but this time use two greater-than signs, the output for this second time is appended to the file, which can be seen when I run cat errorfile. Notice how the &quot;No such file&quot; message is now listed twice.</p><h3 id="combine-redirection-03-55-05-01" tabindex="-1"><a class="header-anchor" href="#combine-redirection-03-55-05-01"><span>Combine Redirection 03:55-05:01</span></a></h3><p>It&#39;s helpful to understand that you can redirect both the standard out and the standard error at the same time if needed.</p><p>To see what I mean, let&#39;s enter tail /var/log/boot.log 1&gt; lastboot. This portion of the command will take the last few lines from the boot.log file and will put them in a file named lastboot. But in addition to that, I also want to create a second file to contain any error messages generated. To do that, I&#39;ll need to add 2 and a greater-than sign (&gt;) to indicate that I want error messages. And if any error messages are generated, I want them to go into a new file named booterror.</p><p>Now when I press Enter, nothing is displayed on the screen because we&#39;re redirecting both the standard output and the error messages to two separate files.</p><p>When I run ls, we see that we not only have the lastboot file, but we also have the booterror file. In this example, the booterror file will be empty because the tail command didn&#39;t generate any errors. If there had been errors, they would&#39;ve been written to that file.</p><h3 id="redirect-with-pipe-05-01-06-32" tabindex="-1"><a class="header-anchor" href="#redirect-with-pipe-05-01-06-32"><span>Redirect with Pipe 05:01-06:32</span></a></h3><p>Another method of redirecting output is to pipe the output to another command.</p><p>For example, if I were to use the cat command to view the contents of the syslog, some of the results would scroll off the page because there&#39;s too much information to fit on one screen. To make it easier to view this file, I can redirect the output of the cat command to the command named more. The more command will then use the information and display the results, one page at a time.</p><p>To see this, let&#39;s run cat /var/log/syslog, but now we&#39;ll redirect its output using the pipe key (|) and then tell the cat command to pipe it to more. Now I can use the spacebar to scroll down through the output, one page at a time.</p><p>The pipe can also be used to create an &quot;or&quot; condition by using two pipe characters together.</p><p>When we run tail /var/log/syslog, and then use two pipe characters (||) followed by tail /var/log/boot.log. We&#39;re telling the computer that if the syslog file exists, show me the results of that file, OR, if it doesn&#39;t exist, show me the results of the boot.log file.</p><p>I&#39;ll press Enter and see that since the syslog file did exist, the contents of that file are shown. Let&#39;s run the command again, but this time we&#39;ll use a file that doesn&#39;t exist. When I press Enter, you see that since the sysx file couldn&#39;t be found, the last few lines of the boot.log file were shown instead.</p><h3 id="redirect-standard-in-06-32-07-11" tabindex="-1"><a class="header-anchor" href="#redirect-standard-in-06-32-07-11"><span>Redirect Standard In 06:32-07:11</span></a></h3><p>Before ending this demonstration, I also want to show you how you can redirect the standard in.</p><p>This allows us to take a file and send it to a particular command as input.</p><p>For example, instead of running cat /var/log/boot.log and piping it to the more command. I can enter more at the beginning of the command and then indicate that the source of the more command will come from the boot.log file by adding a less-than sign (&lt;) and then the path and name of our /var/log/boot.log file.</p><p>Now when I press Enter, the contents of the boot.log file are shown, but they&#39;re shown one page at a time.</p><h3 id="summary-07-11-07-31" tabindex="-1"><a class="header-anchor" href="#summary-07-11-07-31"><span>Summary 07:11-07:31</span></a></h3><p>In this demo, we talked about redirection. We first looked at redirecting the standard out. We then looked at redirecting the standard error. We also discussed how to redirect output using piping. Then we ended this lesson by looking at how to redirect the standard in.</p><h2 id="_2-7-4-use-piping" tabindex="-1"><a class="header-anchor" href="#_2-7-4-use-piping"><span>2.7.4 Use Piping</span></a></h2><h3 id="use-piping-00-00-00-15" tabindex="-1"><a class="header-anchor" href="#use-piping-00-00-00-15"><span>Use Piping 00:00-00:15</span></a></h3><p>In this demonstration, we&#39;re going to look at piping with shell commands. This can be a very useful technique. Piping lets you send the output of one command to the input of another command for processing.</p><h3 id="single-pipe-–-more-00-15-01-50" tabindex="-1"><a class="header-anchor" href="#single-pipe-–-more-00-15-01-50"><span>Single Pipe – more 00:15-01:50</span></a></h3><p>To see how piping works, let&#39;s begin by switching to our root user account so we can work with some files that only root has access to.</p><p>The first thing we&#39;re going to do is to view the contents of a large file using the cat command. This is a log file that&#39;s created as the system boots up, where each boot message that&#39;s generated during the boot-up process is written to it. This file is often use when troubleshooting your system. When I press Enter, notice that the file is displayed, and I&#39;m left at the end of the file. To see the beginning of the file, I need to scroll back up. As I do, you can see that this is a very large file.</p><p>To make this cat command a little more user-friendly, I can use the pipe command to show only one page at a time. This is done by taking the output of the cat command and piping it into a different command. To show you how this works, I&#39;ll use my up-arrow key to return to the cat command and then, on the end, I&#39;ll add a pipe character (|).</p><p>The pipe character can be found on the keyboard directly above the return key. The pipe character tells the shell to take whatever output comes from the original command and send it to the input of whatever command is specified after the pipe character. To get the cat results to show one page at a time, I&#39;ll pipe it to the more command.</p><p>Now, when I press Enter, you see the cat command is displaying the same information, but pipes the output to the more command. The more command then pauses the output after the first screen is displayed. Now, to continue, I just need to press the spacebar to view the next page of information, and I can keep doing that until I&#39;ve either found what I was looking for, or I reach the end of the file.</p><h3 id="single-pipe-–-grep-01-50-02-35" tabindex="-1"><a class="header-anchor" href="#single-pipe-–-grep-01-50-02-35"><span>Single Pipe – grep 01:50-02:35</span></a></h3><p>Piping is also commonly used in conjunction with the grep command. As you may recall, grep can search a plain-text file for the specific text we are looking for. Therefore, we can use the cat command to find all the text in our syslog file, but then used grep to only display the parts of the file for which we&#39;re looking.</p><p>For example, if I were troubleshooting my Ethernet interface, I may want to see whether it was activated during boot-up.To do that, I&#39;d use the same cat command we used earlier, but this time, I&#39;ll pipe it to the grep command instead of the more command. Next, I need to tell grep what I&#39;m looking for, so I&#39;ll add eth0, which is the name of my Ethernet interface.And when I press Enter, you see that only the lines from the syslog file that contain eth0 are displayed.</p><h3 id="create-a-text-stream-02-35-03-41" tabindex="-1"><a class="header-anchor" href="#create-a-text-stream-02-35-03-41"><span>Create a Text Stream 02:35-03:41</span></a></h3><p>The piping option can also be used to chain multiple commands together. This means that you can take the output of one command, send it to the input of another command, and then take the output of the second command and send it on to a third command, and so on. Chaining commands like this can be done as many times as needed to get the desired information. This is called creating a text stream.</p><p>To see how text streaming works, let&#39;s use the same pipe command we used before to find everything to do with our Ethernet interface, but this time, add another pipe symbol and the more command.</p><p>Before we press Enter, let&#39;s review what this command will do. First, you see that cat will display the contents of the syslog file, but then that output will be piped to grep. The grep command will then filter out anything that doesn&#39;t contain eth0. Then the next pipe command will take that filtered output from grep and display it on the screen one page at a time using the more command.</p><p>Let&#39;s now press Enter to see the results. As you can see, each line contains the word eth0, and I&#39;m able to scroll through each page, one at a time, by pressing the spacebar.</p><h3 id="summary-03-41-03-59" tabindex="-1"><a class="header-anchor" href="#summary-03-41-03-59"><span>Summary 03:41-03:59</span></a></h3><p>That&#39;s it for this demonstration. In this demo, we discussed how to use piping at the shell prompt. First, we talked about how to create a single pipe with an input and an output. Then we talked about how to chain multiple pipes together to create a text stream.</p><h2 id="_2-7-5-redirection-and-piping-facts" tabindex="-1"><a class="header-anchor" href="#_2-7-5-redirection-and-piping-facts"><span>2.7.5 Redirection and Piping Facts</span></a></h2><p>Redirection and piping are two Linux shell features that allow the input and output of a command to be a file or another command.</p><p>This lesson covers the following topics:</p><ul><li>Standard streams and bash shell file descriptors</li><li>Redirection</li><li>Piping</li><li>The tee command</li><li>Here documents</li><li>Device files often used with redirection and piping</li></ul><h3 id="standard-streams-and-bash-shell-file-descriptors" tabindex="-1"><a class="header-anchor" href="#standard-streams-and-bash-shell-file-descriptors"><span>Standard Streams and Bash Shell File Descriptors</span></a></h3><p>The bash shell maintains three standard data streams, which are pre-connected input and output communication channels. Unless configured otherwise, bash commands use the following standard streams:</p><ul><li>Standard input (stdin) is data that is typically streamed from the keyboard. If a bash command accepts input, by default, it is gathered from stdin.</li><li>Standard output (stdout) is data that is typically streamed to the console screen. By default, bash commands send their output to stdout.</li><li>Standard error (stderr) is data that is also typically streamed to the console screen. If a command needs to output an error messages or give diagnostics, by default, it sends this output to stderr.</li></ul><p>The bash shell assigns a file descriptor to each of the standard streams. A file descriptor is a handle or number that identifies an open file or other data source and how that resource can be accessed. The following table summarizes these ideas.</p><table><thead><tr><td>Standard Stream</td><td>File Descriptor</td><td>Associated Device</td></tr></thead><tbody><tr><td>stdin</td><td>0</td><td>Keyboard</td></tr><tr><td>stdout</td><td>1</td><td>Console screen or graphical shell window</td></tr><tr><td>stderr</td><td>2</td><td>Console screen or graphical shell window</td></tr></tbody></table><h3 id="redirection" tabindex="-1"><a class="header-anchor" href="#redirection"><span>Redirection</span></a></h3><p>Linux commands can be modified to divert the standard input, output, and error streams to locations other than the default. This process is called redirection and is implemented using the following command operators:</p><table><thead><tr><td>Command Operator</td><td>Description</td></tr></thead><tbody><tr><td><b>&gt;</b> and <b>1&gt;</b></td><td> Redirects command output that is normally sent to stdout to the file name that follows the operator. The 1 is implied so that <b>&gt;</b> and <b>1&gt;</b> are functionally identical. <ul><li> If the file that follows the operator exists, it is overwritten. </li><li>If the file doesn&#39;t exist, it is created.</li><li> If there is no output generated by the command, the file will be empty. </li></ul></td></tr><tr><td><b>2&gt;</b></td><td> Redirects command output that is normally sent to stderr to the file name that follows the operator. The <b>2</b> is mandatory. <ul><li> If the file that follows the operator exists, it is overwritten. </li><li>If the file doesn&#39;t exist, it is created.</li><li> If there is no error generated by the command, the file will be empty. </li></ul></td></tr><tr><td><b>&gt;&gt;</b> , <b>1&gt;&gt;</b> and <b>2&gt;&gt;</b></td><td> The <b>&gt;&gt;</b> operator functions in the same way as the <b>&gt;</b> operator except that any output/errors are appended to the file that follows the operator. <ul><li> The <b>&gt;&gt;</b> and <b>1&gt;&gt;</b> operators appends the output sent to stdout. </li><li> The <b>2&gt;&gt;</b> operator appends the output sent to stderr. </li><li> If the file that follows the operator exists, it is appended with the output/error. </li><li>If the file doesn&#39;t exist, it is created.</li><li> The file will be not be appended if there is no output/errors generated by the command. <br></li></ul></td></tr><tr><td><b>&amp;&gt;</b></td><td> Redirects both command output that is normally sent to stdout and command errors that are normally sent to stderr to the file name that follows the operator. <ul><li> As part of a command, <b>&amp;&gt; myfile.txt</b> is equivalent to <b>&gt; myfile.txt 2&gt; &amp;1</b> or <b>&gt; myfile.txt 2&gt; myfile.txt</b> . </li><li> File creation follows the rules for the <b>&gt;</b> operator. </li></ul></td></tr><tr><td><b>&amp;&gt;&gt;</b></td><td> The <b>&amp;&gt;&gt;</b> operator functions in the same way as the <b>&amp;&gt;</b> operator except that both output and errors are appended to the file that follows the operator. <ul><li> As part of a command, <b>&amp;&gt;&gt; myfile.txt</b> is equivalent to <b>&gt;&gt; myfile.txt 2&gt;&gt; &amp;1</b> (where <b>&amp;</b> indicates that what follows is a file descriptor and not a filename) or <b>&gt;&gt; myfile.txt 2&gt;&gt; myfile.txt</b> . </li><li> File creation follows the rules for the <b>&gt;</b> operator. </li></ul></td></tr><tr><td><b>&lt;</b> and <b>0&lt;</b></td><td> Redirects command input that is normally read from stdin so that it is read from the file name that follows the operator. The 0 is implied so that <b>&lt;</b> and <b>0&lt;</b> are functionally identical. <ul><li> If the file that follows the operator exists, it is used as input. </li><li>If the file doesn&#39;t exist, an error is shown.</li><li> If there is no input needed by the command, the file is ignored. </li></ul></td></tr></tbody></table><p>The following examples demonstrate redirection concepts.</p><table><thead><tr><td>Example</td><td>Result</td></tr></thead><tbody><tr><td><b>ls /usr &gt; /tmp/deleteme</b></td><td> Writes the list of files in the /usr directory to a file named /tmp/deleteme. </td></tr><tr><td><b>ls /nonesuch &gt; /tmp/deleteme</b></td><td> Creates an empty /tmp/deleteme file (or overwrites it as an empty file if it exists) and displays the error message <i>/nonesuch not found</i> (because the /nonesuch directory does not exist). </td></tr><tr><td><b>ls /nonesuch 2&gt; /tmp/deleteme</b></td><td> Writes the error message <i>/nonesuch not found</i> (because the /nonesuch directory does not exist) to a file named /tmp/deleteme. The /tmp/deleteme file will be overwritten if it already exists. </td></tr><tr><td><b>ls /bin /nonesuch &gt; /tmp/deleteme</b></td><td> Writes a listing of the files and directories within the /bin directory to the /tmp/deleteme file and displays the error message <i>/nonesuch not found</i> to the console screen or shell window. The /tmp/deleteme file will be overwritten if it already exists. </td></tr><tr><td><b>ls /bin /nonesuch &gt; /tmp/deleteme 2&gt;&amp;1</b></td><td> Writes a listing of the files and directories within the /bin directory to the /tmp/deleteme file and also writes the error message <i>/nonesuch not found</i> to the /tmp/deleteme file. Both the list of files and directories within the /bin directory and the error message are written to the same file. </td></tr><tr><td><b>ls /bin &gt;&gt; /tmp/deleteme</b></td><td> Appends the list of files from the /usr directory to the /tmp/deleteme file. The /tmp/deleteme file will be created if it does not exist. </td></tr><tr><td><b>sort &lt; unordered.txt &gt; ordered.txt</b></td><td> Uses the contents of the unordered.txt as input to the <b>sort</b> command, and then writes the sorted contents to the file named ordered.txt. If the ordered.txt file already exists, it will be overwritten. </td></tr></tbody></table><h3 id="piping" tabindex="-1"><a class="header-anchor" href="#piping"><span>Piping</span></a></h3><p>Piping redirects the output from one command to be the input of another command.</p><ul><li>A Linux pipe is represented by a vertical bar ( <b>|</b> ).</li><li>The pipe functionality is similar to that of using stdout redirection to write the output of one command to an intermediate file, that is then used as input to a second command, using stdin redirection.</li><li>A plumbing pipe, where water enters from one end and exits the other, can be used as a mnemonic to help explain how the pipe (|) operator works.</li></ul><h3 id="the-tee-command" tabindex="-1"><a class="header-anchor" href="#the-tee-command"><span>The tee Command</span></a></h3><p>There may be times when you want to view the output of a command as it is normally sent to the console screen (stdout), but you also want the same output to be saved in a file. This can be done using the tee command.</p><ul><li>The output from a command is piped to the tee command.</li><li>The file used to store the output is added as a tee command argument.</li><li>A plumbing tee, where water flow is divided from one pipe to two separate pipes, can help you understand how the tee command works.</li></ul><p>The following examples demonstrate tee command concepts.</p><table><thead><tr><td>Example</td><td>Result</td></tr></thead><tbody><tr><td><b>ls /bin | tee binfiles.txt</b></td><td> Displays the files and directories contained in the /bin directory on the console screen (or shell window) and writes the same information to the binfiles.txt file. </td></tr><tr><td><b>ls -1 *.txt | wc -l | tee count.txt</b></td><td> Pipes a one-column list of files that end with <i>.txt</i> in the current directory to the wc (word count) command and then take that output, which gives the number of files in the list, and pipes that to the tee command that displays this number on the console screen (or shell window) and writes the same number to the count.txt file. </td></tr></tbody></table><h3 id="here-documents" tabindex="-1"><a class="header-anchor" href="#here-documents"><span>Here Documents</span></a></h3><p>A here document is a block of text that is redirected as input to a command. Here documents are often used in shell scripts.</p><ul><li> A command is followed by the <b>&lt;&lt;</b> operator, which is then followed by a marker, which is traditionally an uppercase word. <div><div><div><div class="to-icon large" aria-hidden="true" style="width:20px;"><svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div><div><span> The term <i>here document</i> may have origins in the practice of using the word <i>HERE</i> as the marker.</span></div></div></div></div></li><li>Lines of text are included in the block.</li><li> The end of the block of text is indicated by the same marker that follows the <b>&lt;&lt;</b> operator. </li><li>The shell passes the block of text to the command as input.</li></ul><p>The following examples demonstrate here document concepts.</p><table><thead><tr><td>Example</td><td>Explanation</td></tr></thead><tbody><tr><td><b>cat &lt;&lt; HERE <br>&gt; Today, we hope you are <br>&gt; learning a great deal <br>&gt; about Linux redirection <br>&gt; and piping from TestOut. <br>&gt;HERE </b></td><td> The following lines are displayed on the console screen or shell window: <p> Today, we hope you are <br> learning a great deal <br> about Linux redirection <br> and piping from TestOut. </p><p> This may be useful when creating shell scripts that present explanations and documentation to users. </p></td></tr><tr><td><b>lftp machine -uUser,Passwd &lt;&lt;END<br>cd your_dir<br>get your_file<br>bye<br>END</b></td><td> Multiple commands are entered during an ftp session. These commands are managed using the lftp program. This may be helpful when automating a long list of ftp commands. </td></tr></tbody></table><h3 id="device-files-often-used-with-redirection-and-piping" tabindex="-1"><a class="header-anchor" href="#device-files-often-used-with-redirection-and-piping"><span>Device Files Often Used with Redirection and Piping</span></a></h3><p>Device files are file-like access points to hardware devices. There are two device files that are often used with redirection and piping: <code>/dev/tty</code> and <code>/dev/null</code></p><table><thead><tr><td>Device File</td><td>Description</td></tr></thead><tbody><tr><td><b>/dev/tty</b></td><td>The first terminals were Teletype (abbreviated as<i>tty</i>), which can be compared to a remote controlled typewriter. The /dev/tty device file is associated with the computer&#39;s controlling terminal or the shell&#39;s window. <ul><li>Data can be both written to and read from this file.</li><li>Text written to this file is displayed on the console monitor&#39;s screen or shell window.</li><li>Text read from this file originates from the console&#39;s keyboard.</li><li>The <b>/dev/tty</b> device file is similar to a combination of stdin and stdout. Both stdin and stdout are accessed as data streams, whereas <b>/dev/tty</b> is accessed like a file.</li></ul></td></tr><tr><td><b>/dev/null</b></td><td>The /dev/null device file is associate with a null device. A null device is commonly used for disposing unwanted output streams. <ul><li>While a command can read from <b>/dev/null</b> , commands typically write unwanted output or unwanted error messages to<b>/dev/null</b> .</li><li>A slang word for the <b>/dev/nul</b> device file is bit bucket.</li></ul></td></tr><tr><td><b>/dev/zero</b></td><td>Similar to /dev/null, /dev/zero discards any input. It also returns a &quot;0&quot; for however many times it is accessed. It is most commonly used for: <ul><li>Initializing a new block device</li><li>Overwriting existing data</li></ul></td></tr><tr><td><b>/dev/urandom</b></td><td> Returns a pseudo-random number. Frequently used when performing cryptographic (encryption) tasks.</td></tr></tbody></table><h3 id="dev-tty" tabindex="-1"><a class="header-anchor" href="#dev-tty"><span>/dev/tty</span></a></h3><table><thead><tr><td>Example</td><td>Explanation</td></tr></thead><tbody><tr><td><b>echo &quot;test&quot; &gt; /dev/tty</b></td><td>Writes the word <i>test</i> to the console or to a shell windows. This is redundant, since the echo command by itself performs the same action.</td></tr><tr><td><b>sort &lt; /dev/tty &gt; sortkeyboard.txt</b></td><td> The text entered using the keyboard is sorted and written to the sortkeyboard.txt file. <div><div><div>? <div><span>The <b>&lt; /dev/tty</b> operation will continue to accept keyboard input until the user enters an end-of-file (EOF) sequence using the Ctrl+D key combination.</span></div></div></div></div></td></tr><tr><td><b>rm deleteme.txt 2&gt; /dev/null</b></td><td>Deletes the <b>deleteme.txt</b> file if it exists. If it doesn&#39;t exist, don&#39;t display an error message. <div><div><div>? <div><span>This logic is often used in shell scripts to suppress error messages that are not important to the script&#39;s overall purpose.</span></div></div></div></div></td></tr></tbody></table><h2 id="_2-7-6-command-substitution" tabindex="-1"><a class="header-anchor" href="#_2-7-6-command-substitution"><span>2.7.6 Command Substitution</span></a></h2><h3 id="command-substitution-00-00-00-23" tabindex="-1"><a class="header-anchor" href="#command-substitution-00-00-00-23"><span>Command Substitution 00:00-00:23</span></a></h3><p>In this lesson, we&#39;ll discuss an important feature of the Bash shell. This shell allows for command substitution, which means that you can have the output of one command pasted back into the command line as an argument for another command. This lets you perform multiple tasks with a single input. It sounds complicated, right? Let&#39;s go over this concept to make it more clear.</p><h3 id="how-command-substitution-works-00-23-00-50" tabindex="-1"><a class="header-anchor" href="#how-command-substitution-works-00-23-00-50"><span>How Command Substitution Works 00:23-00:50</span></a></h3><p>Command substitution works by first creating and then running a child process. Then, the standard output from the command is piped back to the Bash shell. The shell parses the output from the first command into words that are separated by white space. Once the pipe from the first command closes, the shell starts another child process to run the second command, only this time, it uses the standard out from the first command as its arguments. Let&#39;s look at an example.</p><h3 id="case-study-tail-command-00-50-01-20" tabindex="-1"><a class="header-anchor" href="#case-study-tail-command-00-50-01-20"><span>Case Study: tail Command 00:50-01:20</span></a></h3><p>Here we need to use the tail command to view the last few lines of all the files in the /etc directory that contain the text ens192—that&#39;s the name of our network interface. We first want to grab the filenames and send that list as input to the tail command.</p><p>We can do this in one of two ways. First, you could manually run the fgrep command and then run the tail command. You&#39;d pipe the output from the fgrep command to a file and then send the name of that file&#39;s input to the tail command. This option takes the most work.</p><h3 id="solution-command-substitution-01-20-02-14" tabindex="-1"><a class="header-anchor" href="#solution-command-substitution-01-20-02-14"><span>Solution: Command Substitution 01:20-02:14</span></a></h3><p>The second way is to use command substitution. Here&#39;s an example. First, enter tail. Then enter a dollar sign. Then, in parenthesis, type in the first command that you want to run. In this case, that&#39;s fgrep. After that, you&#39;d tell it to search all the files in the /etc directory for the text string ens192.</p><p>Notice that we used the -l -r options in this example. By default, fgrep returns the matching text. All we want here is the filenames of all files that contain the matching text. The -l option tells fgrep to do this. And the -r option tells it to search through all the subdirectories of the one directory we specified, which was /etc. The result is a list of files that contain the matching text, which is sent as input to the tail command. tail takes this list and displays the last few lines of each file.</p><h3 id="command-substitution-vs-the-xargs-command-02-14-02-53" tabindex="-1"><a class="header-anchor" href="#command-substitution-vs-the-xargs-command-02-14-02-53"><span>Command Substitution vs. the xargs Command 02:14-02:53</span></a></h3><p>Another option for command substitution in the Bash shell is the xargs command. This is useful because the maximum length of a Bash command is 128 kilobytes, and if this limitation is broken, it can cause the command substitution to fail. When this 128-kilobyte limitation is exceeded—which is imposed by the Linux kernel—you get an &quot;Argument list too long&quot; error. This means that the first command piped too many results back to the second command.</p><p>In this situation, you should use xargs instead of command substitution. xargs breaks down a long command line into 128-kilobyte chunks and then passes one chunk at a time as an argument to the specified command.</p><h3 id="case-study-find-and-rm-commands-02-53-03-30" tabindex="-1"><a class="header-anchor" href="#case-study-find-and-rm-commands-02-53-03-30"><span>Case Study: find and rm Commands 02:53-03:30</span></a></h3><p>For example, we have a Linux system that&#39;s being used heavily for productivity. There&#39;s an Office suite installed on it for word processing documents, presentation files, spreadsheets, and more. This is causing the home directory to get choked up with a huge volume of backup files. On Linux, backup files from Office applications usually end in a tilde.</p><p>To clean this all up, we want to use the find command to create a list of files that end in a tilde and then use the rm command to delete them. Using command substitution could work if you&#39;re under the 128-kilobyte limit. But our example here is likely to exceed this.</p><h3 id="solution-xargs-command-03-30-04-11" tabindex="-1"><a class="header-anchor" href="#solution-xargs-command-03-30-04-11"><span>Solution: xargs Command 03:30-04:11</span></a></h3><p>To prevent an error from happening, we&#39;d use xargs. We&#39;d run the find command first and tell it to start looking in the home directory. We&#39;ll have it search for any files in the home directory, including all the subdirectories, that end in a tilde. Then we&#39;ll pipe the output from the find command to the input of the xargs command, which will process that text stream 128 kilobits at a time. It&#39;ll send it to the standard input of the rm command. This gives the command a list of files to delete one at a time. So even if the total size of all the files exceeds 128 kilobytes, no errors should occur because xargs broke everything up into small-enough chunks.</p><h3 id="summary-04-11-04-31" tabindex="-1"><a class="header-anchor" href="#summary-04-11-04-31"><span>Summary 04:11-04:31</span></a></h3><p>Great! That&#39;s it for this lesson. We talked about how to run multiple commands at the same time with a single command at the shell prompt. This is called command substitution. And then we talked about using the xargs command to do the same thing with larger inputs.</p><h2 id="_2-7-7-command-substitution-facts" tabindex="-1"><a class="header-anchor" href="#_2-7-7-command-substitution-facts"><span>2.7.7 Command Substitution Facts</span></a></h2><p>Command substitution is a feature of the Bash shell that substitutes the output of one shell command as the arguments for another shell command.</p><p>This lesson covers the following topics:</p><ul><li>Implement command substitution</li><li>The xargs command</li></ul><h3 id="implement-command-substitution" tabindex="-1"><a class="header-anchor" href="#implement-command-substitution"><span>Implement Command Substitution</span></a></h3><h4 id="command" tabindex="-1"><a class="header-anchor" href="#command"><span><code>$(&lt;command&gt;)</code></span></a></h4><ol><li>The shell creates a child process that runs the specified command.</li><li>The stdout from the first command is redirected back to the shell.</li><li>The shell parses the output from the first command into words separated by white space. <div><div><div><div class="to-icon large" aria-hidden="true" style="width:20px;"><svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div><div><span>If the command substitution operator <b>$()</b> appears within single quotes (&#39; &#39;), word parsing is not performed on the output.</span></div></div></div></div></li><li>The shell creates a new command by substituting the parsed output from the first command in place of the<b>$(&lt; <i>command</i> &gt;)</b> operator.</li><li> The shell creates another child process that runs the second command.</li></ol><p>The examples below demonstrate these command substitution concepts.</p><table><thead><tr><th scope="col">Example</th><th scope="col">Explanation</th></tr></thead><tbody><tr><td><b>printf &quot;The date and time is: $(date)\n&quot;</b></td><td> Command substitution occurs when the shell encounters <b>$(date)</b> . The process is as follows: <ol><li> The shell creates a child process and runs the <b>$(date)</b> command. </li><li> The output from the child process is redirected back to the shell, but is not parsed. </li><li> The <b>$(date)</b> operator in the original command is replaced with the output from the child process. </li><li> Another new process is created that runs the <b>printf</b> command with the replaced text. <div><div><div><div class="to-icon large" aria-hidden="true" style="width:20px;"><svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div><div><span> The <b>printf</b> command replaces the <b>\n</b> in double quotes with a newline character.</span></div></div></div></div></li></ol></td></tr><tr><td><b>echo -e &quot;List of logged on users and what they are doing:\n $(w)&quot;</b></td><td> Command substitution occurs when the shell encounters <b>$(w)</b> . The process is as follows: <ol><li> The shell creates a child process and runs the <b>w</b> command. <div><div><div><div class="to-icon large" aria-hidden="true" style="width:20px;"><svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div><div><span> The <b>w</b> command is short for &quot;who&quot; and returns a summary of logged-on users.</span></div></div></div></div></li><li> The output from the child process is redirected back to the shell, but is not parsed. </li><li> The <b>$(w)</b> operator in the original command is replaced with the output from the child process. </li><li> Another new process is created that runs the <b>echo</b> command with the replaced text. <div><div><div><div class="to-icon large" aria-hidden="true" style="width:20px;"><svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div><div><span> The <b>-e</b> option with the <b>echo</b> command causes the <b>\n</b> in double quotes to be replaced with a newline character.</span></div></div></div></div></li></ol></td></tr></tbody></table><h3 id="the-xargs-command" tabindex="-1"><a class="header-anchor" href="#the-xargs-command"><span>The xargs Command</span></a></h3><h4 id="xargs" tabindex="-1"><a class="header-anchor" href="#xargs"><span>xargs</span></a></h4><table><thead><tr><td>Example</td><td>Explanation</td></tr></thead><tbody><tr><td><b>find /home -name *~ | xargs rm</b></td><td>This command deletes all files in all subdirectories of the /home directory that end with the tilde (~) character. <ol><li>The <b>find /home -name *~</b> command returns a list of all the files in all the subdirectories under the /home directory that end with the tilde (~) character.</li><li>The file list is piped as a stream to the <b>xargs</b> command.</li><li>The <b>xargs</b> command collects the first 128-KB chunk from the stream.</li><li>The <b>rm</b> command is run using the 128-KB chunk as an argument.</li><li>The <b>xargs</b> command continues to collect 128-KB chunks from the stream and continues to run the <b>rm</b> command using the chunks until the end of the stream.</li></ol></td></tr><tr><td><b>ls -S *.txt | xargs wc</b></td><td>When there are large number of *.txt files in a directory, this command displays a list of all the files along with the number of lines/words/characters in each. The list is sorted by size, with the largest files shown first. <ol><li>The <b>ls -S *.txt</b> command returns the list of files sorted from largest to smallest.</li><li>The file list is piped as a stream to the <b>xargs</b> command.</li><li>The <b>xargs</b> command collects the first 128-KB chunk from the stream.</li><li>The <b>wc</b> command is run using the 128-KB chunk as an argument.</li><li>The <b>xargs</b> command continues to collect 128-KB chunks from the stream and continues to run the <b>wc</b> command using the chunks until the end of the stream.</li></ol></td></tr></tbody></table></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></div></footer><nav class="vp-page-nav" aria-label="page navigation"><a class="route-link auto-link prev" href="/linux/02/06.html" aria-label="Section 2.6 Shell Configuration Files"><div class="hint"><span class="arrow left"></span> Prev</div><div class="link"><span>Section 2.6 Shell Configuration Files</span></div></a><a class="route-link auto-link next" href="/linux/02/08.html" aria-label="Section 2.8 Directories"><div class="hint">Next <span class="arrow right"></span></div><div class="link"><span>Section 2.8 Directories</span></div></a></nav><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/linux/assets/app-B0K3Hfci.js" defer></script>
  </body>
</html>
