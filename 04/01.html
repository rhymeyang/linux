<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.15" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme')
      const systemDarkMode =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (userMode === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (userMode === 'dark' || systemDarkMode) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>Section 4.1 Linux Boot Process | Security Pro</title><meta name="description" content="some description">
    <link rel="preload" href="/linux/assets/style-DY6JTdq5.css" as="style"><link rel="stylesheet" href="/linux/assets/style-DY6JTdq5.css">
    <link rel="modulepreload" href="/linux/assets/app-DARZRMzR.js"><link rel="modulepreload" href="/linux/assets/01.html-4Wz-fn-R.js">
    <link rel="prefetch" href="/linux/assets/index.html-C2ga3lpZ.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-CjwIVV2w.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-CxACkFz6.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-Dt4glSvg.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-oqMbzLVE.js" as="script"><link rel="prefetch" href="/linux/assets/02.html--mOCWCl5.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-Bv86koGs.js" as="script"><link rel="prefetch" href="/linux/assets/04.html-Ticb19sb.js" as="script"><link rel="prefetch" href="/linux/assets/05.html-D7NY7Z-y.js" as="script"><link rel="prefetch" href="/linux/assets/06.html-DbuKPoqi.js" as="script"><link rel="prefetch" href="/linux/assets/07.html-pHQPka0P.js" as="script"><link rel="prefetch" href="/linux/assets/08.html-CSGKsgWC.js" as="script"><link rel="prefetch" href="/linux/assets/09.html-BEQYdk4M.js" as="script"><link rel="prefetch" href="/linux/assets/10.html-fSVFp0Cu.js" as="script"><link rel="prefetch" href="/linux/assets/11.html-ByseIyGn.js" as="script"><link rel="prefetch" href="/linux/assets/12.html-pckAlwXO.js" as="script"><link rel="prefetch" href="/linux/assets/13.html-CWPezKqO.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-DBe3gZ5W.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-BneLv4b7.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-D3VFamLa.js" as="script"><link rel="prefetch" href="/linux/assets/temp.html-DMCw_w_r.js" as="script"><link rel="prefetch" href="/linux/assets/404.html-ByYsRJ_w.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/linux/"><img class="vp-site-logo" src="/linux/images/leaf.svg" alt="Security Pro"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">Security Pro</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../linux/" aria-label="Linux Pro"><!---->Linux Pro<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../security_pro/" aria-label="Security Pro"><!---->Security Pro<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../tools/" aria-label="Tools"><!---->Tools<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../english-starter/" aria-label="English"><!---->English<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../Se/" aria-label="Semester 3"><!---->Semester 3<!----></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../linux/" aria-label="Linux Pro"><!---->Linux Pro<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../security_pro/" aria-label="Security Pro"><!---->Security Pro<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../tools/" aria-label="Tools"><!---->Tools<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../english-starter/" aria-label="English"><!---->English<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../Se/" aria-label="Semester 3"><!---->Semester 3<!----></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">Info <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/" aria-label="Linux Pro"><!---->Linux Pro<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">0.0 Linux Pro Introduction <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/00/01.html" aria-label="Section 0.1 Course Introduction"><!---->Section 0.1 Course Introduction<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/00/02.html" aria-label="Section 0.2 The TestOut Lab Simulator"><!---->Section 0.2 The TestOut Lab Simulator<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">1.0 Linux Overview <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/01/01.html" aria-label="Section 1.1 Linux Introduction"><!---->Section 1.1 Linux Introduction<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">2.0 Using Linux <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/01.html" aria-label="Section 2.1 The Linux Shell"><!---->Section 2.1 The Linux Shell<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/02.html" aria-label="Section 2.2 Linux Help"><!---->Section 2.2 Linux Help<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/03.html" aria-label="Section 2.3 Text Editors"><!---->Section 2.3 Text Editors<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/04.html" aria-label="Section 2.4 Aliases"><!---->Section 2.4 Aliases<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/05.html" aria-label="Section 2.5 Environment Variables"><!---->Section 2.5 Environment Variables<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/06.html" aria-label="Section 2.6 Shell Configuration Files"><!---->Section 2.6 Shell Configuration Files<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/07.html" aria-label="Section 2.7 Redirection, Piping and Command Substitution"><!---->Section 2.7 Redirection, Piping and Command Substitution<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/08.html" aria-label="Section 2.8 Directories"><!---->Section 2.8 Directories<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/09.html" aria-label="Section 2.9 Files"><!---->Section 2.9 Files<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/10.html" aria-label="Section 2.10 Links"><!---->Section 2.10 Links<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/11.html" aria-label="Section 2.11 Filesystem Hierarchy Standard (FHS)"><!---->Section 2.11 Filesystem Hierarchy Standard (FHS)<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/12.html" aria-label="Section 2.12 Locating and Searching Files"><!---->Section 2.12 Locating and Searching Files<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/13.html" aria-label="Section 2.13 Text Stream Processing"><!---->Section 2.13 Text Stream Processing<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">3.0 Installation and Localization <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">4.0 Boot and Shutdown <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">5.0 Graphical User Interfaces and Desktops <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">6.0 Software Installation <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">7.0 Users and Groups <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">8.0 Disk and File System Management <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">9.0 Hardware Installation <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">10.0 Processes and System Services <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">11.0 System Monitoring <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">12.0 Networking <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">13.0 Cloud, Containers, and Virtualization <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">14.0 Scripting and Automation <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">15.0 Security <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">A0 Linux Pro - Practice Exams <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">B0 Linux Pro - CompTIA Linux+ <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">Glossary <!----></p><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div class="theme-default-content" vp-content><!--[--><!--]--><div><p>As you study this section, answer the following questions:</p><ul><li>What are the three general stages of the boot process?</li><li>When is the initramfs image loaded into memory?</li><li>What is the default initial program?</li><li>Which component mounts the root partition?</li><li>What is the process ID of the initial program?</li><li>Where is the primary bootloader located?</li></ul><p>Key terms for this section include the following:</p><table class="terms"><thead><tr><th>Term</th><th>Definition</th></tr></thead><tbody><tr><td> Basic Input/Output System <br> (BIOS) </td><td> A basic program that starts up a computer system. BIOS is a legacy system that&#39;s been replaced by UEFI. </td></tr><tr><td> Unified Extensible Firmware Interface <br> (UEFI) </td><td> A basic program that starts up a computer system. UEFI has replaced BIOS. </td></tr><tr><td>Boot</td><td> The act of starting up a computer (also referred to as powering the computer on). </td></tr><tr><td>Firmware</td><td> Software that&#39;s embedded in hardware, usually on a read-only memory (ROM) chip. </td></tr><tr><td> Boot manager/ <br> bootloader </td><td> A software program that controls the process of loading the operating system. </td></tr><tr><td> Complementary metal-oxide semiconductor <br> (CMOS) </td><td> A technology for constructing integrated circuits. It refers to the system configuration that&#39;s stored in a battery-powered memory chip on computers. </td></tr><tr><td> Power-On Self Test <br> (POST) </td><td> A software process that verifies that computer hardware works properly. </td></tr><tr><td> Globally Unique Identifier <br> (GUID) </td><td> A label that software programs use to identify the location of a data object. </td></tr><tr><td> Master Boot Record <br> (MBR) </td><td> A legacy system that refers to the boot sector on a hard disk or other storage device. The boot sector contains the files required to start a computer. </td></tr><tr><td> Extensible Firmware Interface System Partition <br> (ESP) </td><td> The partitioning scheme used by UEFI. ESP is the format used for the boot sector where the operating system and utilities for starting a computer are stored. </td></tr><tr><td>init</td><td> init is the first process that&#39;s started when booting a Linux system. init is a daemon process that continues running until the system is shut down. It&#39;s the direct or indirect ancestor of all other processes and automatically adopts all orphaned processes. init is a legacy process that&#39;s been replaced by systemd. </td></tr><tr><td>initramfs</td><td> initramfs is used as the first root file system that your machine has access to. It&#39;s used for mounting the real rootfs, which has all of your data. </td></tr><tr><td> Root <br> partition </td><td> The partition at the top of the directory tree, which contains all of the programs and files necessary for running Linux. This is the root file system that&#39;s represented by a forward slash (/). </td></tr></tbody></table><p>This section helps you prepare for the following certification exam objectives:</p><table class="objectives"><thead><tr><th>Exam</th><th>Objective</th></tr></thead><tbody><tr><td>TestOut Linux Pro</td><td> 1.3 Manage system startup and shutdown <ul><li>Manage bootloader configurations</li></ul></td></tr><tr><td>CompTIA Linux+ XK0-005</td><td> 1.1 Summarize Linux fundamentals <br><ul><li>Basic boot process</li><ul><li>Basic Input/Output System (BIOS)</li><li>Unified Extensible Firmware Interface (UEFI)</li><li> Comands <ul><li>initrd.img</li><li>vmlinuz</li><li>mkinitrd</li><li>dracut</li></ul></li><li>Grand Unified Bootloader</li><li>Boot sources</li><ul><li>Preboot eXecution (PXE)</li><li>Booting from Universal</li><li>Booting from ISO</li><li>Booting from Universal Serial Bus (USB)</li></ul></ul><li> Device types in /dev <ul><li>Block devices</li><li>Character devices</li></ul></li></ul></td></tr></tbody></table><h2 id="_4-1-1-linux-boot-process" tabindex="-1"><a class="header-anchor" href="#_4-1-1-linux-boot-process"><span>4.1.1 Linux Boot Process</span></a></h2><p>Click one of the buttons to take you to that part of the video.</p><p>Linux Boot Process 00:00-00:23 It is important to understand how an OS boots. Different Linux distributions may have slight differences, so we&#39;re going to look at the generic boot process in this lesson. We&#39;ll examine the boot loader, the boot target, and the service files and daemons loaded during a boot-up. Configuring how the Linux system boots is a key skill for system administrators.</p><p>Linux Boot Process 00:23-00:37 To make the Linux boot process a little more digestible, we&#39;re going to break it down into the three phases that you see here. First, we&#39;re going to look at the hardware boot phase, then the bootloader phase, and we&#39;ll end with the kernel phase.</p><p>Linux Boot Process â€“ Hardware Boot Phase 00:37-01:46 With Linux or any other OS, the first step when starting the system is the hardware boot phase. When you power on your system, it goes through a process to make sure the hardware is working properly. This is the POST, or Power On Self Test, step in running your Basic Input/Output system, or BIOS. During this phase, components such as the keyboard and mouse, CPU and RAM, I/O ports, and video are tested to make sure they&#39;re all operational. If an error occurs, your system will either beep or display an error message.</p><p>Once the POST process completes, the system boot device takes control. This device may be internal storage, an optical disk, a USB device, or an SD card. The device is usually configured in the system configuration, or it can be chosen at boot time with a key press.</p><p>Up to this point, the system&#39;s startup routine is, generally, the same as other operating systems. The process then moves to the boot device to start Linux. Traditionally, systems used BIOS to configure their systems. While there are still systems configured with legacy BIOS, UEFI or Unified Extensible Firmware Interface, is more secure and provides many improvements over legacy BIOS.</p><p>Bootloader Phase 01:46-02:45 Once the system&#39;s hardware has been tested, control is given to the boot device. While the boot device may differ, it contains code that allows the system to start the operating system. This is the job of the bootloader. The bootloader loads code into RAM allowing the operating system to take over control of the hardware. This code may differ from distribution to distribution and is different than other operating systems.</p><p>After the bootloader begins loading its code, it creates a temporary virtual file system in your system RAM called a RAM disk. And, depending on your distribution, this image will either be called initrd, for initial RAM disk, or initramfs, for initial RAM file system. Both perform the same function which is to load a basic image used to load the Linux OS. This image contains just enough to get things started such as loading specific drivers for networking, video, or other specific hardware in the system. At this point, the Linux kernel is started and control of the hardware is transitioned to the kernel.</p><p>Kernel Phase 02:45-03:32 Once the bootloader process completes, control has been given to the kernel. The kernel is the core of the operating system. While there are many different distros available, the Linux kernel is not significantly changed. The kernel uses the RAM disk to load all the modules required to initialize the system and load necessary daemons and other programs.</p><p>At this point, the RAM disk is no longer needed so it dismounts and destroys it to reclaim the used memory. The kernel then mounts the root file system and starts probing for new hardware and loading the appropriate drivers.</p><p>Lastly, it starts the initialization process, systemd. Systemd is used to initialize the system, define the systemd target, and whether to load additional programs and daemons. At this point, the system is considered &quot;booted&quot; and you are prompted to login.</p><p>Summary 03:32-03:45 That&#39;s it for this lesson. In this lesson, we reviewed the Linux boot process. We looked at the hardware boot, bootloader, and kernel phases of the boot process.</p><h2 id="_4-1-2-linux-boot-process-facts" tabindex="-1"><a class="header-anchor" href="#_4-1-2-linux-boot-process-facts"><span>4.1.2 Linux Boot Process Facts</span></a></h2><p>Understanding the overall boot process can be beneficial when you need to configure boot loaders, boot targets, and service files that govern the way daemons are loaded. Basic Input/Output System (BIOS) is the firmware specification that was originally used by personal computers to initiate the boot process. The Unified Extensible Firmware Interface (UEFI) was developed to address the shortcomings of BIOS. UEFI has replaced BIOS and is now the standard used by computer manufacturers to govern the boot process.</p><p>This lesson covers the following topics:</p><ul><li>UEFI boot</li><li>BIOS boot</li><li>vmlinux/vmlinuz</li></ul><h3 id="uefi-boot" tabindex="-1"><a class="header-anchor" href="#uefi-boot"><span>UEFI Boot</span></a></h3><p>UEFI (previously known as the EFI) is a firmware specification that defines the process for booting computer systems. It is the interface between a computer system&#39;s hardware/firmware and the operating system. Some of the features provided by UEFI include the following:</p><ul><li>It provides support for larger disks using the <i class="fs-italicize">Globally Unique Identifier Partition Table</i> (GPT) partition scheme. The MBR partitioning scheme used by BIOS supported only four partitions per disk, with a maximum size of 2 TB per partition. UEFI supports a maximum partition size of 9.4 ZB (9.4 x 10 <sup>21</sup> bytes).</li><li>It provides its own boot manager. This is a significant change. The old BIOS had only enough intelligence to load a single block from the storage device. This required a multi-stage boot process. UEFI has its own command interpreter and boot manager. You no longer need a dedicated boot loader as long as you place the operating system&#39;s bootable files into the EFI system partition (ESP), which is formatted with a FAT file system.</li><li>It preserves several components from the traditional BIOS, including power management and a real-time clock.</li></ul><p>The following table identifies the phases during a UEFI boot.</p><table><thead><tr><th>Phase</th><th>Process</th></tr></thead><tbody><tr><td>UEFI</td><td> The following steps take place during the UEFI boot process: <ol><li> Power is supplied to the processor. The processor is hard-coded to look at a special memory address for code to execute. </li><li> This memory address contains a pointer or jump program that instructs the processor where to find the UEFI program. (The mount point for the EFI system partition is usually /boot/efi, where its content is accessible after Linux is booted.) </li><li>The processor loads the UEFI program.</li><li> UEFI runs the power-on self-test (POST). If the POST is successful, UEFI identifies other system devices. It uses the CMOS system clock and information supplied by the devices themselves to identify and configure hardware devices. Plug and Play devices are allocated system resources. The system typically displays information about the keyboard, mouse, and IDE drives in the system. Following this summary, information about devices and system resources is displayed. </li><li> UEFI reads the GUID partition table, which is located in the blocks immediately after block 0. The GUID partition table defines the layout of the partition table on the storage device. </li><li> Using this information, the UEFI boot loader locates the ESP which contains the boot loader files or kernel images for all operating systems that are installed on other partitions on the device. ESP also contains device driver files for hardware devices on the computer that are used by the firmware at boot, system utility programs to be run before the operating system is booted, and data files, including error logs. <div><div><div><div class="to-icon large" aria-hidden="true" style="width:20px;"><svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div><div><span> To boot Linux, you would use a UEFI-aware version of the GRUB bootloader and install its boot file (grub.efi) in the EFI system partition.</span></div></div></div></div></li></ol></td></tr><tr><td>Boot loader</td><td> During the boot loader stage, UEFI gives control to the boot loader program. The following steps take place: <ol><li>UEFI loads the boot loader code.</li><li> When the boot loader is in RAM and executing, a splash screen is commonly displayed, and an optional initial RAM disk (e.g., initrd or initramfs image) is loaded into memory. The initramfs image is used with new distributions. Initramfs: <ul><li> Is a custom version of the init program, containing all the drivers and tools needed at boot. </li><li> Is created by mkinitrd. Mkinitrd uses dracut to reduce boot times by using special tools and enabling udev to create device nodes for system hardware. </li><li> Has root permissions that can be used to access the actual /root file system regardless of whether it exists on the local computer or an external device. Without the permissions, the computer could not access the file systems and read information that exists only on those file systems. </li><li> Is used to mount the file system and load the kernel into RAM. </li></ul></li><li> With the images ready, the boot loader invokes the kernel image. </li></ol></td></tr><tr><td>OS Kernel</td><td> During this stage, the Linux kernel takes over. The kernel: <ol><li>Resides in the /EFI directory.</li><li>Initializes the hardware on the system.</li><li> Locates and loads the initrd script to access the linuxrc program, which configures the operating system. </li><li> Dismounts and erases the RAM disk image. On older distributions, this is the initrd image. On newer distributions, this is the initramfs image. </li><li>Looks for new hardware and loads the drivers.</li><li>Mounts the root partition.</li><li> Loads and executes either the init (Initial) process (for older distributions) or the systemd process (for newer distributions). These processes then launch all other processes (either directly or indirectly) to finish booting the system. </li></ol><div><div><div><div class="to-icon large" aria-hidden="true" style="width:20px;"><svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div><div><span> The init (Initial) or systemd processes are always assigned a process ID of 1 because they are always the first processes to run on the system.</span></div></div></div></div></td></tr></tbody></table><h3 id="bios-boot" tabindex="-1"><a class="header-anchor" href="#bios-boot"><span>BIOS Boot</span></a></h3><p>The BIOS process has been used for decades. You may find older hardware that still uses this system. Be aware that recent computer systems no longer use this process but use UEFI instead.</p><p>The following table identifies the phases during a BIOS boot.</p><table id="table1"><thead><tr><th>Phase</th><th>Process</th></tr></thead><tbody><tr><td>BIOS</td><td> In the BIOS stage, BIOS is loaded, and the system hardware is identified. The following steps take place: <ol><li> Power is supplied to the processor. The processor is hard-coded to look at a special memory address for code to execute. </li><li> This memory address contains a pointer or jump program that instructs the processor where to find the BIOS program. </li><li> The processor loads the BIOS program. The first BIOS process to run is the power-on self-test (POST). </li><li> If the POST is successful, the BIOS identifies other system devices. It uses CMOS settings and information supplied by the devices themselves to identify and configure hardware devices. Plug and Play devices are allocated system resources. The system typically displays information about the keyboard, mouse, and IDE drives in the system. Following this summary, information about devices and system resources is displayed. </li><li> The BIOS then searches for a boot sector, using the boot order specified in the CMOS. </li></ol></td></tr><tr><td>Boot loader</td><td> During the boot loader stage, BIOS gives control to the boot loader program. The following steps take place: <ol><li> BIOS searches the boot sector, which contains a Master Boot Record (MBR). </li><li>BIOS loads the primary bootloader code from the MBR.</li><li> The primary bootloader does one of the following: <ul><li> It examines the partition table marked as bootable, and then loads the boot sector from that partition. This boot sector contains a secondary boot loader, which locates an OS kernel. </li><li> It locates an OS kernel directly without using a secondary boot loader. </li></ul></li><li> When the secondary boot loader is in RAM and executing, a splash screen is commonly displayed, and an optional initial RAM disk (e.g., initrd image) is loaded into memory. The initrd image: <ul><li> Has root permissions that can be used to access the actual /root file system regardless of whether it exists on the local computer or an external device. Without the permissions, the computer could not access the file systems and read information that only exists on those file systems. </li><li> Is used to mount the actual file system and load the kernel into RAM. </li></ul></li><li> With the images ready, the secondary boot loader invokes the kernel image. </li></ol></td></tr><tr><td>OS Kernel</td><td> During this stage, the Linux kernel takes over. The kernel: <ol><li>Resides in the /boot directory.</li><li>Initializes the hardware on the system.</li><li> Locates and loads the initrd script to access the linuxrc program, which configures the operating system. </li><li> Dismounts and erases the RAM disk image. On older distributions, this is the initrd image. On newer distributions, this is the initramfs image. </li><li>Looks for new hardware and loads the drivers.</li><li>Mounts the root partition.</li><li> Loads and executes either the init (Initial) process (for older distributions) or the systemd process (for newer distributions). These processes then launch all other processes (either directly or indirectly) to finish booting the system. </li></ol><div><div><div><div class="to-icon large" aria-hidden="true" style="width:20px;"><svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div><div><span> The init (Initial) or systemd processes are always assigned a process ID of 1 because they are always the first processes to run on the system.</span></div></div></div></div></td></tr></tbody></table></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></div></footer><!----><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/linux/assets/app-DARZRMzR.js" defer></script>
  </body>
</html>
