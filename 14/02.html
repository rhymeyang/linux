<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.15" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme')
      const systemDarkMode =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (userMode === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (userMode === 'dark' || systemDarkMode) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>Section 14.2 Shell Environments, Bash Variables and Parameters | Linux Pro</title><meta name="description" content="some description">
    <link rel="preload" href="/linux/assets/style-DY6JTdq5.css" as="style"><link rel="stylesheet" href="/linux/assets/style-DY6JTdq5.css">
    <link rel="modulepreload" href="/linux/assets/app-CsWvKd9L.js"><link rel="modulepreload" href="/linux/assets/02.html-CllDkhNZ.js">
    <link rel="prefetch" href="/linux/assets/index.html-DNfC3OpR.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-DlRAHWBA.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-BVeA-TUj.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-BjZ-6AzD.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-Dta59RhN.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-BLJu3SqT.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-BIfbmwil.js" as="script"><link rel="prefetch" href="/linux/assets/04.html-pXSOwON1.js" as="script"><link rel="prefetch" href="/linux/assets/05.html-C9MQtyY7.js" as="script"><link rel="prefetch" href="/linux/assets/06.html-GhfLXkMo.js" as="script"><link rel="prefetch" href="/linux/assets/07.html-F_yEySa3.js" as="script"><link rel="prefetch" href="/linux/assets/08.html-CKsdyH4o.js" as="script"><link rel="prefetch" href="/linux/assets/09.html-7RE7qTEx.js" as="script"><link rel="prefetch" href="/linux/assets/10.html-D9Q3LSOh.js" as="script"><link rel="prefetch" href="/linux/assets/11.html-BTGKtuE6.js" as="script"><link rel="prefetch" href="/linux/assets/12.html-D-VYpLqE.js" as="script"><link rel="prefetch" href="/linux/assets/13.html-C3TkJ56C.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-DCYx2JMx.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-TzB2e-Hu.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-CbF7-RXL.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-DOTje6Dc.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-CgT-LZUd.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-x7-P5ZwY.js" as="script"><link rel="prefetch" href="/linux/assets/04.html-B5g1cHT7.js" as="script"><link rel="prefetch" href="/linux/assets/05.html-C6GVO8VB.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-DHYCt8LE.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-BA8eTywX.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-CRUWxp4O.js" as="script"><link rel="prefetch" href="/linux/assets/04.html-DtkaBr8c.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-C5ZcTieh.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-Biehb4T1.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-Nuk-6X-f.js" as="script"><link rel="prefetch" href="/linux/assets/04.html-V_Io5m5C.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-HSR-hSm1.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-CUNh_U-d.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-CdehzQCB.js" as="script"><link rel="prefetch" href="/linux/assets/04.html-ZzilVJo3.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-CHl0Bai8.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-DWjePN8c.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-BPgeTZgr.js" as="script"><link rel="prefetch" href="/linux/assets/04.html-CHWu-6qr.js" as="script"><link rel="prefetch" href="/linux/assets/05.html-DncVL_py.js" as="script"><link rel="prefetch" href="/linux/assets/06.html-dtonAS7a.js" as="script"><link rel="prefetch" href="/linux/assets/07.html-xub5KFAc.js" as="script"><link rel="prefetch" href="/linux/assets/08.html-CsUjk3iM.js" as="script"><link rel="prefetch" href="/linux/assets/09.html-EVd_aFym.js" as="script"><link rel="prefetch" href="/linux/assets/10.html-7AnOM-M8.js" as="script"><link rel="prefetch" href="/linux/assets/11.html-BCgJyRLC.js" as="script"><link rel="prefetch" href="/linux/assets/12.html-B1_6sTql.js" as="script"><link rel="prefetch" href="/linux/assets/13.html-BfWiCZis.js" as="script"><link rel="prefetch" href="/linux/assets/14.html-M8PA3ad8.js" as="script"><link rel="prefetch" href="/linux/assets/15.html-PV9wpIX3.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-3ENC_H0u.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-BqUZVOrM.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-SKKn8rob.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-Cq7QHawl.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-DWUNadzP.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-CovqP8yW.js" as="script"><link rel="prefetch" href="/linux/assets/04.html-CDQWVuMx.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-P13dE6sS.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-BwxkJ5-n.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-D7NsGHXG.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-Bv33V3c0.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-Dcmx5deR.js" as="script"><link rel="prefetch" href="/linux/assets/04.html-KGKz5yTc.js" as="script"><link rel="prefetch" href="/linux/assets/05.html-BVxA7zYT.js" as="script"><link rel="prefetch" href="/linux/assets/06.html-BToH-NoP.js" as="script"><link rel="prefetch" href="/linux/assets/07.html-CEjZyCJF.js" as="script"><link rel="prefetch" href="/linux/assets/08.html-D41J5yTQ.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-CwgtQd0q.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-C260D3l_.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-DPrpWyS8.js" as="script"><link rel="prefetch" href="/linux/assets/04.html-BoTIYLhj.js" as="script"><link rel="prefetch" href="/linux/assets/05.html-DYxz7BVs.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-B0S16kFp.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-Dj9LOzJa.js" as="script"><link rel="prefetch" href="/linux/assets/04.html-BCJ3r32w.js" as="script"><link rel="prefetch" href="/linux/assets/05.html-CAaWweKK.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-D7VR1PpI.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-DO3QIpaE.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-aVmJ3MlL.js" as="script"><link rel="prefetch" href="/linux/assets/04.html-Cm7gyb4y.js" as="script"><link rel="prefetch" href="/linux/assets/05.html-DcPSi3Uo.js" as="script"><link rel="prefetch" href="/linux/assets/06.html-K4XPVAtD.js" as="script"><link rel="prefetch" href="/linux/assets/07.html-C-FjC9J5.js" as="script"><link rel="prefetch" href="/linux/assets/08.html-B2tBCUIv.js" as="script"><link rel="prefetch" href="/linux/assets/09.html-Bl3KeC1w.js" as="script"><link rel="prefetch" href="/linux/assets/10.html-BPZlKtFK.js" as="script"><link rel="prefetch" href="/linux/assets/11.html-BaHLyRfa.js" as="script"><link rel="prefetch" href="/linux/assets/12.html-DUoqfFbQ.js" as="script"><link rel="prefetch" href="/linux/assets/13.html-D7AKR4WF.js" as="script"><link rel="prefetch" href="/linux/assets/14.html-CbQC8QSg.js" as="script"><link rel="prefetch" href="/linux/assets/temp.html-nrZf0ogR.js" as="script"><link rel="prefetch" href="/linux/assets/404.html-BfFplXDw.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/linux/"><img class="vp-site-logo" src="/linux/images/leaf.svg" alt="Linux Pro"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">Linux Pro</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../linux/" aria-label="Linux Pro"><!---->Linux Pro<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../security_pro/" aria-label="Security Pro"><!---->Security Pro<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../tools/" aria-label="Tools"><!---->Tools<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../english-starter/" aria-label="English"><!---->English<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../Se/" aria-label="Semester 3"><!---->Semester 3<!----></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../linux/" aria-label="Linux Pro"><!---->Linux Pro<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../security_pro/" aria-label="Security Pro"><!---->Security Pro<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../tools/" aria-label="Tools"><!---->Tools<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../english-starter/" aria-label="English"><!---->English<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../Se/" aria-label="Semester 3"><!---->Semester 3<!----></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">Info <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/" aria-label="Linux Pro"><!---->Linux Pro<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">0.0 Linux Pro Introduction <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/00/01.html" aria-label="Section 0.1 Course Introduction"><!---->Section 0.1 Course Introduction<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/00/02.html" aria-label="Section 0.2 The TestOut Lab Simulator"><!---->Section 0.2 The TestOut Lab Simulator<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">1.0 Linux Overview <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/01/01.html" aria-label="Section 1.1 Linux Introduction"><!---->Section 1.1 Linux Introduction<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">2.0 Using Linux <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/01.html" aria-label="Section 2.1 The Linux Shell"><!---->Section 2.1 The Linux Shell<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/02.html" aria-label="Section 2.2 Linux Help"><!---->Section 2.2 Linux Help<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/03.html" aria-label="Section 2.3 Text Editors"><!---->Section 2.3 Text Editors<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/04.html" aria-label="Section 2.4 Aliases"><!---->Section 2.4 Aliases<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/05.html" aria-label="Section 2.5 Environment Variables"><!---->Section 2.5 Environment Variables<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/06.html" aria-label="Section 2.6 Shell Configuration Files"><!---->Section 2.6 Shell Configuration Files<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/07.html" aria-label="Section 2.7 Redirection, Piping and Command Substitution"><!---->Section 2.7 Redirection, Piping and Command Substitution<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/08.html" aria-label="Section 2.8 Directories"><!---->Section 2.8 Directories<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/09.html" aria-label="Section 2.9 Files"><!---->Section 2.9 Files<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/10.html" aria-label="Section 2.10 Links"><!---->Section 2.10 Links<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/11.html" aria-label="Section 2.11 Filesystem Hierarchy Standard (FHS)"><!---->Section 2.11 Filesystem Hierarchy Standard (FHS)<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/12.html" aria-label="Section 2.12 Locating and Searching Files"><!---->Section 2.12 Locating and Searching Files<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/13.html" aria-label="Section 2.13 Text Stream Processing"><!---->Section 2.13 Text Stream Processing<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">3.0 Installation and Localization <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/03/01.html" aria-label="Section 3.1 Linux System Design"><!---->Section 3.1 Linux System Design<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/03/02.html" aria-label="Section 3.2 Linux Installation"><!---->Section 3.2 Linux Installation<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/03/03.html" aria-label="Section 3.3 Localization"><!---->Section 3.3 Localization<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">4.0 Boot and Shutdown <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/04/01.html" aria-label="Section 4.1 Linux Boot Process"><!---->Section 4.1 Linux Boot Process<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/04/02.html" aria-label="Section 4.2 Bootloaders"><!---->Section 4.2 Bootloaders<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/04/03.html" aria-label="Section 4.3 systemd Boot Targets"><!---->Section 4.3 systemd Boot Targets<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/04/04.html" aria-label="Section 4.4 System Services"><!---->Section 4.4 System Services<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/04/05.html" aria-label="Section 4.5 System Shutdown"><!---->Section 4.5 System Shutdown<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">5.0 Graphical User Interfaces and Desktops <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/05/01.html" aria-label="Section 5.1 Graphical User Interfaces"><!---->Section 5.1 Graphical User Interfaces<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/05/02.html" aria-label="Section 5.2 Linux Desktops"><!---->Section 5.2 Linux Desktops<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/05/03.html" aria-label="Section 5.3 Remote Desktop"><!---->Section 5.3 Remote Desktop<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/05/04.html" aria-label="Section 5.4 Accessibility"><!---->Section 5.4 Accessibility<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">6.0 Software Installation <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/06/01.html" aria-label="Section 6.1 Red Hat Package Manager (RPM)"><!---->Section 6.1 Red Hat Package Manager (RPM)<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/06/02.html" aria-label="Section 6.2 Online Package Installation"><!---->Section 6.2 Online Package Installation<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/06/03.html" aria-label="Section 6.3 Debian Package Manager (dpkg)"><!---->Section 6.3 Debian Package Manager (dpkg)<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/06/04.html" aria-label="Section 6.4 Shared Libraries"><!---->Section 6.4 Shared Libraries<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">7.0 Users and Groups <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/07/01.html" aria-label="Section 7.1 User and Group Overview"><!---->Section 7.1 User and Group Overview<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/07/02.html" aria-label="Section 7.2 User Management"><!---->Section 7.2 User Management<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/07/03.html" aria-label="Section 7.3 Group Management"><!---->Section 7.3 Group Management<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/07/04.html" aria-label="Section 7.4 Troubleshoot User Issues"><!---->Section 7.4 Troubleshoot User Issues<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">8.0 Disk and File System Management <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/01.html" aria-label="Section 8.1 Storage Concepts"><!---->Section 8.1 Storage Concepts<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/02.html" aria-label="Section 8.2 MBR Disk Partitions"><!---->Section 8.2 MBR Disk Partitions<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/03.html" aria-label="Section 8.3 GUID Partitions"><!---->Section 8.3 GUID Partitions<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/04.html" aria-label="Section 8.4 Logical Volume Manager"><!---->Section 8.4 Logical Volume Manager<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/05.html" aria-label="Section 8.5 File Systems"><!---->Section 8.5 File Systems<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/06.html" aria-label="Section 8.6 Mounting File Systems"><!---->Section 8.6 Mounting File Systems<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/07.html" aria-label="Section 8.7 File System Maintenance"><!---->Section 8.7 File System Maintenance<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/08.html" aria-label="Section 8.8 Disk Quotas"><!---->Section 8.8 Disk Quotas<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/09.html" aria-label="Section 8.9 Ownership"><!---->Section 8.9 Ownership<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/10.html" aria-label="Section 8.10 Permissions"><!---->Section 8.10 Permissions<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/11.html" aria-label="Section 8.11 The umask Command"><!---->Section 8.11 The umask Command<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/12.html" aria-label="Section 8.12 Special Permissions"><!---->Section 8.12 Special Permissions<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/13.html" aria-label="Section 8.13 Access Control Lists"><!---->Section 8.13 Access Control Lists<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/14.html" aria-label="Section 8.14 Archive and Backup"><!---->Section 8.14 Archive and Backup<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/15.html" aria-label="Section 8.15 Troubleshooting Storage"><!---->Section 8.15 Troubleshooting Storage<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">9.0 Hardware Installation <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/09/01.html" aria-label="Section 9.1 Device Drivers"><!---->Section 9.1 Device Drivers<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/09/02.html" aria-label="Section 9.2 Kernel Module Management"><!---->Section 9.2 Kernel Module Management<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/09/03.html" aria-label="Section 9.3 Hotplug and Coldplug Devices"><!---->Section 9.3 Hotplug and Coldplug Devices<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">10.0 Processes and System Services <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/10/01.html" aria-label="Section 10.1 Processes"><!---->Section 10.1 Processes<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/10/02.html" aria-label="Section 10.2 Process Management"><!---->Section 10.2 Process Management<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/10/03.html" aria-label="Section 10.3 Task Management"><!---->Section 10.3 Task Management<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/10/04.html" aria-label="Section 10.4 System Time Configuration"><!---->Section 10.4 System Time Configuration<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">11.0 System Monitoring <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/11/01.html" aria-label="Section 11.1 System Logging"><!---->Section 11.1 System Logging<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/11/02.html" aria-label="Section 11.2 Resource Monitoring"><!---->Section 11.2 Resource Monitoring<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">12.0 Networking <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/12/01.html" aria-label="Section 12.1 IPv4 Overview"><!---->Section 12.1 IPv4 Overview<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/12/02.html" aria-label="Section 12.2 Network Interface Configuration"><!---->Section 12.2 Network Interface Configuration<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/12/03.html" aria-label="Section 12.3 NetworkManager"><!---->Section 12.3 NetworkManager<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/12/04.html" aria-label="Section 12.4 IPv6 Overview"><!---->Section 12.4 IPv6 Overview<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/12/05.html" aria-label="Section 12.5 Routing Configuration"><!---->Section 12.5 Routing Configuration<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/12/06.html" aria-label="Section 12.6 Hostname and DNS Configuration"><!---->Section 12.6 Hostname and DNS Configuration<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/12/07.html" aria-label="Section 12.7 Linux Firewalls"><!---->Section 12.7 Linux Firewalls<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/12/08.html" aria-label="Section 12.8 Network Troubleshooting"><!---->Section 12.8 Network Troubleshooting<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">13.0 Cloud, Containers, and Virtualization <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/13/01.html" aria-label="Section 13.1 Cloud and Virtualization Overview"><!---->Section 13.1 Cloud and Virtualization Overview<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/13/02.html" aria-label="Section 13.2 Virtual Machines"><!---->Section 13.2 Virtual Machines<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/13/03.html" aria-label="Section 13.3 Sandboxed Applications"><!---->Section 13.3 Sandboxed Applications<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/13/04.html" aria-label="Section 13.4 Containers"><!---->Section 13.4 Containers<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/13/05.html" aria-label="Section 13.5 Virtual Networking"><!---->Section 13.5 Virtual Networking<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading active">14.0 Scripting and Automation <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/14/01.html" aria-label="Section 14.1 Bash Shell Scripting"><!---->Section 14.1 Bash Shell Scripting<!----></a><!----></li><li><a class="route-link route-link-active auto-link vp-sidebar-item active" href="/linux/14/02.html" aria-label="Section 14.2 Shell Environments, Bash Variables and Parameters"><!---->Section 14.2 Shell Environments, Bash Variables and Parameters<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/14/03.html" aria-label="Section 14.3 Bash Scripting Logic"><!---->Section 14.3 Bash Scripting Logic<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/14/04.html" aria-label="Section 14.4 Version Control Using Git"><!---->Section 14.4 Version Control Using Git<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/14/05.html" aria-label="Section 14.5 Orchestration Processes and Concepts"><!---->Section 14.5 Orchestration Processes and Concepts<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">15.0 Security <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/15/01.html" aria-label="Section 15.1 Root Usage"><!---->Section 15.1 Root Usage<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/15/02.html" aria-label="Section 15.2 User Security and Restriction"><!---->Section 15.2 User Security and Restriction<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/15/03.html" aria-label="Section 15.3 Login Blocking"><!---->Section 15.3 Login Blocking<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/15/04.html" aria-label="Section 15.4 Network Security"><!---->Section 15.4 Network Security<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/15/05.html" aria-label="Section 15.5 OpenSSH"><!---->Section 15.5 OpenSSH<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/15/06.html" aria-label="Section 15.6 SSH Port Tunneling"><!---->Section 15.6 SSH Port Tunneling<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/15/07.html" aria-label="Section 15.7 Security-Enhanced Linux (SELinux)"><!---->Section 15.7 Security-Enhanced Linux (SELinux)<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/15/08.html" aria-label="Section 15.8 Application Armor (AppArmor)"><!---->Section 15.8 Application Armor (AppArmor)<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/15/09.html" aria-label="Section 0.2 The TestOut Lab Simulator"><!---->Section 0.2 The TestOut Lab Simulator<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/15/10.html" aria-label="Section 0.2 The TestOut Lab Simulator"><!---->Section 0.2 The TestOut Lab Simulator<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/15/11.html" aria-label="Section 0.2 The TestOut Lab Simulator"><!---->Section 0.2 The TestOut Lab Simulator<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">A0 Linux Pro - Practice Exams <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">B0 Linux Pro - CompTIA Linux+ <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">Glossary <!----></p><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div class="theme-default-content" vp-content><!--[--><!--]--><div><p>As you study this section, answer the following questions:</p><ul><li>What happens when a shell environment is spawned?</li><li>How are shell variables added to a shell process?</li><li>What is the difference between a PID and a PPID?</li><li>What are some of the common commands used when working with environment variables?</li><li>What is the difference between a shell variable and an environment variable?</li><li>In relation to a shell, what are positional parameters?</li></ul><p>In this lesson, you will learn to:</p><ul><li>Use variables and parameters in a Bash script</li><li>Use shell arithmetic in a Bash script</li><li>Use arrays, variable expansions, and command substitution in a Bash script</li></ul><p>Key terms for this section include the following:</p><table class="terms"><thead><tr><th>Term</th><th>Definition</th></tr></thead><tbody><tr><td>Environment variable</td><td>A Bash variable that is inherited by child shells.</td></tr><tr><td>Shell variable</td><td>A Bash variable usually added by a shell startup script.</td></tr><tr><td>Interactive shell</td><td> A shell that a user can interact with through stdin (the keyboard) and stdout (the display screen) that runs the Bash startup scripts. </td></tr><tr><td>Login shell</td><td> An interactive shell that requires the user to enter a user ID and password. </td></tr><tr><td>Non-login shell</td><td> An interactive shell that does not require the user to enter a user ID and password. </td></tr><tr><td>Non-interactive shell</td><td> A shell that does not interact with the user (e.g., a shell that runs a script). </td></tr><tr><td>Positional parameter</td><td> A series of special variables that contain the arguments given when the shell is invoked or when a script is run. </td></tr><tr><td>Special parameters</td><td> A set of special variables that are maintained by the shell and contain values such as the number of positional parameters, the status of the last executed command, etc. </td></tr><tr><td>Integer variable</td><td> A variable that can be assigned a value based on the results of a shell arithmetic equation. </td></tr><tr><td>Shell arithmetic</td><td> A feature of the Bash shell that evaluates arithmetic expressions. </td></tr></tbody></table><p>This section helps you prepare for the following certification exam objectives:</p><table class="objectives"><thead><tr><th>Exam</th><th>Objective</th></tr></thead><tbody><tr><td>TestOut</td><td> 1.2 Configure and use Linux shell environments <br><ul><li>Manage environment variables</li></ul></td></tr><tr><td>CompTIA Linux+ XK0-005</td><td> 3.1 Given a scenario, create simple shell scripts to automate common tasks <br><ul><li> Shell script elements <ul><li>Loops</li><li>for</li><li>Shell parameter expansion</li><ul><li>Brace expansions</li></ul><li>Comparisons</li><ul><li>Arithmetic</li><li>String</li><li>Boolean</li></ul><li>Variables</li></ul></li><li> Environment variables <ul><li>$SHELL</li><li>$?</li></ul></li></ul></td></tr></tbody></table><h2 id="_14-2-1-bash-shell-environments-and-shell-variables" tabindex="-1"><a class="header-anchor" href="#_14-2-1-bash-shell-environments-and-shell-variables"><span>14.2.1 Bash Shell Environments and Shell Variables</span></a></h2><p>Click one of the buttons to take you to that part of the video.</p><p>Bash Shell Environments and Shell Variables 00:00-00:41 One of the important tools available to a Linux administrator is shell scripting. A well-crafted script can save you time and reduce errors when you&#39;re configuring services or performing other complex administrative tasks. You&#39;ll find that the most helpful scripts are ones that automate the repetitive tasks you find yourself doing every day, like adding new users.</p><p>To write helpful shell scripts, you need a good understanding of the environment that the script runs in. In this lesson, we&#39;re going to talk about some of the building blocks of shell scripting, shell environments, environment variables, and shell variables as they relate to the bash shell. These concepts also apply to other shells, as they all function similarly.</p><p>Shell Environment 00:41-01:25 Let&#39;s start by describing a shell environment. Linux is a multi-processing operating system, and each shell environment is spawned as a process. As a process is created, environment information is gathered from a variety of files and settings on the system, and it&#39;s made available to the shell process. This shell environment is implemented as key-value pairs or environment variables. Each environment variable has a name that&#39;s assigned a value or multiple values. By convention, the name of an environment variable is written in uppercase. If you create custom variables using lowercase names, you are less likely to accidently modify an environment variable.</p><p>It&#39;s important to understand how environment variables are added to a shell process, but how this works depends on the shell environment type.</p><p>Shell Environment Types 01:25-02:18 If you&#39;ve interacted with a Linux console or a terminal window, you&#39;re familiar with an interactive shell environment. An interactive shell reads from standard-input (the keyboard) and writes to standard-output (the display screen). There are two kinds of interactive shells. If you&#39;re required to provide a user ID and password, the environment is classified as a login shell. If not, it&#39;s a non-login shell. If you logged in using the Linux console or through a remote SSH session, it&#39;s a login shell. An example of a non-login shell is when you open a terminal window in the Gnome desktop environment.</p><p>There&#39;s one more shell environment type, the non-interactive shell. One way this shell environment is used is when a cron job starts. And here&#39;s the big secret: it&#39;s also used when a shell script is run. Linux creates a new process, initiates a shell environment, and runs the script in that environment.</p><p>Bash Shell Startup Files 02:18-02:59 You&#39;re probably aware of the shell startup files that are run when a bash shell is initiated. There are bash startup files that are run for all users, like /etc/profile and /etc/bashrc, and hidden bash startup files that are specific to each user, like .bash_profile and .bashrc, which are found in the user&#39;s home directory. Here&#39;s another big secret: these bash files only run for interactive shells. This means that bash scripts running in a non-interactive shell environment can&#39;t rely on any configurations that are implemented in the startup scripts. This brings up an important question: how do you add the configurations the bash script needs?</p><p>Environment Variables 02:59-03:40 One important way to do this is with environment variables. Each Linux process has a parent process. You can see the parent process ID, or PPID, for your process using the ps -f command. Here&#39;s the third big secret: when you run a script and a child shell is created, it inherits environment variables from its parent process.</p><p>There&#39;s a couple of caveats to this. Any environment variable added to the parent shell after the child shell is created won&#39;t be available to the child shell. Also, the child shell can manipulate these environment variables without affecting the parent&#39;s environment variables. Essentially, a copy of the parent shell&#39;s environment variables is given to the child shell.</p><p>Create Environment Variables 03:40-04:29 Environment variables are mostly used by the shell. For example, the PATH environment variable is a list of directories used when the shell searches for executable files, and HOSTNAME is the name the shell uses when referring to the host. The printenv command displays a list of environment variables.</p><p>To create an environment variable to be used by a script, on one line, you enter the variable&#39;s name followed by the equal sign and then the value you&#39;d like to assign to the name. This creates a shell variable. To make it an inheritable environment variable, on the next line, you use the export command followed by the variable name. Alternately, you can create and export an environment variable at the same time using the declare -x command.</p><p>This environment variable can be referenced in a script since it&#39;s inherited by any child shells.</p><p>Shell Variables 04:29-06:25 Many people confuse shell variables with environment variables, since their names are in uppercase and they seem to be available in every shell session. The HISTFILE shell variable is a good example of a shell variable. It points to the file where past shell commands used in an interactive shell are stored. Another example is PS1, which contains the characters used to define the appearance of the shell prompt used in an interactive shell.</p><p>Shell variables aren&#39;t inherited like environment variables. There are a few that are explicitly created by the bash shell when it&#39;s invoked. But most are created by shell startup scripts.</p><p>One way to see the difference between environment variables and shell variables is to run two commands, printenv and set, and compare the results. The printenv command lists only environment variables, while the set command lists all variables, including environment variables. Any variable listed in the set command output that isn&#39;t in the print-env output is, strictly, a shell variable.</p><p>Another way to see the difference is to add the printenv command to a script. If you run printenv interactively, its results are identical to a script run without it. However, when you do the same thing using the set command, the two outputs will be dramatically different. This is due to the shell variables that are added by the shell startup files that are only run in interactive shell environments. You might think that when the set command is run in a script, its output should be the same as the printenv output. But there are several shell variables that are added when the shell initializes, independent of whether the shell is interactive or non-interactive.</p><p>The important thing in all of this is that environment variables--those that are listed by the printenv command--are inherited from parent shells by child shells. On the other hand, shell variables are created during shell initialization or by shell startup scripts.</p><p>Create Shell Variables 06:25-07:06 When we discussed creating environment variables that could be used by a script, we listed the steps that you use to create a shell variable. You enter the variable&#39;s name followed by the equal sign and then the value you&#39;d like to assign to the name.</p><p>Be aware that that a shell variable isn&#39;t inherited by a child shell. It&#39;s only available in the current shell. You can use the same steps to create a variable in a script. However, we normally classify variables created in a script as user variables.</p><p>To convert a shell variable to an environment variable, on the next line, you use the export command. If you need to convert an environment variable back to a shell variable, you use the export -n command.</p><p>Summary 07:06-07:38 Now let&#39;s review what we&#39;ve talked about. In this lesson, we described the shell environment. We introduced two shell environment types; interactive shells, including login and non-login shells; and non-interactive shells, which are the type that a shell script runs in. Then we described environment variables that are inherited by child shells and shell variables that are added during shell initialization and by shell startup script. Finally, we discussed how to create environment variables and shell variables in a script.</p><h2 id="_14-2-2-bash-shell-parameters-and-user-variables" tabindex="-1"><a class="header-anchor" href="#_14-2-2-bash-shell-parameters-and-user-variables"><span>14.2.2 Bash Shell Parameters and User Variables</span></a></h2><p>Click one of the buttons to take you to that part of the video.</p><p>Bash Shell Parameters and User Variables 00:00-00:21 In this lesson, we&#39;ll discuss some building blocks for writing shell scripts.</p><p>The Bash shell uses variables which are containers in memory that store data. This data is called a value and can be a number, single character, string of characters, or array of values. And each container has a name.</p><p>Positional Parameters 00:21-01:33 Let&#39;s look at a series of special parameters called positional parameters. They contain the arguments given when the shell is invoked. These special variables are named with digits, such as $1, $2, and $3.</p><p>Here&#39;s an example. This executable file named testparams has a shell script with the first three positional parameters, $1, $2, and $3, referenced in the script. You can see here that $1 is set to the first argument, TestOut; $2 is set to the second argument, is; and $3 is set to the third argument, Great.</p><p>The arguments you use in the script cause different actions when it&#39;s run. Be cautious about a couple of things when using positional parameters. First, you can use the set command to reset positional parameters within the script. If you have a long script, you may want to store the positional parameters in another variable near the start of the script.</p><p>Second, if you have more than nine arguments, note that the Bash shell interprets two-digit parameters such as $10 as a $1 parameter followed by a zero. To fix this, enclose the parameter in braces like this: ${10}. This is called a shell expansion.</p><p>Special Parameters 01:33-02:20 Here&#39;s a list of special parameters whose values are set and maintained by the Bash shell. So, they can only be referenced. Notice that the $_ and $@ both contain positional parameters. The $_ is a single string with the positional parameters separated by a space, and $@ is an array with multiple values. Each positional parameter is added as a separate element of the array.</p><p>The hash (#) parameter expands to the number of positional parameters when referenced. And like a positional parameter, the zero (0) parameter expands to the name of the shell when referenced in an interactive shell. In a script, $0 expands to the filename of the script.</p><p>We won&#39;t cover the rest of the special parameters right now. But you might find them useful as you write more complex scripts.</p><p>User Variables 02:20-03:56 In the Bash shell, user variables are treated the same as environmental and shell variables. So, consider creating them with lowercase names to decrease the chance of your environmental and shell variables being overwritten with new values. Typically, you create user variables when assigning them a value.</p><p>At the shell prompt or within a script, enter the variable name, the equal sign (=), and then your assigned value for the variable. For example, enter ‘mytraining=TestOut’. If a value has a space, use single or double quotes around the value as shown here: ‘myname=&quot;Jane Doe&quot;’.</p><p>Later, you reference the variable using the dollar sign ($). When you put a dollar sign followed by a variable name in a Bash command, the variable&#39;s value is used instead of the variable name. This is called expanding the variable. For example, if you enter the echo mytraining command, the output is &quot;mytraining&quot;. But if you enter ‘echo $mytraining’., the output is &quot;TestOut&quot;. This function is often used when manipulating variables. For example, ‘fullname=&quot;$firstname $lastname&quot;’. or ‘savepositionalparameter=$1’.</p><p>There are a few Bash commands, like the read command, that&#39;ll create a variable and assign a value to it. For example, ‘read myname’ creates the myname variable, reads a line of text from the keyboard, and assigns it to the myname variable.</p><p>You can also use the declare command to create a variable. It can be used any time you create a variable, but usually, it&#39;s with shell arithmetic. And finally, you can delete a user variable using the unset command.</p><p>Integer Variables 03:56-04:31 Bash variables are stored as character strings unless you add the declare -i command. Then the variable is treated as an integer. An integer is a whole number and can be positive, negative, or zero.</p><p>The declare -l command allows the variable to be assigned a value using shell arithmetic. Shell arithmetic uses the plus character (+) for addition, the minus or dash character (-) for subtraction, the asterisk character (*) for multiplication, and the slash character (/) for division. These are the four basic arithmetic operators. Look on the Bash man page for other operators that do more complex arithmetic.</p><p>Shell Arithmetic 04:31-06:51 To use shell arithmetic, enter the variable, the equal sign (=), and then an arithmetic equation. The equation can consist of variables, operators, and parentheses that specify the order of operations.</p><p>When working with equations, remember that the dollar sign isn&#39;t needed for the value of the variable. For example, if you follow the x=4 command with the declare -i y=x+4 command, the value assigned to y is 8. For comparison, without the -i, the value assigned to y is x+4.</p><p>Also, remember to keep spaces out of your equations. The Bash shell will evaluate each part delimited by spaces as a command or an argument to a command. Additionally, if a variable has a character instead of numeric data, Bash will evaluate the equation by substituting a zero for the character data. For example, the a=badchars command followed by the declare -i z=a+7 command assigns z the value of 7.</p><p>Finally, even if a variable is declared using the -i option, you can assign character data to it. The declare -i b=John command will be accepted, and the echo $b command will return the output &quot;John&quot;. However, once the variable&#39;s declared using the -i option, the variable will always allow shell arithmetic.</p><p>To assign multiple values, declare a variable as an array. Arrays are either indexed or associative. The declare -a namearray=(Bob Sue Joe Jane) command creates an indexed array of four elements. The first element has an index number of zero (0), and its value is Bob. By default, index numbers begin with zero. So, the fourth element has the index number of 3 and the value of Jane.</p><p>You can reference an additional element in the array by adding the index number to the end of the variable name within brackets. Then, enclose the whole expression in braces. For example, echo ${namearray[2]} would output Joe, the third element of the array. The braces are needed because the Bash shell interprets $namearray as the first element and [2] as a literal string, so echo $namearray[2] would output Bob[2], which isn&#39;t what we want.</p><p>Storing Arrays in Variables 06:51-07:26 The command declare -iA agearray=([Bob]=21 [Sue]=19 [Joe]=22 [Jane]=25) creates an associative array. We added the -i option to allow shell arithmetic. Again, you reference an element of the array using the variable name, the bracketed element name, and braces. For example, echo ${agearray[Sue]} would output 19.</p><p>Global vs. Local Variables 07:26-08:38 Now, let&#39;s talk about local versus global variables. Consider what happens when you declare a user variable, like myvar, in an interactive shell and execute a script that declares a variable with the same name. To complicate this situation, what happens if this script calls a second script that doesn&#39;t declare a myvar variable but tries to reference it?</p><p>The key to answering this riddle is understanding that myvar is a local variable. It&#39;s local to the Bash shell where it was declared. A new Bash shell is created when a script is run, meaning the interactive myvar variable is a user variable; it&#39;s not transferred to the shell that the first script runs in. The first script creates its own myvar variable. The second script won&#39;t be able to find myvar and will return either an error or blank results when myvar is referenced.</p><p>This is the motivation for environment variables. They&#39;re considered global variables since they&#39;re global to the shell where they&#39;re created. So, each child shell is associated with an environment variable. When a child shell spawns a new shell, that new shell has access to the same environment variable. However, a copy of the environment variables is given to the child shell. The child can add environment variables that can be passed to its children, but the parent shell won&#39;t see the added environment variables.</p><p>Summary 08:38-08:56 Well, that&#39;s it for this lesson. In this lesson, we looked at positional parameters and special parameters. We described user variables, including integer variables used in shell arithmetic. We ended this lesson by looking at arrays that can contain multiple values.</p><h2 id="_14-2-3-bash-shell-expansion" tabindex="-1"><a class="header-anchor" href="#_14-2-3-bash-shell-expansion"><span>14.2.3 Bash Shell Expansion</span></a></h2><p>Click one of the buttons to take you to that part of the video.</p><p>Shell Expansions 00:00-00:29 In this lesson, we&#39;ll look at shell expansions which can quickly get complex. So, we&#39;ll introduce two simple expansions.</p><p>Variable expansion is known as parameter expansion, and command expansion is known as command substitution.</p><p>In a command, the dollar sign introduces expansion, and what follows it is expanded. Parameter expansion uses the dollar-sign-braces construct (${}). Command substitution uses the dollar-sign parentheses construct [$()].</p><p>Parameter Expansion 00:29-01:34 In our previous example, we used the dollar sign and braces in the echo ${namearray[2]} command to display the value of an array element. But parameter expansion goes much further because you can add operators. For example, start with the location=&quot;NY 10014&quot; command. In this command, we add an offset operator, echo ${location:3}. This is a sub-string expansion that starts at the offset that follows the colon, in this case, 3, and continues to the end of the value. Since the offset begins with 0, we begin counting at three and continue to the end, giving us 10014.</p><p>And here&#39;s one more parameter expansion using pattern substitution. The echo ${location/10014/10032} command looks for the pattern 10014 in the location value and substitutes 10032. So, the output from the command would be NY 10032.</p><p>Command Substitution 01:34-03:11 Command substitution allows you to use a command&#39;s output to replace the command. The expansion is initiated with the dollar sign and followed by a command within parentheses. The command within the parentheses is run, and the output is substituted. Command substitution is often used as an argument for another command or to set a variable. Here are some simple examples.</p><p>The mv -t ./old $(find -maxdepth 1 -mtime +30) command results in a list of files in the current directory that are over thirty days old. Suppose only two files are older than 30 days, a.dat and b.dat. Command substitution would replace the $() construct with these two files. The command becomes mt -t ./old a.dat b.dat.</p><p>You can use command substitution to set a variable. To save last Friday&#39;s date, use the command lastfriday=$(date --date=&quot;last Friday&quot;). Then use this variable in your script. For example, echo &quot;The file was backed up on $lastfriday&quot;.</p><p>An older but still used construct for command substitution uses commands listed within backquotes (<code>). The backquote on a keyboard is usually to the left of the 1 key. Don&#39;t use the single quote mark (�) next to the enter key. To illustrate, our variable example could&#39;ve been written as </code>date --date=&quot;last Friday&quot;`.</p><p>Summary 03:11-03:23 That&#39;s it for this lesson. In this lesson, we looked at two shell expansions, parameter expansions and command substitutions, and how they work.</p><h2 id="_14-2-4-bash-shell-variables-and-parameters" tabindex="-1"><a class="header-anchor" href="#_14-2-4-bash-shell-variables-and-parameters"><span>14.2.4 Bash Shell Variables and Parameters</span></a></h2><p>Click one of the buttons to take you to that part of the video.</p><p>Bash Shell Variables and Parameters 00:00-00:24 We&#39;re going to discuss using Bash shell variables and parameters. When you open a terminal, you&#39;re running a shell. You can find out which type of shell is being used by running the ps processes command. We&#39;re running a Bash shell, and its PID, or process ID, is 2243.</p><p>Process IDs and Scripts 00:24-01:24 When a script is run, an additional Bash shell is started with its own process IDs. I&#39;ve written a simple script named show-IDs that will show the current process ID and its parent process ID.</p><p>We&#39;re showing the PID using the special $$ variable, and the parent ID is being shown using the built-in variable of $PPID.</p><p>To see how the script works, let&#39;s go ahead and run ./show-IDs.sh. The scripts process ID has a larger number than the one we saw when we ran the ps command earlier. The parent ID is the same as what we saw with the ps command. Each subshell is spawned from the same parent.</p><p>Let&#39;s run this script three more times. We see that the process ID number continues to increase. However, the parent process ID still stays the same. When a script is run, a different Bash shell is executed.</p><p>Scripts and Environment Variables 01:24-02:16 When working with Bash shells, we must consider environment variables. A variable is a character string to which a value is assigned. Environment variables are a set of dynamic named values stored within the system that are used by applications launched in shells or subshells and are used to define the environment&#39;s behavior.</p><p>To look at our current environment variables, run env and filter the results by piping it to the more command. We see where the type of shell to use is defined, as well as other common environmental variables, such as my login name, admin, and my home directory. There are a lot of other environment variables listed here as well.</p><p>When a script is run interactively, the value of some of these variables may change. The variables may also change based on Linux processes that are running between a parent and the child.</p><p>Special Parameters 02:16-03:54 Let&#39;s look at how different special parameters can work within scripts. This will introduce you to the power of Linux scripts, which are an important part of any Linux system.</p><p>Let&#39;s look at another script I&#39;ve written named showargs.sh. It uses some special variables. The first line of this script will display all the arguments that are stored in the $* variable. Any information, such as a word or number that follows the name of the script, will be stored in this variable. We also see \n, which inserts a new line before showing the echoed information.</p><p>In the second line, I&#39;m using the $# variable. This variable stores the number of command line arguments that were passed to the shell when the script was run. The third line uses the $0 variable, which references the first word of the entered command, or in other words, the name of the program or script being run.</p><p>The next two lines use the $1 and $2 variables. This is a continuation of the $0 variable, meaning that, instead of referencing the first word, $1 references the first parameter that follows the script name, while $2 references the second parameter. These lines will give you the general idea of how these variables work.</p><p>The last line in our script uses the $@ variable. It shows me all the arguments that were entered when the script is run, starting with the first argument. At first glance, it may look like the $@ and the $* variables are the same, but there is a subtle difference.</p><p>First Look at $* and $@ 03:54-04:39 To see how all these variables work, let&#39;s begin by typing ./showargs.sh, the name of our script, and now I&#39;m going to add a few simple parameters: one, two, three, and four. When I press Enter, the script is run, and we can see the results of each line of code.</p><p>For example, on the All arguments line, we see the four arguments we included when the script was run. The second line shows us a numerical value of the number of arguments we used, which is 4. And on the third line, we see the name of the script that was run. The next two lines show the first argument listed, followed by the second argument. And finally, we see all the arguments listed again, starting with the first argument.</p><p>Second Look at $_ and $@ 04:39-05:56 In our last example, we&#39;ll look at how these variables can be used with a script loop and how the $_ and $@ variables are different. When including several arguments, we can create a loop that will show all the arguments that are entered in a format that can be used.</p><p>Let&#39;s look at our last script, which is named star-at_diff. We have three sections. The first section is going to display all the parameters stored in the $* variable, and then the numeric number of parameters stored in the $# variable.</p><p>In the second section, I&#39;ve created a loop using what&#39;s stored in the $_ variable, which are the arguments that are entered on the command line. The echo line will create a new line using \n and then displays this text: This loop is using the parameters in $_:. The backslash before the dollar sign simply tells the echo command to use the value stored in this variable instead of writing a dollar sign on the screen.</p><p>The for loop that follows will display the parameters stored in the $* variable on a new line until all the parameters have been shown. The last section will display the parameters in the $@ variable.</p><p>$* and $@ Results 05:56-07:03 Now we&#39;ll type the name of the script and then add the same parameters; one, two, three, and four; and then press Enter. There really isn&#39;t much difference in the output between the two loops.</p><p>Here are the results of $* and $@ with all my parameters. Let&#39;s try that again with one small change. Let&#39;s modify the last command by adding quotation marks around the last two parameters. Now, when we press Enter, we see that the results of our two loops are different. There are only three parameters detected instead of four, like we saw last time.</p><p>When we look at the output of the loops, we see that the loop using the $* variable is the same—it&#39;s still showing all four parameters on separate lines. But the output for the loop using the $@ variable only shows three lines. Since the last two parameters, three and four, were put on the same line, the $@ variable uses an array format to print. When it saw the quotes around the last two arguments, it considered them as one item. Depending on how the variable is used, the output or result may be different.</p><p>Summary 07:03-07:26 And that&#39;s the end of this demo. In this demonstration we discussed a terminal as a Bash shell and how a different Bash shell is executed for subshells. Then we discussed both environment variables and special variables and explored a few examples of how scripts can be used with these special variables.</p><h2 id="_14-2-5-user-variables-and-shell-arithmetic" tabindex="-1"><a class="header-anchor" href="#_14-2-5-user-variables-and-shell-arithmetic"><span>14.2.5 User Variables and Shell Arithmetic</span></a></h2><p>Click one of the buttons to take you to that part of the video.</p><p>User Variables and Shell Arithmetic 00:00-00:21 In this demonstation we look at bash variables that we define at the shell prompt and variables inside of a script. We sometimes call these local variables or user variables. We&#39;ll pay particular attention to integer variables and how you can use shell arithmetic to manipulate them.</p><p>Variable Basics 00:21-01:06 Let&#39;s start with some basics. Remember that variables are like a container with a name. Here at our bash shell prompt, we can use the declare command like this to define a container and give it the name myvar. We reference the variable using the dollar sign ($) expansion. Let&#39;s do a simple echo command. This container, or variable, is empty.</p><p>Notice that we named myvar using lowercase characters. Bash lets us name them using any combination of upper and lowercase. While serious programmers standardize the way they name variables, the only suggestion we might want to consider is that when we name them in something other than full uppercase, we&#39;re less likely to overwrite any of our environment variables.</p><p>Assign a Value 01:06-02:11 We don&#39;t have to formally declare every variable we want to use. Variables are automatically declared when they are assigned a value. To assign a value we use the equal sign (=). The name of the variable is on the left and the value is on the right.</p><p>Notice that we can&#39;t put spaces before or after the equal sign (=). If we do, bash thinks the variable is a command. If our value needs to have spaces in it, we enclose it using quotes. We use single quotes when we want the value to be the literal characters between the quotes. We use double quotes if we want to use special character like the dollar sign ($) and backslash () to retain their special meaning.</p><p>Bash variables are untyped, meaning bash doesn&#39;t store characters, numbers, strings or other values differently. In fact, bash always stores data as character strings. Even though we assign this variable x a number, it stores it as the character 1 followed by a period (.) and the characters 2, and 3.</p><p>Shell Arithmetic 02:11-03:04 But what if we need to do arithmetic? Bash will do that if we declare a variable using the -i option. Bash denotes variables that are declared this way as integer variables. What that really means is that when we assign it a value using the equal sign (=), the part on the right is considered an arithmetic equation, rather than a character string. We call this shell arithmetic. And there are a lot of rules.</p><p>Let&#39;s try some shell arithmetic with our x variable that currently is not an integer variable. When we assign it 4+5, we get the literal characters 4, the plus sign (+) and 5.</p><p>Let&#39;s start over by deleting x using the unset command. Now, let&#39;s declare x as an integer variable. And we can give x an assignment in the same command. Notice that now the value of x is nine (9).</p><p>Integer vs. Non-Integer Variables 03:04-03:37 Shell arithmetic is only performed when the variable on the left of the equal (=) sign is an integer variable. Here we might expect that y would be assign the value of 10, because x is 9, and 9 plus 1 is 10. But y is not an integer variable, so we just get the literal characters.</p><p>Let&#39;s make y an integer and try our equation again. Now, y is assigned the value 10 because y is an integer variable and shell arithmetic was used.</p><p>Shell Arithmetic Tips 03:37-04:20 Here are some tips about shell arithmetic. First, Integer values can be negative. Next, we can form equations using star (*) for multiply, and forward slash (/) for divide. There are other arithmetic operators you can use. We can find them in the bash man page or other references.</p><p>We can also use parentheses () to force the order of the arithmetic. Also, notice that the dollar sign ($) isn&#39;t required to expand the variables in an equation. It will still work, but it isn&#39;t needed in shell arithmetic.</p><p>Integer Arithmetic 04:20-05:31 One important thing we need to cover is that shell arithmetic is integer arithmetic. We can&#39;t assign decimal values to integers. This is particularly noticeable when we divide. Any remainder from a division operation is ignored. Sometimes we refer to this as the value was truncated. In this example, x+2 would be 11, and 11 divided by 3 is 3 with a remainder of 2. So y is assigned the value of 3 and the remainder of 2 is discarded.</p><p>Another important thing to understand is that shell arithmetic will substitute a zero (0) in an equation, when the value is non-numeric characters. You can add &quot;Dave&quot; to 4, but shell arithmetic substitutes a zero (0) for &quot;Dave&quot;, giving 4 as the result.</p><p>We can use the declare -p command to see both the value of a variable and whether it has been declared as an integer. In the case of our y variable, the i shows that it&#39;s an integer. Also notice the double quotes (&quot;) around the value of 4. This helps us remember that the value is stored as the character &quot;4&quot;, and not the number 4.</p><p>Local Variables 05:31-06:30 Before we finish, we need to emphasize that all of these variables are considered local variables. The same thing applies to variables within a script. If we exit this terminal window and re-open it, our variables are gone.</p><p>Let&#39;s look at this script. It simply assigns a value to a variable named myvar and then echos the value. Let&#39;s set a variable named myvar before we run the script and echo it to the screen.</p><p>Now let&#39;s run the script and re-echo the value of myvar. We notice that even though myvar was assigned a different value inside the script, it didn&#39;t affect the variable in the terminal window. We remember that user variables in a parent shell aren&#39;t inherited by a child shell. Essentially, there are two myvar variables, one in our shell that is our terminal window, and the other inside the child shell that ran the script.</p><p>Summary 06:30-06:55 That&#39;s it for this demonstration. We showed how local or user variables are defined and how the declare -i command creates an integer variable. We also showed how shell arithmetic is used to assign a value to integer variables. We finished by showing that user variables are local to the shell where they are created.</p><h2 id="_14-2-6-arrays-and-expansions" tabindex="-1"><a class="header-anchor" href="#_14-2-6-arrays-and-expansions"><span>14.2.6 Arrays and Expansions</span></a></h2><p>Click one of the buttons to take you to that part of the video.</p><p>Arrays and Expansions 00:00-00:15 In this demonstration, we&#39;ll show you how to use bash variables that contain an array of values. We&#39;ll also show you two shell expansions, parameter expansion, and filename expansion.</p><p>Indexed Arrays 00:15-00:37 In Bash, there are two types of arrays, indexed and associative. Let&#39;s look first at indexed arrays where each element in the array is referenced by a number. To create an indexed array, we declare it with declare -a. To declare an indexed array with initial values, we specify them after the declare statement. To see the value of an array, we use declare -p.</p><p>Add, Change, and Reference an Element 00:37-00:50 We can add or change a single element using its numeric index. To reference an array element, we must use a shell expansion called parameter expansion or variable expansion. It uses the dollar sign ($) braces {} construct.</p><p>Associative Arrays 00:50-01:02 Associative arrays are similar to indexed arrays but have names instead of numbers for each element. They&#39;re declared with declare -A. An element can be added, changed, or referenced using its name.</p><p>Shell Expansions 01:02-01:42 Now we&#39;ll look at shell expansions. These include command, parameter, and filename expansions. We&#39;ve discussed command expansions in a previous lesson.</p><p>Here are a couple of variations on parameter expansion. Here&#39;s an expansion that returns a substring of 15 characters beginning at the 14th character. We start counting the characters at zero (0), and here&#39;s an expansion that substitutes one string for another.</p><p>Filename expansion allows you to generate a list of files concisely. For example, we can use an asterisk character to list all the files ending in .txt and curly braces to list any backup files. More information on shell expansions can be found on the man page for Bash.</p><p>Summary 01:42-01:57 That&#39;s it for this demonstration. In this demonstration, we showed how to use array variables and how to use two more shell expansions, parameter expansions, and filename expansions.</p><h2 id="_14-2-7-shell-environments-bash-variables-and-parameters-facts" tabindex="-1"><a class="header-anchor" href="#_14-2-7-shell-environments-bash-variables-and-parameters-facts"><span>14.2.7 Shell Environments, Bash Variables and Parameters Facts</span></a></h2><p>To write helpful Bash shell scripts, you need a good understanding of the environment that the script runs in, including environment variables, shell variables, Bash shell parameters, user variables, and expansions.</p><p>This lesson covers the following topics:</p><ul><li>Environment variables, shell variables, and shell environment types</li><li>Scripts and environment variable inheritance</li><li>Environment variables</li><li>Shell variables</li><li>Positional parameters</li><li>Special parameters</li><li>User variables</li><li>Integer variables and shell arithmetic</li><li>Storing arrays in variables</li><li>Shell expansions</li></ul><h3 id="environment-variables-shell-variables-and-shell-environment-types" tabindex="-1"><a class="header-anchor" href="#environment-variables-shell-variables-and-shell-environment-types"><span>Environment Variables, Shell Variables, and Shell Environment Types</span></a></h3><p>Linux is a multi-processing operating system, and each shell environment is spawned as a process.</p><ul><li>As a process is created, environment information is gathered from a variety of files and settings on the system and made available to the shell process.</li><li>This shell environment is implemented as key-value pairs or environment variables.</li><li>Each environment variable has a name that’s assigned a value or multiple values.</li><li>Bash startup routines and Bash shell startup scripts can add shell variables to the shell process.</li></ul><p>The way that shell variables are added to a shell process depends on the shell environment type.</p><ul><li>An interactive shell reads from standard input (the keyboard) and writes to standard output (the display screen). There are two kinds of interactive shells. <ul><li>A login shell requires a user to provide a user ID and password. If you logged in using the Linux console or through a remote SSH session, it’s a login shell.</li><li>A non-login shell does not require a user ID and password. The Terminal windows in the Gnome desktop environment is an example of a non-login shell.</li><li>Bash shell startup scripts that add shell variables are only run in interactive shells.</li></ul></li><li>A non-interactive shell does not interact with the user. Examples of a non-interactive shell are when a cron job starts or when a shell script is run. <ul><li>Bash shell startup scripts do not run in non-interactive shells.</li></ul></li></ul><h3 id="scripts-and-environment-variable-inheritance" tabindex="-1"><a class="header-anchor" href="#scripts-and-environment-variable-inheritance"><span>Scripts and Environment Variable Inheritance</span></a></h3><p>A Bash shell runs in a Linux process. Each Linux process has a parent process.</p><ul><li>To run a script from a parent Bash shell: <ul><li>A child process is created.</li><li>The child process opens a Bash shell.</li><li>The script runs in the child Bash shell.</li></ul></li><li>The child shell inherits environment variables from its parent process. <ul><li>A copy of the parent shell’s environment variables is given to the child shell.</li><li>Any environment variable added to the parent shell after the child shell is created won’t be available to the child shell.</li><li>The child shell can manipulate these environment variables without affecting the parent’s environment variables.</li></ul></li></ul><h3 id="environment-variables" tabindex="-1"><a class="header-anchor" href="#environment-variables"><span>Environment Variables</span></a></h3><p>Environment variables are mostly used by the shell. The following commands are used when working with environment variables.</p><table border="1"><tbody><tr><td>Command</td><td>Description</td><td>Examples</td></tr><tr><td><b>printenv</b></td><td> When an environment variable name is added as an argument, <b>printenv</b> displays the environment variable&#39;s value. <p> When no arguments are added, <b>printenv</b> displays a list of environment variables and their values. </p></td><td><b>printenv PATH</b><br>This command displays the value of the PATH environment variable. <p><b>printenv</b><br>This command lists all environment variables and their values. </p></td></tr><tr><td><b><i class="fs-italicize">variable name</i>=<i class="fs-italicize">value</i></b></td><td>Creates a shell variable with the given name and value.</td><td><b>training=TestOut</b><br>This command creates the shell variable with the name of &quot;training&quot; that has the value &quot;TestOut&quot;. </td></tr><tr><td><b>export <i class="fs-italicize">variable name</i></b></td><td> Converts a shell variable into an inheritable environment variable. </td><td><b>export training</b><br>This command converts the training variable into an environment variable. </td></tr><tr><td><b>declare -x <i class="fs-italicize">variable name</i>=<i class="fs-italicize">value</i></b></td><td>Creates and exports an environment variable at the same time.</td><td><b>declare -x training=TestOut</b><br>This command creates an environment variable named &quot;training&quot; that has the value &quot;TestOut&quot;. </td></tr></tbody></table><h3 id="shell-variables" tabindex="-1"><a class="header-anchor" href="#shell-variables"><span>Shell Variables</span></a></h3><p>Many people confuse shell variables with environment variables, since their names are in uppercase and they seem to be available in every shell session.</p><ul><li>Shell variables aren’t inherited like environment variables.</li><li>Most shell variables are created by shell startup scripts.</li></ul><p>One way to see the difference between environment variables and shell variables is to run two commands, which are <code>printenv</code> and <code>set</code>, and compare the results.</p><ul><li>The <b class="fw-bold">printenv</b> command lists only environment variables.</li><li>The <b class="fw-bold">set</b> command lists all variables, including environment variables.</li><li>Any variable listed in the <b class="fw-bold">set</b> command output that isn’t in the <b class="fw-bold">printenv</b> output is a shell variable.</li></ul><p>Shell variables are created just like environment variables by entering the variable’s name followed by the equal sign and then the value to be assigned to the name.</p><h3 id="positional-parameters" tabindex="-1"><a class="header-anchor" href="#positional-parameters"><span>Positional Parameters</span></a></h3><p>Positional parameters are a series of special variables that contain the arguments given when the shell is invoked. The names of these special variables are digits, so they’re referenced by $1, $2, $3, $4, and so on.</p><table border="1"><tbody><tr class="header"><td class="contentheader">Script</td><td class="contentheader">Script Execution</td><td class="contentheader c1">Description</td></tr><tr><td class="content"><b class="fw-bold">[auser@mylinux bin]$ cat testparams<br>#!/bin/bashbr&gt; echo &quot;Positional Parameters&quot;<br>echo &#39;$1 = &#39; $1<br>echo &#39;$2 = &#39; $2<br>echo &#39;$3 = ‘ $3<br>exit 0</b></td><td class="content"> [auser@mylinux bin]$ testparams TestOut is Great<br>Positional Parameters<br>$1 = TestOut<br>$2 = is<br>$3 = Great<br></td><td class="content"> The positional parameters are set to the arguments given when the script is run. </td></tr><tr><td class="content"><b class="fw-bold">[auser@mylinux bin]$ cat testparams2<br>#!/bin/bash<br>echo &quot;Positional Parameters&quot;<br>echo &#39;$1 = &#39; $1<br>echo &#39;$9 = &#39; $9<br>echo &#39;$10 = &#39; ${10}<br>echo &#39;$11 = &#39; ${11}<br>exit 0</b></td><td class="content"> [auser@mylinux bin]$ testparams2 one 2 3 4 5 6 7 8 nine ten eleven<br>Positional Parameters<br>$1 = one<br>$9 = nine<br>$10 = ten<br>$11 = eleven </td><td class="content"> If more than nine arguments are given, the name of the positional parameter will use two digits, like $10, $11, etc. When $10 is used, the Bash shell interprets this as the $1 parameter followed by a zero (0). When referenced, it must be enclose the parameter in braces: ${10}. This is a shell expansion. </td></tr></tbody></table><h3 id="special-parameters" tabindex="-1"><a class="header-anchor" href="#special-parameters"><span>Special Parameters</span></a></h3><p>The following is a list of special parameters that can only be referenced using the dollar sign ($*, $#, $?, etc.) Their values are set and maintained by the Bash shell.</p><table border="1"><tbody><tr class="header"><td class="centered">Special<br>Parameter</td><td class="contentheader">Description</td></tr><tr><td class="centered">*</td><td class="content"> The positional parameters as a single text string </td></tr><tr><td class="centered">@</td><td class="content">The position parameters as an array</td></tr><tr><td class="centered">#</td><td class="content">The number of positional parameters</td></tr><tr><td class="centered">?</td><td class="content">The exit status of the last executed command</td></tr><tr><td class="centered">-</td><td class="content">The option flags from the last set command</td></tr><tr><td class="centered">$</td><td class="content">The process ID (PID) of the shell</td></tr><tr><td class="centered">!</td><td class="content">The process ID of the last background job</td></tr><tr><td class="centered">0</td><td class="content">The name of the shell or shell script</td></tr><tr><td class="centered">_</td><td class="content">The last argument of the previous command</td></tr></tbody></table><h3 id="user-variables" tabindex="-1"><a class="header-anchor" href="#user-variables"><span>User Variables</span></a></h3><p>In the Bash shell, user variables are treated the same as environment variables and shell variables. Consider creating them with lowercase names to avoid environment and shell variables being overwritten with new values.</p><ul><li> In most cases, create user variables at the same time as you assign them a value. <ul><li> Enter the name of the variable, the equal sign (=), and then the value to assign the variable. </li></ul></li><li> Reference the variable using the dollar sign ($). <ul><li> When a dollar sign followed by a variable name is encountered in a Bash command, the value of the variable is used instead of the variable name. </li><li>In Bash, this is described as expanding the variable.</li></ul></li><li> There are a few Bash commands, like the <b class="fw-bold">read</b> command, that create a variable and assign a value to it. </li><li> A user variable can be created using the <b class="fw-bold">declare</b> command. <ul><li> The <b class="fw-bold">declare</b> command can be used every time to create a variable. </li><li> The <b class="fw-bold">declare</b> command is mostly used with shell arithmetic. </li></ul></li><li> A variable can be compared using strings or a boolean as needed. A string comparison compares each character and its placement, where a boolean either is <i class="fs-italicize">true</i> or <i class="fs-italicize">false</i>. </li><li> A variable can be deleted using the <b class="fw-bold">unset</b> command. </li></ul><h3 id="integer-variables-and-shell-arithmetic" tabindex="-1"><a class="header-anchor" href="#integer-variables-and-shell-arithmetic"><span>Integer Variables and Shell Arithmetic</span></a></h3><p>All Bash variables are stored as character strings. The declare -i command will treat the variable as an integer.</p><ul><li> An integer is a whole number, like the numbers you use to count. <ul><li>An integer can be positive, negative, or zero.</li></ul></li><li> The <b class="fw-bold">declare -i</b> command allows the variable to be assigned a value using shell arithmetic. </li><li> Shell arithmetic uses: <ul><li>The plus character (<b class="fw-bold">+</b>) for addition</li><li> The minus or dash character (<b class="fw-bold">-</b>) for subtraction </li><li> The asterisk character (<b class="fw-bold">*</b>) for multiplication </li><li>The slash character (<b class="fw-bold">/</b>) for division</li></ul></li><li>Other operators are described on the Bash man page.</li><li> To use shell arithmetic: <ul><li> Enter the variable and the equal sign (=), and then enter an arithmetic equation. <ul><li> Equations can be made up of variables and operators with no spaces between them. </li><li> Parenthesis can be used to specify the order that the arithmetic operations are performed. </li></ul></li><li>Don’t use the dollar sign to use the value for a variable.</li></ul></li></ul><p>The following examples illustrate the use of shell arithmetic.</p><table border="1"><tbody><tr class="header"><td class="contentheader">Example</td><td class="contentheader">Results</td><td class="contentheader">Description</td></tr><tr><td class="content"><b class="fw-bold">x=4<br>declare -i y=x+4<br>echo &#39;$y = &#39; $y</b></td><td class="content">$y = 8</td><td class="content"> The variable y is assigned the value x+4, which is 4+4, or 8. </td></tr><tr><td class="content"><b class="fw-bold">declare y=x+4<br>echo &#39;$y = &#39; $y</b></td><td class="content">$y = x+4</td><td class="content"> The variable y is assigned the literal characters &quot;x+4&quot;. </td></tr><tr><td class="content"><b class="fw-bold">a=badchars<br>echo &#39;$a = &#39; $a<br>declare -i z=a+7<br>echo &#39;$z = &#39; $z</b></td><td class="content">$a = badchars<br>$z = 7</td><td class="content"> The variable z will accept shell arithmetic, but the variable a is assigned character data. When a is used in an equation, the value of zero (0) is substituted. So the variable z is assigned the value a+7, which is interpreted as 0+7 or 7. </td></tr><tr><td class="content"><b class="fw-bold">x=4<br>declare -i b=&quot;John&quot;<br>echo &#39;$b = &#39; $b<br>b=x+20<br>echo &#39;$b = &#39; $b</b></td><td class="content">$b = 0<br>$b = 24</td><td class="content"> The variable b will accept shell arithmetic, so the value of zero (0) is substituted for character data. So b=&quot;John&quot; assigns a zero to the variable b. Once a variable is declared as an integer, it will always accept shell arithmetic. So b=x+20 assigns 4+20 or 24 to the variable b. </td></tr></tbody></table><h3 id="storing-arrays-in-variables" tabindex="-1"><a class="header-anchor" href="#storing-arrays-in-variables"><span>Storing Arrays in Variables</span></a></h3><p>You can assign a variable multiple values by declaring it as an array. There are two types of arrays: indexed and associative. The following examples illustrate the use of arrays.</p><table border="1"><tbody><tr class="header"><td class="centered">Array Type</td><td class="contentheader">Example</td><td class="contentheader">Results</td><td class="contentheader">Description</td></tr><tr><td class="centered">Indexed</td><td class="content"><b class="fw-bold">[auser@mylinux bin]$ cat arrays1<br>#!/bin/bash<br><br>declare -a namearray=(Bob Sue Joe Jane)<br>namearray[7]=George<br><br>echo &#39;$namearray[0] = &#39; ${namearray[0]}<br>echo &#39;$namearray[1] = &#39; ${namearray[1]}<br>echo &#39;$namearray[2] = &#39; ${namearray[2]}<br>echo &#39;$namearray[3] = &#39; ${namearray[3]}<br>echo &#39;$namearray[7] = &#39; ${namearray[7]}<br><br>echo &quot;This won&#39;t work&quot;<br>echo &#39;$namearray[2] = &#39; $namearray[2]<br><br>exit 0</b><br></td><td class="content"> [auser@mylinux bin]$ arrays1<br><br>$namearray[0] = Bob<br>$namearray[1] = Sue<br>$namearray[2] = Joe<br>$namearray[3] = Jane<br>$namearray[7] = George<br><br>This won&#39;t work<br>$namearray[2] = Bob[2]<br></td><td class="content"> Indexed arrays are created using the <b class="fw-bold">declare -a</b> command. The indexed array named namearray is initialized with four elements beginning with the index number of zero (0). Index numbers do not have to be consecutive. To reference an element in the array, add the index number to the end of the variable name within brackets. Then enclose the whole expression with braces. </td></tr><tr><td class="centered">Associative</td><td class="content"><b class="fw-bold">[auser@mylinux bin]$ cat arrays2<br>#!/bin/bash<br><br>declare -iA agearray=([Bob]=21 [Sue]=19 [Joe]=22 [Jane]=25)<br>echo &#39;$agearray[Bob] = &#39; ${agearray[Bob]}<br>echo &#39;$agearray[Sue] = &#39; ${agearray[Sue]}<br>echo &#39;$agearray[Joe] = &#39; ${agearray[Joe]}<br>echo &#39;$agearray[Jane] = &#39; ${agearray[Jane]}<br><br>agearray[Bob]=agearray[Sue]+agearray[Joe]<br>echo &#39;$agearray[Bob] = &#39; ${agearray[Bob]}<br>echo &#39;$agearray[Sue] = &#39; ${agearray[Sue]}<br>echo &#39;$agearray[Joe] = &#39; ${agearray[Joe]}<br>echo &#39;$agearray[Jane] = &#39; ${agearray[Jane]}<br><br>exit 0</b></td><td class="content c1"> [auser@mylinux bin]$ arrays2<br><br>$agearray[Bob] = 21<br>$agearray[Sue] = 19<br>$agearray[Joe] = 22<br>$agearray[Jane] = 25<br><br>$agearray[Bob] = 41<br>$agearray[Sue] = 19<br>$agearray[Joe] = 22<br>$agearray[Jane] = 25 </td><td class="content c1"> Associative arrays are created using the <b class="fw-bold">declare -A</b> command. In this example, the associative array named agearray is also declared with the <b class="fw-bold">-i</b> option to allow shell arithmetic. An element of the array is referenced using the variable name, the bracketed element name, and braces. <p> Array elements can be used in shell arithmetic. The <b class="fw-bold">agearray[Bob]=agearray[Sue]+agearray[Joe]</b> command assigns the value of 41 (Sue’s age plus Joe’s age) to the Bob element.<br></p></td></tr></tbody></table><h3 id="shell-expansions" tabindex="-1"><a class="header-anchor" href="#shell-expansions"><span>Shell Expansions</span></a></h3><p>There are many types of shell expansions. Two important expansions are variable expansion and command expansion.</p><p>Variable expansion is known as parameter expansion and uses the ${} construct. The following examples illustrate parameter expansion.</p><table border="1"><tbody><tr class="header"><td class="contentheader">Example</td><td class="contentheader">Results</td><td class="contentheader">Description</td></tr><tr><td class="content"><b class="fw-bold">echo &#39;$namearray[2] = &#39; ${namearray[2]}</b></td><td class="content">namearray[2] = Joe</td><td class="content"> Parameter expansion is required to get the proper results when an array element is referenced. </td></tr><tr><td class="content"><b class="fw-bold">location=&quot;NY 10014&quot;<br>echo ${location:3}<br></b></td><td class="content">10014</td><td class="content"> An offset operator is added to the parameter expansion. This is a substring expansion that starts at the offset that follows the colon (in this case, 3) and continues to the end of the value. The offset begins counting at 0. Beginning with an offset of 3 and continuing to the end gives us 10014. </td></tr><tr><td class="content"><b class="fw-bold">location=&quot;NY 10014&quot;<br>echo ${location/10014/10032}</b></td><td class="content">NY 10032</td><td class="content"> Pattern substitution is added to the parameter expansion. The command looks for the pattern 10014 in the location value and substitutes 10032. </td></tr></tbody></table><p>Command expansion is also known as command substitution and uses the $() construct. Command substitution uses the output of a command to replace the command itself. The command within the parentheses is run, and the output is substituted. Often, command substitution is used as an argument for another command or to set a variable. The following examples illustrate command substitution.</p><table border="1"><tbody><tr class="header"><td class="contentheader">Example</td><td class="contentheader">Results</td><td class="contentheader">Description</td></tr><tr><td class="content"><b class="fw-bold">find -maxdepth 1 -mtime +30</b></td><td class="content">./a.dat<br>./b.dat</td><td class="content"> The <b class="fw-bold">find</b> command can be used in a command expansion. In this case, the a.dat and b.dat files are the only two files in a directory that are over 30 days old. </td></tr><tr><td class="content"><b class="fw-bold">mv –t ./old $(find -maxdepth 1 -mtime +30)</b></td><td class="content">No output unless an error is generated</td><td class="content"> This command would be translated to <b class="fw-bold">mv –t ./old ./a.dat ./b.dat</b>, which would move two files to the old directory.<br></td></tr><tr><td class="content"><b class="fw-bold">lastfriday=$(date --date=&quot;last Friday&quot;)<br>echo &quot;The file was backed up on $lastfriday&quot;</b></td><td class="content"> The file was backed up on Fri Feb 22 00:00:00 PST 2019 </td><td class="content"> The first command in this example assigns the output of the date command to the lastfriday variable. </td></tr><tr><td class="content"><b class="fw-bold">lastfriday=`date --date=&quot;last Friday`<br>echo &quot;The file was backed up on $lastfriday&quot;</b></td><td class="content"> The file was backed up on Fri Feb 22 00:00:00 PST 2019 </td><td class="content"> The backquote (`) can be used for command substitution. The backquote on a keyboard is usually to the left of the 1 key. Don&#39;t confuse the backquote with the single quote (‘) that is next to the Enter key. </td></tr></tbody></table></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></div></footer><nav class="vp-page-nav" aria-label="page navigation"><a class="route-link auto-link prev" href="/linux/14/01.html" aria-label="Section 14.1 Bash Shell Scripting"><div class="hint"><span class="arrow left"></span> Prev</div><div class="link"><span>Section 14.1 Bash Shell Scripting</span></div></a><a class="route-link auto-link next" href="/linux/14/03.html" aria-label="Section 14.3 Bash Scripting Logic"><div class="hint">Next <span class="arrow right"></span></div><div class="link"><span>Section 14.3 Bash Scripting Logic</span></div></a></nav><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/linux/assets/app-CsWvKd9L.js" defer></script>
  </body>
</html>
