import{_ as s,c as t,a as o,o as i}from"./app-DQZVun5U.js";const n={};function a(r,e){return i(),t("div",null,e[0]||(e[0]=[o('<p>As you study this section, answer the following questions:</p><ul><li>Which types of files can create processes on a Linux system?</li><li>What is the difference between user processes and daemon processes?</li><li>How are system processes usually identified?</li><li>Which process is always assigned the same process ID number?</li><li>What is the major difference between how <b class="fw-bold">top</b> and <b class="fw-bold">ps</b> display system processes?</li></ul><p>In this section, you will learn to:</p><ul><li>View process information using <b class="fw-bold">ps</b> , <b class="fw-bold">top,</b> and <b class="fw-bold">pgrep</b></li><li>Use <b class="fw-bold">pidof</b></li></ul><p>Key terms for this section include the following:</p><table class="terms"><thead><tr><th>Term</th><th>Definition</th></tr></thead><tbody><tr><td>Binary executable</td><td> A program compiled into a binary file that the CPU can execute. </td></tr><tr><td>Internal shell commands</td><td>A command that is built into the shell executable.</td></tr><tr><td> Process ID <br> (PID) </td><td>A number that uniquely identifies each process.</td></tr><tr><td> Parent Process ID <br> (PPID) </td><td> A number that identifies the process that spawned (or started) the current process. </td></tr></tbody></table><p>This section helps you prepare for the following certification exam objectives:</p><table class="objectives"><thead><tr><th>Exam</th><th>Objective</th></tr></thead><tbody><tr><td>TestOut Linux Pro</td><td> 1.4 Manage system processes <ul><li>Monitor and manage running processes</li></ul></td></tr><tr><td>CompTIA Linux+ XK0-005</td><td> 1.4 Given a scenario, configure and use the appropriate processes and services. <ul><li> System services <ul><li>systemctl</li><li>stop</li><li>start</li></ul></li><li> Process management <ul><li> Listing processes and open files <ul><li>top</li><li>ps</li><li>htop</li></ul></li><li>Setting priorities</li><li> Process states <ul><li>Zombie</li><li>Sleeping</li><li>Running</li><li>Stopped</li></ul></li><li>pgrep</li><li>pkill</li></ul></li></ul></td></tr></tbody></table><h2 id="_10-1-1-linux-processes" tabindex="-1"><a class="header-anchor" href="#_10-1-1-linux-processes"><span>10.1.1 Linux Processes</span></a></h2><p>Click one of the buttons to take you to that part of the video.</p><p>Linux Processes 00:00-00:21 In this lesson, we&#39;re going to review how Linux handles processes. First off, what exactly is a process? For our purposes, it&#39;s just a program in our system&#39;s RAM that&#39;s being processed by the CPU. There are different types of programs we can run to create processes, and that&#39;s what we&#39;ll look at in this lesson.</p><p>Create a Process 00:21-01:38 The first method is to use a binary executable. These were originally created as text files using a programming language like C or C++ and then run through a compiler. Nowadays, we can also create a process by running an internal shell command. That&#39;s the second method. Most of the commands you enter at the shell prompt aren&#39;t binary files, but are actually commands rolled into the shell program itself. For example, when you type the exit command at the shell prompt, you&#39;re actually running an internal shell command. If you were to look in the file system, you wouldn&#39;t find a binary executable file named exit. Instead, the necessary computer code for the exit function is stored in the shell.</p><p>The last way we can create a process on Linux is to run a shell script. These are text files executed in the shell. With a text file, you put in all the commands you want to run, and—assuming that you made that shell script executable—it&#39;ll dynamically interpret your file and do whatever it was that you programmed it to do. Because shell scripts aren&#39;t compiled, we define them as being &quot;interpreted.&quot; At no point are they turned into a file of ones and zeros, like binary executables. The concept goes a little beyond the scope of this lesson, but shell scripts are basically run on the fly without the need for that intermediate step. Okay, let&#39;s move on to multitasking.</p><p>Multitasking 01:38-02:17 So, the Linux operating system can run multiple processes concurrently, even on a single CPU. It&#39;s more of an illusion, though, since what&#39;s really going on is Linux is very quickly switching between the various tasks. It works kind of like your vision. You can only focus your eyes on one thing at time, but as you pan around, you get much more than just disjointed objects in your line of sight. The CPU focuses on one process at time, but it switches so fast that everything ends up running concurrently for all intents and purposes. And this works by priority, with critical processes being first. With that, let&#39;s explore a couple of multitasking enhancements you should know.</p><p>Multi-Core CPUs 02:17-02:54 The first is multi-core CPUs, which provide additional concurrent processing. Within a single CPU, there can be 10 or more cores—each able to run its own set of tasks. Let&#39;s say that we just had two. The first core would work on Process 23, jump to 24 and then to 25, and so on. While it&#39;s working on those, the second core would work on Processes 26, 27, and 28. It&#39;s a round-robin approach to making the system run. Effectively, this single CPU could be running Process 23 and 26 at the same time—one on each core.</p><p>Multithreading CPUs 02:54-03:28 The second thing to be aware of is hyperthreading. Sometimes, this is called symmetric or simultaneous multithreading, or SMT. SMT splits each core into two virtual cores called threads, which work simultaneously. This effectively doubles the number of cores that a CPU has. So if you have an octa-core CPU with hyperthreading, you&#39;d have 16 virtual cores. Keep in mind this isn&#39;t the same as doubling the physical number of cores. Physical cores are always more desirable than virtual ones.</p><p>Multi-Core Multithreading CPUs 03:28-04:13 Multithreading CPUs, like multi-core CPUs, can run more than one process at once. If you really want to speed things up, you can look at a multi-core CPU that supports hyperthreading. In this situation, you&#39;d have two or more cores in the processor, with each one being capable of running two processes at a time. Depending on how many cores you buy, this could make for an insanely fast system.</p><p>In this situation here, we have one processor. It has two cores, and each one supports hyperthreading, so this one CPU can multitask four processes at the same time. It&#39;ll work on Processes 23 and 24 on the first core and Processes 27 and 28 on the second. Okay, now let&#39;s get into user processes.</p><p>User Processes 04:13-04:42 Linux implements several different process types. Not all of the processes running on your Linux system are the same. Some are created by the end user when they run a command from the shell prompt, or maybe when they click on an icon on the desktop. These are called user processes because they&#39;re initiated by the user. These are usually associated with some kind of program that&#39;s running on the system. In this example, I ran the LibreOffice command from the shell prompt, which will load the LibreOffice suite on my system.</p><p>System Processes 04:42-05:56 When I did this, two user processes were created—oosplash and soffice.bin. The important thing to remember about user process is that they&#39;re called from within the shell and are therefore associated with that shell session. All others will mostly be system processes, which are created by daemons. Unlike a user process, a system process usually doesn&#39;t provide any type of end-user interface to interact with it.</p><p>Instead, it&#39;s used to provide a service—like a web server, FTP server, file sharing, or printer sharing. These system processes run in the background, and the end user probably doesn&#39;t realize that they&#39;re there. Here&#39;s a list of some of these system processes from my machine. You&#39;ll notice right away that my machine has many, many system processes running. And this is just a fraction of what&#39;s going on.</p><p>Now, system processes are almost always loaded by the Linux operating system at bootup. Because they&#39;re loaded before system starts, they&#39;re not associated with a particular shell instance. This is the key difference between user and system processes. User processes are tied to the particular shell that they were called from, whereas system processes aren&#39;t.</p><p>Summary 05:56-06:17 Great! That&#39;s it for this lesson. In this lesson, we introduced you to Linux processes. We talked about process creation and multitasking. Along with that, we went into multi-cores and multithreading. We also went into the differences between system and user processes.</p><h2 id="_10-1-2-process-heredity" tabindex="-1"><a class="header-anchor" href="#_10-1-2-process-heredity"><span>10.1.2 Process Heredity</span></a></h2><p>Click one of the buttons to take you to that part of the video.</p><p>Process Heredity 00:00-01:03 In this lesson, we&#39;ll discuss the heredity of Linux processes. All Linux processes are directly or indirectly loaded by one single process on your Linux system. This process is either init or systemd, depending on your distribution. Many newer Linux distributions have migrated to systemd, but there are still some that use init.</p><p>The Linux kernel starts either init or systemd during boot up. And any process running on a Linux system is allowed to launch additional processes. The process that launched the new process is called the parent, and the new process is called the child. And this child can launch additional processes, and so on. So, it&#39;s possible to have many generations of processes running on the system. We call these generational relationships the heredity process of Linux.</p><p>In this example, we have a parent process that spawned three child processes. Then each spawned their own, one here, two here, and one here. This makes the original process a grandparent.</p><p>Process Identifiers 01:03-03:59 Any process, or parent process, running on a Linux system needs to be uniquely identifiable. So, Linux assigns each process two resources. The first is a unique number called a process ID or PID. No two processes running on the system at the same time will have the same PID number.</p><p>The second is the parent process ID. This is the PID of the process that launched, or spawned, the process. By assigning these two numbers to every running process, we can track the heredity of that process through the system.</p><p>The kernel uses a table to track all the processes running on the system. This process table is maintained in memory by the operating system to facilitate switching between processes, scheduling processes, and prioritizing those processes.</p><p>Each entry in the table contains information about a process, like its name, state, memory address, and the priority it has on the system.</p><p>Understand that systemd or init, whichever one you have, is the grandparent process that spawns all the processes running on the system. When Linux first boots up, the kernel process is created. It loads systemd, as shown in this example, or it loads init. Then, systemd, or init, launches all other child processes.</p><p>These child processes will launch processes. In this example, systemd launches a login shell. Then, within the login shell, we launch a bash shell, which runs the vi process to provide a text editor for the end user to edit files.</p><p>Whenever you launch a process, its process ID will be assigned randomly from the operating system&#39;s table of available PID numbers. However, the systemd or init process will always be assigned a PID of 1. And the systemd or init process has a parent process ID of zero. This is because its parent is the Linux kernel, which always has a PID of zero.</p><p>The systemd or init process is responsible for launching all system processes configured to start automatically on boot. As shown here, it also creates a login in shell that users can use to log in to the system.</p><p>Notice here a login shell that we use to log in and then a second shell, the bash shell, in which the vi editor&#39;s being run.</p><p>Now, why didn&#39;t we just run vi right out of the login shell? And should we just put vi over here and not have a shell between the two? In this example, vi was launched from within this login shell. So, why do we have this bash shell between the login shell and the vi process?</p><p>Because anytime you run a command from within any shell—it doesn&#39;t matter if it&#39;s a login shell, standard shell session, or a terminal shell session—a second subshell is created, and the process for the command you entered is run within it. In this case, we ran vi, so we had to create a subshell from the login shell and run vi in it. The same thing would happen if we tried to run top from the login shell. We&#39;d create another bash shell, and then top would run within it.</p><p>Process of Forking 03:59-05:28 Just remember that the subshell we create is a separate process. It has its own process ID, and the parent process ID of the subshell is the process ID of the original shell where the command was entered. In this example, we&#39;ll run the vi program from within this bash shell session.</p><p>This bash shell session has a process ID of 567, and its parent process ID is 234. Within this bash shell, we run the vi command. When this happens, a second bash shell is created and assigned whatever process ID number is the next available one.</p><p>In this case, let&#39;s assume it&#39;s 591. Because this subshell was created by the process for this shell, the parent process ID number of the subshell is the process ID number of the original shell, 567.</p><p>Then, within that subshell, the process for the vi text editor is created and assigned its own process ID number—in this example, 598. Because it was created by the bash subshell process, its parent process ID is the process ID number of the subshell, 591. This entire process is called forking.</p><p>In this situation, we&#39;ve run the vi command in the original bash shell, the bash subshell is created, and the vi process is created by it. We use the vi editor, and when we&#39;re done, we exit out of the vi text editor. When the vi command is exited, this subshell is terminated, and control is returned to the original shell session.</p><p>Summary 05:28-05:49 That&#39;s it for this lesson. In this lesson, we talked about the Linux heredity process. Then we discussed process identity numbers, both the PID and the PPID. And we ended this lesson by talking about the process of forking whenever we create a new process within a shell session.</p><h2 id="_10-1-3-process-facts" tabindex="-1"><a class="header-anchor" href="#_10-1-3-process-facts"><span>10.1.3 Process Facts</span></a></h2><p>This lesson covers the following topics:</p><ul><li>Process types</li><li>Process numbering</li><li>Process states</li></ul><h3 id="process-types" tabindex="-1"><a class="header-anchor" href="#process-types"><span>Process Types</span></a></h3><p>A process refers to a program that is loaded into memory and is currently running on the system CPU. The following file types can create processes on a Linux system:</p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>Binary executable</td><td> A binary executable is a program written in a programming language that is compiled into a binary file that the CPU can execute. </td></tr><tr><td>Internal shell commands</td><td> An internal shell command is a command built into the shell executable. </td></tr><tr><td>Shell scripts</td><td> A script is a text file that contains one or more commands. When the shell reads the file, it executes the commands as if they were entered through the keyboard. </td></tr></tbody></table><p>Be aware of the following types of processes:</p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td>User</td><td> User processes start when a user executes a program file. For example, a user starts a user process when they execute the <b class="fw-bold">grep</b> command. </td></tr><tr><td>System</td><td> System processes (also known as daemon processes) are started by the operating system, usually when it boots. However, users can also load daemon processes by manually starting a daemon using its init script or by using the <b class="fw-bold">systemctl</b> command. </td></tr></tbody></table><h3 id="process-numbering" tabindex="-1"><a class="header-anchor" href="#process-numbering"><span>Process Numbering</span></a></h3><p>All processes are assigned unique process ID numbers randomly from a list of available numbers. Linux processes use the following identifiers:</p><table><thead><tr><th>Type</th><th>Description</th></tr></thead><tbody><tr><td> Process ID <br> (PID) </td><td> The PID uniquely identifies each process. System-started processes typically have low numbers, while user-started processes have higher numbers. </td></tr><tr><td> Parent Process ID <br> (PPID) </td><td> The PPID identifies the process that spawned (or started) the current process. The process that spawned the new process is known as the parent process, whereas the spawned process is known as the child process. </td></tr></tbody></table><p>Be aware of the following when working with processes:</p><ul><li> Either the init or the systemd process is the first process started by the kernel, depending upon the distribution. These processes: <ul><li>Always have a PID of 1.</li><li> Spawn all additional processes the operating system needs at boot time. </li></ul></li><li><i class="fs-italicize">Forking</i> occurs when a parent process spawns a child process that is identical to the parent. An example of forking is the subshell that the shell creates when a user runs a command at the shell prompt. The command runs within the subshell. When the command completes, the subshell it ran within is destroyed. </li><li> A <i class="fs-italicize">zombie</i> process is one where the process has finished executing and exited, but the process&#39; parent didn&#39;t get notified that the child process was finished and hasn&#39;t released the child process&#39; PID number. Zombie processes can linger in the system, consuming resources and PIDs. A zombie process may eventually clear up on its own. If it doesn&#39;t, you may need to manually kill the parent process. </li><li>A single-threaded CPU can run only one process at a time.</li></ul><h3 id="process-states" tabindex="-1"><a class="header-anchor" href="#process-states"><span>Process States</span></a></h3><h4 id="ps-aux" tabindex="-1"><a class="header-anchor" href="#ps-aux"><span>ps aux</span></a></h4><p>The most common states are:</p><table><thead><tr><th>Process State</th><th>Process</th><th>Description</th></tr></thead><tbody><tr><td>Running</td><td>R</td><td> The process is either running (it is the current process in the system) or waiting for the CPU to process it. </td></tr><tr><td>Stopped</td><td>T</td><td>The process has been stopped or suspended.</td></tr><tr><td>Waiting - Sleep</td><td>S</td><td>Interruptible sleep (waiting for an event to complete).</td></tr><tr><td>Waiting - Uninterruptible sleep</td><td>D</td><td> Uninterruptible sleep. This is a process that cannot be killed or interrupted with a signal. </td></tr><tr><td>Zombie</td><td>Z</td><td> The process has finished executing and exited, but the process&#39; parent didn&#39;t get notified that the child process was finished and hasn&#39;t released the child process&#39; PID number. </td></tr></tbody></table><h2 id="_10-1-4-process-display" tabindex="-1"><a class="header-anchor" href="#_10-1-4-process-display"><span>10.1.4 Process Display</span></a></h2><p>Click one of the buttons to take you to that part of the video.</p><p>Process Display 00:00-00:21 In this lesson, we&#39;re going to look at a couple of tools you can use from the command line of a Linux system to view information about all the various processes running on that system. One of my favorite utilities to do this with is the top utility. Let&#39;s take a look at how it works.</p><p>top Command 00:21-03:22 The top command displays a list of some of the running processes on the system--one process on each line. Let&#39;s look at what each column of information tells us about a running process.</p><p>The PID column displays the process ID number. The USER column displays the name of the user that owns that process. Most of these are owned by root, but one is owned by the rtracy user.</p><p>The PR column identifies the priority assigned to that process. Most of these are running with the same priority level of 20, except for this one with a lower priority number of 0, which actually means it has a higher priority on the system. The NI column displays the nice value, which influences the priority level. We&#39;ll look at how that works later on.</p><p>The VIRT column displays the amount of virtual memory that&#39;s being used. The RES column displays the amount of physical RAM the process is using in kilobytes as its resident size and memory. The SHR column lists the amount of shared memory that&#39;s being used by the process.</p><p>The S column displays the status of the process. There are a few values that could be displayed here. A value of D indicates that the process is uninterruptedly sleeping. R means the process is running. S indicates sleeping. T means that it&#39;s currently stopped; we call that being traced. Z indicates that the process is zombied. A zombied process happens when a process has finished executing and has exited, but somehow the parent process never got notified that the child process was done, and hasn&#39;t released the child&#39;s process ID number. A zombied process may eventually clear up by itself. But if it doesn&#39;t, you may have to manually kill and then restart the parent process that just won&#39;t let go of its child.</p><p>The percent CPU column identifies the percentage of CPU time that&#39;s being consumed by that process. Percent MEM specifies the percentage of available physical RAM that&#39;s being used. The TIME column displays the total amount of CPU time the process has consumed since it was started.</p><p>Finally, the COMMAND column indicates the name of the command that was originally entered at the shell prompt to start this process. For example, we see that the command that was used to start the first process in the output was the top utility itself.</p><p>The top utility is dynamic in nature. It&#39;s continually updating the display with the latest information about the processes running on the system. You&#39;ll see the display automatically change when things change, like one process using more and then less CPU time. Or when another process might request extra memory, and so on.</p><p>However, top shows only a very limited number of processes. There&#39;ll be times when you need to see everything that&#39;s running on the system. In this situation, top just doesn&#39;t cut it. Instead, you may need to use the ps utility.</p><p>ps Utility 03:22-07:46 The ps utility also displays information about processes on your system. But instead of auto updates, the ps utility displays a snapshot of the current state of the processes running at that time. Though you get more information with ps, it&#39;s not dynamically updated like it is with top.</p><p>ps shows the processes that are associated with the current shell session. In this example, I ran the ps command, and we see that there&#39;s a process for the su command. This is displayed because the su utility was used inside the shell to switch to the root user account.</p><p>There&#39;s also a process for the bash session itself. There&#39;s also a process named ps, because we used it to list the current processes. Therefore, its process is listed in the output as well.</p><p>Four columns of information are displayed by default with ps. The first one lists the process ID number. TTY shows the name of the shell session that the process is running within.</p><p>The TIME column displays the amount of CPU time used by the process.</p><p>Lastly, the CMD column displays the name of the command that was entered at the shell prompt to create the given process.</p><p>Notice that only three processes are listed in the output of the ps command. There are actually many, many processes running on this system. Why didn&#39;t they show up? Well, by default ps shows only the processes associated with the current shell session.</p><p>If you want to see all processes on the system, then you have to use some options with the ps command.</p><p>The best one is the -e option, which displays all the active processes on a Linux system.</p><p>You might notice that these processes have a question mark in the TTY column. These are system processes, also called daemons. Remember that a daemon is loaded by the init or systemd process at start up, and therefore is not associated with any particular shell session.</p><p>ps can also show more information by using the -f option.</p><p>-f performs a full-format listing that displays much more about the processes running on the system, and is frequently used in conjunction with the -e option.</p><p>In this example, I ran ps -ef [p s dash e f] at the shell prompt. We see all of the processes running on the system and additional detail about these processes. Notice with the -f option, several new columns have been added to the output.</p><p>First, we have the UID column, which shows the username of the process owner. This is the user that ran the command that created the process.</p><p>Next, we have the PPID column, which shows the process ID number of the parent process.</p><p>The C column shows the amount of processor time utilized by the process.</p><p>STIME shows the time that the process started.</p><p>If you really want to crank things up, you can also add the -l option to the ps command. The -l option displays the long format of the ps output with additional columns of useful information.</p><p>Here, I ran the ps command with all three options we discussed: -e, -l, and -f (-elf). It&#39;s really easy, just remember ps -elf.</p><p>The F column shows the flags associated with the process, using the code shown here. A value of one indicates that the process forked but didn&#39;t execute. A process of four indicates that it used root privileges. A flag of 5 means that both the 1 and 4 flags apply.</p><p>The S column indicates the state of the process using the same codes we saw with the top command.</p><p>The PRI column shows the priority of the process. Notice, we&#39;re now looking at a lot of the same information we saw on top. The NI column shows the nice value. The ADDR column shows the memory address of the process.</p><p>The SZ column shows the size of the process. The WCHAN column shows the name of the kernel process in which the process is sleeping. If the process isn&#39;t sleeping, but currently running, you&#39;ll see a dash (-) in this column.</p><p>free Command 07:46-08:29 Part of managing processes is knowing how much memory has been used and how much is still available. As we saw earlier, you can use the output of top or ps to view this information, but you can also do this by using the free command.</p><p>The free command displays three critical pieces of system information. One, how much memory is free on the system. Two, how much memory has been allocated. And three, the usage of swap memory. Notice here I&#39;ve used the -m and -t (or -mt) options with free. The -m option displays memory statistics in terms of megabytes. The -t option displays totals for each category of information.</p><p>pgrep Command 08:29-09:48 Another command we can use is pgrep. As the name implies, pgrep combines the functionality of the ps and grep commands together into a single utility. When you run pgrep, you specify certain selection criteria you want to look for. Then, pgrep searches through all the currently running processes and outputs a list that matches just the criteria that you specified.</p><p>Now, there&#39;s several different options listed here to run with pgrep to get the results we&#39;re looking for. One option is to use -P followed by a particular parent process ID number to match a specified parent process ID.</p><p>Use -f to tell pgrep to match on a specific process name. Enter -f followed by a name. Also, use the -u option followed by a particular username to find processes owned by a particular user.</p><p>Here, we typed pgrep -u rtracy to display just the processes owned by the rtracy user. We can also use the -l option to display the process name.</p><p>By default, pgrep only displays the ID number of the process. In this example, we ran pgrep -l so we see the second column here of process names.</p><p>Summary 09:48-10:13 That&#39;s it for this lesson. In this lesson, we reviewed the various tools you can use from the shell prompt to view information about the processes running on a Linux system. We first looked at the top utility. We then looked at the ps utility. We looked at free, and we ended this lesson by talking about pgrep.</p><h2 id="_10-1-5-viewing-process-information-with-ps" tabindex="-1"><a class="header-anchor" href="#_10-1-5-viewing-process-information-with-ps"><span>10.1.5 Viewing Process Information with ps</span></a></h2><p>Click one of the buttons to take you to that part of the video.</p><p>Viewing Process Information with ps 00:00-04:07 The ps command can be used to list currently running processes on a Linux system. ps differs from top in that ps only writes to the standard output and doesn&#39;t hold the terminal or update in real-time. Calling ps with no options shows only the processes running from the current terminal. The columns we see are PID (process ID); TTY, an identifier for the terminal (in this case, pseudo-terminal 0); TIME which shows the cumulative CPU time of these processes; and CMD, which shows the short command name. We can see more processes by adding</p><p>the -e flag. This shows us everything and is not limited to the current terminal. We can show more details using the -l (lower-case L) or -f flags, commonly used together and with -e as -elf, to get a detailed listing of all system processes.</p><p>Columns shown here include - F, process flags, a code where 0 is the default, 1 meaning the process hasn&#39;t executed, 4 which means the process is running with root privileges, and - S, the process state code. We&#39;ll talk about these in a moment. - UID is the process&#39; user ID, which is generally the user who owns the process. The -f flag causes this column to show the username rather than the numeric user id. - PID is the process ID. - PPID is the PID of the process&#39; parent. - C is the cumulative CPU usage of the process. – PRI is the priority of the process.</p><p>Lower numbers mean higher priority. - NI is the so-called &quot;niceness&quot; of the process. Generally, higher numbers mean less CPU usage. – ADDR is the memory address of the process. - SZ is the process&#39; &quot;core image size,&quot; which is essentially the total memory used by the process and is given in units of memory pages (typically four binary kilobytes each). - WCHAN, &quot;wait channel,&quot; is if the process is waiting for a system call—this is the name of that system call. - STIME is the start time of the process (relative to boot).</p><p>We&#39;ve seen TTY, TIME, and CMD before, except that the -f flag makes CMD show the long command name, including arguments. Alternatively, the GNU version of ps distributed with Linux also supports what&#39;s called BSD-compatible syntax, where we can get a detailed listing of all processes using ps aux (with no dash). a and u show additional columns (roughly equivalent to l and f, respectively), and x shows all processes.</p><p>Columns shown in this output that we haven&#39;t seen before include – USER, which is similar to the UID column we&#39;ve seen but always shows the username. - %CPU, which is similar to the C column but shown in higher precision. - %MEM is the proportional memory usage of the process. - VSZ is the virtual memory size in binary kilobytes—essentially the total memory usage of the process—including physical RAM and swap. – RSS is the resident set size in binary kilobytes and is essentially the physical RAM usage of the process. – STAT is similar to S but with BSD-style extensions, – START is an alias for STIME, and - COMMAND is an alias for CMD.</p><p>We can use the -o flag to explicitly select which columns we want ps to display using a comma-delimited list of column codes. For example, ps -e -o comm,%mem gives us a list of each process&#39; command and its proportional memory usage as a percentage. A complete list of available column codes is on the ps man page. We can use the -u flag to show processes owned by a given user. For example, the ps -u demo lists processes owned by the currently logged-in demo account.</p><p>Process State Codes 04:07-05:33 The state codes shown by the S column represent what the process is currently doing. Some common values include – R, which stands for running, - I, which stands for idle, meaning the process isn&#39;t currently doing anything, and – S, which stands for sleep. Specifically, interruptible sleep meaning that the process is waiting for the system.</p><p>Less-common codes include - D, meaning uninterruptible sleep and is a special state you might see with a disk or network driver while communicating with hardware. The process won&#39;t respond to anything (even kill signals) until it exits this state. And – T, which means that the process is explicitly stopped. For example, it will occupy the standard input if I run cat without arguments.</p><p>I can now enter the keyboard input control z, which sends a stop signal to cat. And now ps -l shows that cat is still on the process table but is stopped and won&#39;t continue until explicitly signaled to do so. - Z means the process is defunct, also known as a &quot;zombie&quot; process. To show this, we have a non-standard zombie_demo program.</p><p>As you can see, this spawns a child process now marked with a Z. A process becomes a zombie if it terminates, but its parent process doesn&#39;t allow it to be removed from the process table. It&#39;s almost certainly a bug if it occurs and may cause a leak of system resources. We&#39;ll address how to deal with zombie processes in a future demo.</p><p>Summary 05:33-05:44 For now, this has been an overview of the usage and output of the ps command for viewing processes on Linux.</p><h2 id="_10-1-6-viewing-process-information-with-top" tabindex="-1"><a class="header-anchor" href="#_10-1-6-viewing-process-information-with-top"><span>10.1.6 Viewing Process Information with top</span></a></h2><p>Click one of the buttons to take you to that part of the video.</p><p>View Process Information with top and htop 00:00-00:11 In this demo, we&#39;ll use the top and htop utilities to view live running processes on a Linux system.</p><p>Use top 00:11-01:50 Let&#39;s start by running the top command. This display updates periodically as processes on the system are added and change activity. The first line gives a basic system overview. For example, there&#39;s the current time and uptime since boot, the total number of system users, and the average ratio of CPU-to-idle time. The next line shows the total number of processes and their various states.</p><p>On the next line, the CPU usage is broken down between the following: user processes; system processes; nice processes; idle time; IO waiting; hardware interrupts; software interrupts; and so-called stolen hypervisor time. After that, there&#39;s physical RAM amounts in binary megabytes. Then the same values for swap memory, with the last column being total available swap space.</p><p>After then there&#39;s the list of processes, ordered by CPU usage. Columns include the process ID, user, priority, and memory usage. Then there&#39;s the process state code, where &quot;S&quot; means sleep, &quot;I&quot; means idle, and &quot;R&quot; means running. CPU and memory usage as a percentage, cumulative CPU time, and short command names are also there.</p><p>You can scroll this display with the arrow keys. Some interactive commands are available, like Shift + F, which allows you to add or remove columns and change the sort order. Using the arrow keys, you can highlight the parent process ID, column, and space. And then q returns you to the previous view. And on the right, we now see each process&#39;s PPID. For a full list of commands in Interactive Mode, we can press h. To exit back, press the q key again.</p><p>Use htop 01:50-02:39 Now, htop is an optional utility in most Linux distros. It provides similar functionality to top, but with a more sophisticated UI. We launch it by running the htop command. You may immediately notice that htop is rather colorful. CPU, memory, and swap usage are now displayed with graphic bars as well as numbers. The keyboard can be used to navigate and enter interactive commands, just as with top, but now we&#39;re also able to use the mouse. For example, clicking on the column header for PID sorts the table by the values in that column.</p><p>At the bottom are references for interactive commands, which can be used with keyboard and mouse. For example, clicking on Help brings up an explanatory reference, which we can exit with the q key or by clicking anywhere. To exit htop, we can click Quit or press q.</p><p>Summary 02:39-02:51 And that&#39;s it for this demo. This has been an overview of using the top and htop utilities to view processes on a Linux system.</p><h2 id="_10-1-7-viewing-process-information-with-pgrep" tabindex="-1"><a class="header-anchor" href="#_10-1-7-viewing-process-information-with-pgrep"><span>10.1.7 Viewing Process Information with pgrep</span></a></h2><p>Click one of the buttons to take you to that part of the video.</p><p>Using the pgrep Command 00:00-01:09 While ps lists information about all running processes on a Linux system, the pgrep command can retrieve information about specific processes based on command name and other criteria. In this demo, we&#39;ll introduce how to use pgrep.</p><p>The basic use of pgrep lists the process IDs, or PIDs, of all running processes whose command name matches the regular expression provided. For example, we can find the PID of the open terminal emulator with pgrep gnome-terminal. pgrep supports a number of options.</p><p>For example, the -a flag allows us to see the full command name of matching processes, including any command-line arguments. The -x flag makes pgrep only show an exact match rather than using a regular expression. The -n and -o flags make pgrep only show the newest and oldest processes that match the pattern, respectively.</p><p>Summary 01:09-01:17 This has been an introduction to the usage of the pgrep command.</p><h2 id="_10-1-8-process-display-facts" tabindex="-1"><a class="header-anchor" href="#_10-1-8-process-display-facts"><span>10.1.8 Process Display Facts</span></a></h2><p>This lesson covers the following topics:</p><ul><li>Viewing processes using top</li><li>Viewing processes using ps</li><li>Viewing processes using pgrep</li></ul><h3 id="viewing-processes-using-top" tabindex="-1"><a class="header-anchor" href="#viewing-processes-using-top"><span>Viewing Processes Using top</span></a></h3><p>The top command displays the activity of your Linux processor and also displays tasks managed by kernel in real-time.</p><table><thead><tr><th>Command</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td><b>top</b></td><td> The <b>top</b> command: <ul><li> Returns Process ID (PID), uptime, load, CPU status, memory, and priority information for processes. </li><li> Is useful in situations where you need to monitor processes continuously. </li></ul><h2>top</h2><ul><li><b>h</b> to display the help screen.</li><li><b>f</b> to add or remove columns from the chart.</li><li><b>F</b> to show a list of sortable columns, then press the key of the letter next to the column to be sorted. </li><li><b>u</b> to specify processes for a specific user.</li></ul><h2>-u</h2></td><td><b>top -u gshant</b> starts top by monitoring only the gshant user. </td></tr></tbody></table><h3 id="viewing-processes-using-ps" tabindex="-1"><a class="header-anchor" href="#viewing-processes-using-ps"><span>Viewing Processes Using ps</span></a></h3><p>The ps command is used to provide information about the currently running processes, including their process identification numbers (PIDs).</p><table><thead><tr><th>Command</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td><b>ps</b></td><td> Displays a snapshot of currently running processes in ascending order based on the PID. By default, the <b>ps</b> command displays the following information: <ul><li>PID</li><li> Name of the shell session where the process is running (TTY) </li><li>CPU time the process has used (TIME)</li><li>The command used to invoke the process (CMD)</li></ul><h2>ps</h2><ul><li><b>-A, e</b> shows all processes.</li><li><b>-a</b> shows processes owned by other users and attached to a terminal (e.g., foreground processes). </li><li><b>-f</b> shows detailed information for processes.</li><li><b>-u</b> shows processes by user ID.</li><li><b>-l</b> shows the processes in long format and the process <i class="fs-italicize">state</i> (under the STAT column). The process states include: <ul><li>sleeping (S)</li><li>running (r)</li><li>traced (t) by another process</li><li>zombie (Z)</li></ul></li><li><b>-x</b> shows processes that are not attached to a terminal. Use this option to view daemon processes that begin during system boot. </li></ul></td><td><b>ps -Au jsmith</b> shows all processes owned by the user jsmith. <br><b>ps -elf</b> shows detailed information about all processes in long format. <br><b>ps aux</b> shows detailed information about all processes. <h2>Note:</h2><h2>ps aux | less</h2></td></tr></tbody></table><h3 id="viewing-processes-using-pgrep" tabindex="-1"><a class="header-anchor" href="#viewing-processes-using-pgrep"><span>Viewing Processes Using pgrep</span></a></h3><p>The pgrep command combines the functionality of the ps command, and the grep command into one single command or utility. When you run pgrep, you can specify certain selection criteria that you want the command to look for. The command then searches through all the currently running processes and then outputs a list of only those processes that match the criteria that you specify.</p><table><thead><tr><th>Command</th><th>Description</th><th>Example</th></tr></thead><tbody><tr><td><b>pgrep</b></td><td><p> The pgrep command includes many options. The following are a few of the more useful options: </p><ul><li><b>-f</b> searches for a specific process name.</li><li><b>-p</b> only match processes whose parent process ID is listed. </li><li><b>-u</b> only match processes whose effective user ID is listed (the user that owns the process). </li></ul></td><td><b>pgrep -l -u jsmith</b> show all the process owend by jsmith (-u) in long (-l) format. </td></tr></tbody></table>',147)]))}const l=s(n,[["render",a],["__file","01.html.vue"]]),p=JSON.parse('{"path":"/10/01.html","title":"Section 10.1 Processes","lang":"zh-CN","frontmatter":{"lang":"zh-CN","title":"Section 10.1 Processes","description":"some description"},"headers":[{"level":2,"title":"10.1.1 Linux Processes","slug":"_10-1-1-linux-processes","link":"#_10-1-1-linux-processes","children":[]},{"level":2,"title":"10.1.2 Process Heredity","slug":"_10-1-2-process-heredity","link":"#_10-1-2-process-heredity","children":[]},{"level":2,"title":"10.1.3 Process Facts","slug":"_10-1-3-process-facts","link":"#_10-1-3-process-facts","children":[{"level":3,"title":"Process Types","slug":"process-types","link":"#process-types","children":[]},{"level":3,"title":"Process Numbering","slug":"process-numbering","link":"#process-numbering","children":[]},{"level":3,"title":"Process States","slug":"process-states","link":"#process-states","children":[]}]},{"level":2,"title":"10.1.4 Process Display","slug":"_10-1-4-process-display","link":"#_10-1-4-process-display","children":[]},{"level":2,"title":"10.1.5 Viewing Process Information with ps","slug":"_10-1-5-viewing-process-information-with-ps","link":"#_10-1-5-viewing-process-information-with-ps","children":[]},{"level":2,"title":"10.1.6 Viewing Process Information with top","slug":"_10-1-6-viewing-process-information-with-top","link":"#_10-1-6-viewing-process-information-with-top","children":[]},{"level":2,"title":"10.1.7 Viewing Process Information with pgrep","slug":"_10-1-7-viewing-process-information-with-pgrep","link":"#_10-1-7-viewing-process-information-with-pgrep","children":[]},{"level":2,"title":"10.1.8 Process Display Facts","slug":"_10-1-8-process-display-facts","link":"#_10-1-8-process-display-facts","children":[{"level":3,"title":"Viewing Processes Using top","slug":"viewing-processes-using-top","link":"#viewing-processes-using-top","children":[]},{"level":3,"title":"Viewing Processes Using ps","slug":"viewing-processes-using-ps","link":"#viewing-processes-using-ps","children":[]},{"level":3,"title":"Viewing Processes Using pgrep","slug":"viewing-processes-using-pgrep","link":"#viewing-processes-using-pgrep","children":[]}]}],"git":{"updatedTime":1736673740000},"filePathRelative":"10/01.md"}');export{l as comp,p as data};
