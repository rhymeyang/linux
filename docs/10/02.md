---
lang: zh-CN
title: Section 10.2 Process Management
description: some description
---

As you study this section, answer the following questions:

<ul><li>What is the difference between a process running in the foreground and a process running in the background?</li>
<li>Which commands can be used to move processes between the foreground and the background?</li>
<li>How can you change the priority of a process?</li>
<li>What is the range for <b class="fw-bold">nice</b> values?</li>
<li>What number would be the highest priority for a <b class="fw-bold">nice</b> value?</li>
<li>Which termination signal is sent by the Ctrl+z key combination?</li></ul>

In this section, you will learn to:

- Stop a zombie process
- Bring an application to the foreground

Key terms for this section include the following:

<table class="terms">
<thead>
  <tr>
    <th>Term</th>
    <th>Definition</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>Foreground</td>
    <td>
      The area where a command or task runs directly from a terminal and
      must complete before continuation. No other commands can run on the
      terminal until that process completes.
    </td>
  </tr>
  <tr>
    <td>Background</td>
    <td>
      The area where a task can run while other processes run in the
      foreground.
    </td>
  </tr>
</tbody>
</table>

This section helps you prepare for the following certification exam objectives:

<table class="objectives">
<thead>
  <tr>
    <th>Exam</th>
    <th>Objective</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>TestOut Linux Pro</td>
    <td>
      1.4 Manage system processes
      <ul>
        <li>Start, stop, and restart system services</li>
        <li>Monitor and manage running processes</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>CompTIA Linux+ XK0-005</td>
    <td>
      <p>
        1.4 Given a scenario, configure and use the appropriate processes
        and services
      </p>
      <ul>
        <li>
          Process management
          <ul>
            <li>
              Kill signals
              <ul>
                <li>SIGTERM</li>
                <li>SIGKILL</li>
                <li>SIGHUP</li>
              </ul>
            </li>
            <li>
              Setting priorities
              <ul>
                <li>nice</li>
                <li>renice</li>
              </ul>
            </li>
            <li>
              Process states
              <ul>
                <li>Zombie</li>
              </ul>
            </li>
            <li>
              Job control
              <ul>
                <li>bg</li>
                <li>fg</li>
                <li>jobs</li>
                <li>Ctrl+Z</li>
                <li>Ctrl+C</li>
                <li>Ctrl+D</li>
              </ul>
            </li>
            <li>pkill</li>
          </ul>
        </li>
      </ul>
      <p>
        4.3 Given a scenario, analyze and troubleshoot central processing
        unit (CPU) and memory issues
      </p>
      <ul>
        <li>Zombie processes</li>
      </ul>
    </td>
  </tr>
</tbody>
</table>

## 10.2.1 Process Management

Click one of the buttons to take you to that part of the video.

Process Management 00:00-00:15
In this lesson, we'll discuss how to manage running Linux processes. Specifically, we'll look at running processes in the background, and switching processes between the background and the foreground.

Use subshell 00:15-00:34
Let's start by talking about how you run processes in the background. Recall that whenever you run any command at the shell prompt on a Linux system, a new subshell process is created. That process is run within that subshell. As soon as that process exits, the associated subshell is destroyed as well.

Use subshell 00:34-01:26
Here's the key thing you need to remember. During the time that process remains running, the shell prompt of the parent shell disappears. And you can't do anything at the shell prompt unless you were to open up a new terminal session. This happens because the process is running in what's called the foreground.

Now, this behavior is even more apparent when you run a graphical application from the shell prompt. In this example, I've used the libreoffice command to launch the LibreOffice application.

Notice that while LibreOffice is running over here, the shell prompt is unavailable, and is going to remain that way until I close this window by clicking on that X right there or clicking File > Exit. Only then can I enter additional commands at the shell prompt.

This is the default behavior for any command you enter at the shell prompt. It doesn't matter whether that command runs a text-based shell program or a graphical program. The effect is the same.

Run in Background 01:26-02:37
But it's possible to run the program in the background instead. If you do this, the program you launch will run normally, but control will be returned immediately to the shell session where you ran the command. Then, you can use the shell to launch other programs or to perform other tasks.

The process for doing this is quite easy. In this example, I've run the same application that I ran in the previous example. I entered libreoffice at the shell prompt but notice that I added one character at the end of the command.

I added a space and then I appended an ampersand (&) character to the command. This is very important. This ampersand character tells the shell to run the program in the background instead of the foreground. By doing this, I still have the same graphical application window that I had before, but I get my shell prompt back.

Notice that when I ran this command with the ampersand, two values were displayed on the screen once the process was loaded into the background. The first value right here is the job ID and the second value is the process ID of the process being run to create this application.

This job ID number is very important because it helps you keep track of all of your background jobs. In fact, you can view a list of all the background jobs currently running on the system by entering the simple jobs command at the shell prompt.

Switch Process Background and Foreground 02:37-05:08
As you can see in this example, I have just one background job running, with a job ID of 1. The status is running, and here's the name of the command that I used to create that background job.

Just because a process was loaded into the background or foreground doesn't mean that it has to stay there. You can switch a process between the foreground and the background while it's still running.

So what do you do if you have a process currently running in the foreground, and you decide, "Wait a minute, I actually want that running in the background"? One option would be to close the application and load it again using the command that we just looked at – appending an ampersand to the end of the command.

However, there is another, and I think better, way to do this – by using the two shell commands shown here.

The first one is the fg command. This command will move a background process to the foreground. To use the fg command, you have to know the job ID number of that process that you want to move from the background to the foreground. Use the jobs command to find out what that is if you don't already know it.

Once you do, just type fg and then the job ID number, and the process jumps from the background into the foreground. You can do just the opposite with the bg command. As its name implies, this command will take a process that's running in the foreground and move it into the background.

But before you can do this, you have to assign the foreground job an ID number. Remember, when we loaded a process directly into the background, it was assigned a job ID number by default. If we have a foreground job, we've got to assign it one of those numbers before we can move it into the background. Do this by pressing the Ctrl + Z key sequence.

When you do this, you'll see the process stop, and a new job ID number will be assigned to that process. Once that's done, all you have to do is type bg followed by the job ID number that was just assigned, and it will move that process from the foreground to the background, and continue running.

An example of how to do that is shown here. In this example, I ran the vi Editor to edit the zombie.c file. Notice that I didn't include an ampersand right here.

Therefore, this process ran in the foreground. Then I decided "Wait a minute, I don't want it running in the foreground. I want it running in the background."

So, I pressed Ctrl+ Z. When I did, a job ID number was assigned, and the process was temporarily stopped. Here's the name of the command that was used to start the original process. Then I typed the bg command followed by the job number, which moved the process into the background, and it started running again.

Summary 05:08-05:26
That's it for this lesson. In this lesson we talked about managing running Linux processes. We first talked about how to run a process in the background. Then we looked at how you can move a process that's already running in the foreground to the background.

## 10.2.2 Switching Foreground and Background Processes

Click one of the buttons to take you to that part of the video.

Switching Foreground and Background Processes 00:00-00:17
In a Bash shell environment, processes can be run in the foreground or background. In this demonstration, we'll look at background processes and how to switch processes between the foreground and background.

Run a Process in the Background 00:17-01:15
By default, when we call a command in the shell, it runs in the foreground. If, for example, we run the gedit command to launch the Gnome text editor, we're not given a new shell prompt right away. The gedit command will continue to occupy the shell while the text editor is open, and until the current command is done, we can't enter any new commands.

We can indicate to the shell that a command is to run in the background by putting an & after the command-line, for example, gedit &. The text editor is running, but we're also free to enter more commands. Note these numbers on the standard output, [1] in brackets is the job number of the background gedit process, and 6030 is its process ID or PID. Both of these are useful for managing the background process.

Move a Process to Background 01:15-01:51
Suppose we run a command without the &; in this case, let's use gnome-calculator. We can move this process to the background at any time. First, we'll enter control z into the terminal. This sends a stop signal to the gnome-calculator process. The shell shows us the job number is 2 for the stopped gnome-calculator process and gives us a prompt. We can now resume running gnome-calculator in the background using the bg command (for background) with the job number as the argument—in this case, bg 2.

Move Process to Foreground 01:51-02:00
If we wanted to move a background process to the foreground, we could do that with the fg command—for the foreground—and again with the job number as the argument.

View the Current Shell's Background Processes 02:00-02:11
The jobs command gives us a list of all the background processes in the current shell environment, which can be useful for further managing them and when writing shell scripts.

Summary 02:11-02:22
In this demonstration, we've looked at running processes in the foreground and background of the shell.

## 10.2.3 Process Prioritization

Click one of the buttons to take you to that part of the video.

Process Prioritization 00:00-00:55
In this lesson, we'll talk about how to prioritize processes running on a Linux System.

Linux is a multitasking operating system. It rotates CPU time between each of the processes running to create an illusion that they're all running concurrently. Because of this, you can specify a priority level for each process running on the system.

By default, Linux doesn't do prioritization. Instead, it tries to equalize the amount of CPU time given to all the processes running on the system, with very few exceptions.

However, there may be times when you need to adjust the priority assigned to a particular process. For example, if the system's being used for a web server, it should have a higher priority than the other processes running on it.

You can do this using several Linux utilities. For now, let's explore two of the most popular commands for prioritization: nice and renice.

PR and NI 00:55-02:22
The nice utility can launch a new process on a Linux system with a customized priority level.

You've probably seen it before. Whenever you use the commands top and the ps to display information about the processes running on a Linux system, they show you two things: the priority value, or PR, and the nice value, or NI. The higher the priority number, the lower the priority of the process. I know it's a bit counterintuitive, but you'll get used to it.

In this example, most processes run with a priority value of 20. But, if you look down here, this process has a priority of 0. Because this one uses a lower number, it has a higher priority than all the others.

Now let's focus a little more on the nice value. The nicer the process, the less CPU time it demands. The less nice a process is, the more CPU time it demands. It's factored into the kernel's calculations that determine the overall priority of the process. The nice value for any Linux process can range between negative 20 to positive 19.

Notice in the output of the top command here that most of these processes have the same nice value of zero. This is the default value and makes them all have the same level of priority on the system.

However, if you look here, you can see that there's one exception, the kworker process. It has a nice value of negative 20, which has a lower priority value than the other processes. This means it has a higher priority level on the system.

Nice Value 02:22-02:50
The next key thing you need to understand is that you can't directly manipulate the priority of a process. But you can indirectly manipulate it by customizing a process' nice value. The easiest way to do this is to set the process' nice value when you initially load it at the shell prompt.

This is when the nice command becomes useful. Here's the syntax for it. Enter "nice -n" followed by the nice level you want to assign to the process, followed by the name of the command you want to run.

Default Priority and Nice Levels 02:50-03:19
For example, suppose I wish to launch the gedit program from the shell prompt. Gedit is a graphical text editor for Linux systems. But I want to launch gedit with increased priority on the system because I take my text editing seriously.

By default, gedit will receive a priority of 80 because it will be assigned a nice value of zero. That nice value is used by the kernel to calculate the overall priority of this process. And using its various calculations, it results in 80.

nice Syntax 03:19-03:49
I also want the best performance possible when editing text. To achieve this, I need a higher priority level, so I should decrease its nice value.

For example, here, I entered "nice -n -15" followed by the "gedit" command. As you can see, this caused the priority number assigned to gedit to decrease and its overall priority on the system to increase. After running the command, my nice value reduced to negative 15, and my priority number reduced to 65.

Use nice 03:49-04:20
With that said, be aware that Linux is hesitant to let you reduce the value of the nice parameter for processes running on the system. That's because multiple users on the same system can adjust the nice values of their own processes. And naturally, every user will try to crank down the nice value of their processes over other users' processes to increase their priority level on the system. This will cause a tug-of-war of sorts between users.

To keep this from happening, Linux won't let you adjust the nice value of a process below zero unless you're logged in as root.

Using renice 04:20-06:05
The nice command works great for modifying the nice value when you're initially running a command at the shell prompt to start a process. But what about if the process you want to modify is already running and you don't want to, or can't, restart it? Maybe it's running some mission-critical application, and if you shut it off and restart it with a new nice value, you're going to have the entire company coming after you with pitchforks.

In this situation, you can use the renice command because it allows you to adjust the nice value of a process that's already running. Here's the syntax for it. We run renice -n, followed by the nice level we want to assign. And this time, we reference the process ID number instead of the command name.

So, in this example, gedit is already running on the system. It has a nice value of negative 15, and its priority level is 65. Let's say that because I did that, I'm causing all kinds of havoc on the system, and I'm using way more resources than I should just to edit text files. But I still take my text editing seriously, so I don't want to exit out of gedit and reload it with nice. I want to change its nice value dynamically while it's still running.

So, the first thing I do is run ps -elf to find out the PID number of the gedit process, which in this case is 4133. Then I run the renice command and specify a nice value of 4.

Notice that when I do that, the priority and nice value of the gedit process get much higher than before, making gedit a much nicer, friendlier program.

One quick thing I'd like to point out is that when you're using renice, you're still constrained by the same rule we talked about with nice. You must be logged in as root if you want to adjust the nice level of a running process to a number that's less than zero or a negative number. If you're logged in as a regular user, you can set its value only to zero or higher.

Summary 06:05-06:23
That's it for this lesson. In this lesson, we reviewed how to manage process priorities using the nice and renice commands. They're easy to use and helpful when you need the system to focus on a certain process.

## 10.2.4 Prioritizing Processes

Click one of the buttons to take you to that part of the video.

Adjusting Process CPU Priority 00:00-00:40
The Linux kernel uses an attribute called process priority to determining how much CPU time is used in executing each process. One of the factors the system uses to calculate a process's priority is an attribute called "niceness", which the user can set using the nice and renice commands. In this demonstration, we will go over both of these commands.

A process's niceness is a number between -20 and 19. A higher number means the process is "nicer", or in other words, that it uses less CPU and allows other processes to use more. A lower number means the process is less nice, that it uses more CPU.

The nice Command 00:40-01:34
The nice command can be used to start a process with a specific nice value. nice is run as a command with arguments and a given niceness value. For example, we can call nice -n 0 ./use_cpu.sh & and nice -n 19 ./use_cpu.sh & to run the same CPU-heavy script with two different niceness values.

To view the nice values of a process, the ps -l command can be used. Using the utility top with a filter allows us to see these processes' CPU usage in real time. Just as expected, the nicer one is using much less of the CPU.

The renice Command 01:34-01:52
Using the renice command, we can change the niceness value of a process that's already running. Let's make our first process a little nicer with renice -n 5.

We can see the new niceness has taken effect.

Niceness and Privileges 01:52-03:13
An unprivileged user is not allowed to hog CPU time on a shared system, and so is not allowed to start a process with niceness less than zero.

An unprivileged user is also not allowed to decrease the niceness of any process, even to a value greater than zero. For that reason, you should be careful before setting niceness with an unprivileged user account.

An unprivileged user is also not allowed to renice any other users' processes. On the other hand, a superuser is allowed to renice any process to any niceness value.

However, the superuser cannot directly set the priority value of a process; that is determined exclusively by the kernel. By using the nice and renice commands, the superuser can affect the way the kernel calculates priority.

Summary 03:13-03:29
In this demonstration, we've covered how processes can have their priority affected using the nice and renice commands. Nice is used when starting a process, and renice is used to modify an already running process.

## 10.2.5 Process Management Facts

When a process runs in the foreground, no other commands can be run from that terminal until the foreground process terminates. Therefore, it is important to know how to move processes to the background to allow additional commands to be run.

This lesson covers the following topics:

- Moving processes between the foreground and the background
- Adjusting process priorities

### Moving Processes between the Foreground and the Background

The following table describes ways to move processes between the foreground and the background.

<table>
<thead>
  <tr>
    <th>Command</th>
    <th>Function</th>
    <th>Examples</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>
      <b><i>command</i> &amp;</b>
    </td>
    <td>
      Starts a process in the background, leaving the shell available for
      other commands. When running a process in the background, the shell
      displays the following information:
      <ul>
        <li>The job ID in brackets</li>
        <li>The process ID (PID)</li>
      </ul>
    </td>
    <td>
      <b>gedit &amp;</b> starts the gedit process in the background.
    </td>
  </tr>
  <tr>
    <td><b>jobs</b></td>
    <td>
      Views background jobs and their associated job ID numbers. The job
      ID number is specific to the terminal session. Each opened terminal
      has its own set of jobs and job ID numbers. Jobs from one terminal
      cannot be managed from a second terminal using job ID numbers.
      <b>jobs's</b> options function as follows:<br />
      <br />
      <b>-c</b> prints the command name for each process in jobs.<br />
      <b>-g</b> only print the group id of each job.<br />
      <b>-l</b> only the last job to be started is printed.<br />
      <b>-p</b> print the process id for each process in all jobs.<br />
    </td>
    <td>
      <b>jobs -p %p</b> display the process ID or jobs for the job whose
      name begins with “p.”
    </td>
  </tr>
  <tr>
    <td><b>bg</b></td>
    <td>Sends a job to the background.</td>
    <td><b>bg 3</b> sends the job with job ID 3 to the background.</td>
  </tr>
  <tr>
    <td><b>fg</b></td>
    <td>Brings a job to the foreground.</td>
    <td><b>fg 1</b> brings the job with job ID 1 to the foreground.</td>
  </tr>
  <tr>
    <td><b>Ctrl+z</b></td>
    <td>
      Pauses a running process and sends it to the background. A job ID
      number is assigned to the process.
    </td>
    <td></td>
  </tr>
  <tr>
    <td><b>Ctrl+D</b></td>
    <td>
      Sends the end-of-file (EOF) marker to bash, which closes bash.
      Frequently used to indicate no more input should be read.
    </td>
    <td><br /></td>
  </tr>
</tbody>
</table>

### Adjusting Process Priorities

The following table describes ways to adjust process priorities.

<table>
<thead>
  <tr>
    <th>Command</th>
    <th>Function</th>
    <th>Examples</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td><b>nice</b></td>
    <td>
      Starts a process and customizes its priority on the system by
      manipulating the process' nice value. Be aware of the following:
      <ul>
        <li>
          Each process running on a Linux system has a priority (PR) and
          nice (NI) value associated with it.
          <ul>
            <li>
              The PR value represents the process' kernel priority. The
              higher the PR value, the lower the priority of the process.
              The lower the PR value, the higher the process' priority.
            </li>
            <li>
              The NI value is factored into the kernel calculations that
              determine the PR value of a process. Changing the NI value
              associated with a process also changes its PR value.
            </li>
          </ul>
        </li>
        <li>
          NI values range from <b>19</b> (lowest priority) to
          <b>-20</b> (highest priority). The higher the NI value, the
          lower the process' priority. The lower the NI value, the higher
          the process' priority.
        </li>
        <li>
          Use <b>-n</b> to specify the priority value. If no value is
          specified, the process starts with a nice value of 10 by
          default.
        </li>
        <li>
          Zero (0) is the default nice value for processes not executed
          with the <b>nice</b> command.
        </li>
      </ul>
      <div>
        <div>
          <div>
            <div class="to-icon large" aria-hidden="true" style="width: 20px">
              <svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div>                    
            <div class="to-info-box-body-content">
              <span>
                To keep users from abusing the nice command, standard
                users are not allowed to specify a nice value less than
                <b>0</b>. Only root can assign a nice value that is a
                negative number.</span
              >
            </div>
          </div>
        </div>
      </div>
    </td>
    <td>
      <b>nice -n 7 gedit</b> starts gedit with a nice value of 7. This
      runs the process with a lower priority than the default.
      <br />
      <br />
      <b>nice -n -9 gedit</b> starts gedit with a nice value of -9. This
      runs the process with a higher priority than the default.
    </td>
  </tr>
  <tr>
    <td><b>renice</b></td>
    <td>
      Assigns a new nice value to a running process using the PID of the
      process. The command can contain multiple PIDs separated by a space
      to give them all the same priority number. The nice values assigned
      are identical to those used with the <b>nice</b> command. You can
      use several options with <b>renice</b> :
      <ul>
        <li><b>-n</b> specifies a priority.</li>
        <li><b>-u</b> specifies a user.</li>
        <li><b>-g</b> specifies a group.</li>
      </ul>
    </td>
    <td>
      <b>renice -5 3346</b> assigns a nice value of -5 to the process with
      a PID of 3346. This raises the priority of the process from the
      default.
      <br />
      <br />
      <b>renice 7 2266 3902</b> assigns a nice value of 7 to both
      processes. This lowers the priority of both processes from the
      default.
      <br />
      <br />
      <b>renice 5 -u userbob</b> sets the nice value of all processes
      owned by userbob to 5.
    </td>
  </tr>
</tbody>
</table>

## 10.2.6 Process Termination Part 1

Click one of the buttons to take you to that part of the video.

Process Termination 00:00-00:43
Let's spend a few minutes discussing how to kill a running process from the shell prompt.

Normally, you'd use the appropriate exit function coded into nearly all applications to end its process. For example, if you were in the vi editor and wanted to get out, you'd enter a colon (:) to enter command-line mode and then enter exit to end the vi process.

However, there are times when this won't work. For instance, if a process is hung and you can't get it to exit out properly, you may need to manually kill it.

There are two different ways to do this. One is to use either the kill or the killall command. The other is to use the pkill command, but we'll look at this last one in a different lesson.

Use kill 00:43-03:11
Let's begin by looking at the kill command. As its name implies, the kill command terminates a running process. Here's the syntax. Enter kill, then a dash (-), then enter which kill signal you want to send, followed by the process ID number of the process you want to terminate. A nice thing about this command is its flexibility. There are about 64 different types of kill signals you can send to a process. Some are very kind and gentle; others are very brutal.

These are a few of the most useful kill signals. This first is the SIGHUP or signal hang-up. This is a very kind and gentle kill signal. The second is the SIGINT kill signal. This one tries to stop the process, but it does so very politely. This is the equivalent of pressing Ctrl+C on the keyboard to stop the process from running. If the process is behaving properly, it should respond. If it's not, it probably won't.

If you need to get a little meaner, you can use SIGTERM or kill signal 15. This signal tells the process to terminate immediately. In fact, if you don't specify a signal here with the kill command, this is the one that'll be sent by default. The good thing about SIGTERM is that it tries to be a bit polite by allowing the process to clean up after itself as it exits.

Unfortunately, some processes won't respond to either SIGINT or SIGTERM. That's when SIGKILL comes in. This is kill signal number 9, and it's a lot more brutal. If a process is hung badly, this option will force it to stop. And, as I said, it's a brute force signal because it doesn't give the process an opportunity to clean up after itself.

When I say clean up after itself, I'm talking about freeing up resources that may've been allocated to that process, such as memory addresses associated with it. Those resources will remain allocated to the process you killed until you restart the system itself. When you run the kill command, you can use either the name or the number of the kill signal. Either one works. One important thing to remember about using the kill command is that you must specify the process ID number of the process that you want to kill. So, first, you'll need to use ps or top at the shell prompt to identify the process ID number.

In this example, I have the gedit program running. Its process ID number is 4133. If I wanted to kill it, I would enter kill, followed by the signal I want to send, followed by the process ID number. Notice that I used SIGTERM in this command. That's the same as signal 15, which allows gedit to clean up after itself as it exits, freeing up any system resources allocated to it. This'll allow the gedit process to exit out cleanly.

Kill Processes Properly 03:11-03:34
This example also brings up a mistake many new Linux system administrators make when they start working with the kill command. They want to bypass all the polite kill signals and go right for the brutal ones. They're going for the jugular first.

But this isn't the best way to do things. Yes, using SIGKILL will work most of the time, but it's better if you try the cleaner, more polite signals first. If these kill signals fail, then go for a more brutal one.

Kill Processes Properly 03:34-03:59
I suggest you use the sequence you see here. First, try sending a SIGINT kill signal and see if the process responds. If it doesn't, try the SIGTERM kill signal. Nine times out of ten, this fixes the problem. And it's better because it allows that process to exit cleanly, freeing up any resources allocated to it. But, on rare occasions, you may find that SIGTERM doesn't work, in which case, you'll need to get mean and send it a SIGKILL.

Use killall 03:59-04:55
In addition, to kill, there's also the killall command. It's very similar to kill. Even the syntax is almost the same. The key difference is that with killall, you specify the command name of the process to be killed instead of its process ID number. For example, here, once again, we need to kill that pesky gedit process. I'm going to send it a kill signal 15.

To do this with killall, I enter killall -15, followed by the name of the process, gedit. This'll send the SIGTERM signal to the process named gedit. Basically, it allows you to kill the process without needing the process ID number.

I strongly suggest that you spend some time looking at the man page for both kill and killall. Both commands are quite extensive, and there are a lot of different things you can do with them. We don't have time or space to cover all the different options here. For example, on the man page, you'll see that you can use the dash u option with the kill and killall commands to kill processes owned by a specific user.

Summary 04:55-05:12
That's it for this lesson. In this video, we reviewed killing a running process on a Linux system from the shell prompt. We discussed how to use the kill and killall commands. We also laid out the most proper ways of killing processes.

## 10.2.7 Process Termination Part 2

Click one of the buttons to take you to that part of the video.

Process Termination 2 00:00-00:19
In the last video, we talked about two ways to kill running processes from the shell prompt. One's to use either the kill or the killall command. The other is to use the pkill command. Since we already explored both kill and killall in the last lesson, we'll now move on to the second option, which is to use the pkill command.

Use pkill 00:19-01:15
You can also use another command to kill running processes, the pkill command. This command is a close cousin of the pgrep command. In fact, if you look at the man page for pkill, you'll see that it's the same content as the one for pgrep.

The two commands also use the same options. pkill is very useful. It can search for processes that match specific search criteria you specify and then send those matching processes a particular kill signal.

In this example, I need it to search for any running processes whose name contains the term gedit. I only have one here, but it's possible that I could have multiple processes with gedit in their name. To find all those processes, I enter pkill, followed by the kill signal I want to send—either its name or number.

Let's send kill signal 15, SIGTERM, and then specify the term I want to search for in the name; in this case, gedit. This'll kill every process that has gedit in its process name.

Use nohup 01:15-02:01
The last topic we need to address before we end this lesson is how to keep a process running even if you log out of the system. As we've discussed, various signals can be sent to running processes to indicate that a system event of some type has occurred and that the process needs to respond in some way. A very commonly used one is the hangup signal we talked about earlier, the SIGHUP. Linux keeps track of which processes are being run by each shell session, and when a user logs out of a shell session, Linux sends a SIGHUP signal to all the programs associated with that shell session.

Normally, each process will respond as it's supposed to when it receives a SIGHUP signal. However, a process can also be told to ignore any SIGHUP signals, allowing it to remain running even if you log out of your shell session. One way to do this is to use the nohup utility. It stands for no hangup.

Use nohup 02:01-03:22
For example, suppose I created a shell script called updatemydb that automatically updates a local database with information from an external data source. This script takes a long time to run. It may take three to four hours, and I'm leaving for the night, but I don't want my system logged in while it runs. So, I enter nohup at the shell prompt, followed by the command that I want to run, updatemydb, then I run it in the background with the ampersand (&) command. I can then go ahead and log out. Even though I've logged out, the process created by this command will continue to run.

Now, the shell session where I ran the command will be gone when I log out. This could be a problem if the command generates something that's sent to the standard out, such as text on the screen like, "Command was successful," or if there's an error message sent to standard error. Because the shell session is gone, standard out and standard error have no place to display their information. Therefore, if the command generates output for standard out or standard error, nohup will redirect the standard to a text file in your /home directory called nohup.out. You can look at it after the command is done, when you come back in, and ensure everything ran properly.

It's important to note that any command running with nohup is only immune to hangup signals. All other kill signals will still work. For example, I could run updatemydb with nohup but still send a SIGTERM kill signal with kill, and it'll respond. It'll shut down.

Use screen Commands 03:22-05:31
Another command you can use to accomplish a similar result is screen. This command is interesting and very useful, especially if you're accessing a Linux system remotely over the network using an SSH connection. The key benefit of screen is that it allows you to use multiple shell windows within a single SSH session. This is beneficial because it can keep an SSH shell active, even if the network goes down. Whatever you were running will continue, even if you lost the connection.

You can also use screen to disconnect and reconnect to a particular shell session from a different location. In addition, screen doesn't need to stop and then restart whatever process you were working on. Just run it by simply entering the screen command at the shell prompt. Then, you'll see a shell prompt displayed that looks the same as the shell prompt you were working with before. However, it's different because now you're inside a screen window instead of within the shell session itself.

The window functions like a normal shell session; you can run commands and interact with programs just as you would from any other shell prompt. But you can do other things too. For example, if you press Ctrl+A within the screen window, anything you type after CTRL+A will be sent to the screen process instead of to whatever process you're running in the shell session.

Let me show you. If you press Ctrl+A, followed by C, a new screen window will be created. But the old window you were working in will remain active, along with any processes that were running within it. This allows you to run multiple commands within one single SSH session.

For example, you can run top in one window, then open another one and use an email client to check your email. If you press Ctrl+A, followed by N, you can toggle between all your open windows within the screen. Pressing CTRL+A, followed by D, will detach your screen window and drop you back to your original shell prompt, but whatever processes you had running in all the various screen windows will remain running.

In fact, you can completely log out of the server and be gone, but everything you were running will continue within that detached window. And, most likely, you'll want to reattach to that window at some point. To do that, use the screen -r command, which will reattach you to any detached screen windows you may've started previously. If you have multiple screen windows, you'll have to specify which one you want to reattach to.

Summary 05:31-05:50
That's it for this lesson. In this lesson, we reviewed killing a running process on a Linux system from the shell prompt using the pkill utility. We also discussed using the nohup and screen commands to keep a process running even when you're logged out from the system.

## 10.2.8 Terminating Processes

Click one of the buttons to take you to that part of the video.

Terminate Processes 00:00-00:39
In Linux, if the user wishes to end a process, there are a few preferred methods, depending on the program type. For a graphical application, the user interface typically has a close button. For a service, it's generally best to use systemctl stop. A long-running command occupying a terminal can be interrupted with the keyboard input Ctrl+C.

However, there are occasions when these methods don't work or can't be used. The commands kill, killall, and pkill can be used to terminate running processes. In this demo, we'll go over how to use these commands and the differences between them.

kill 00:39-01:19
The first command we'll touch on is kill. kill terminates a process given the process' PID. Currently on screen are two terminal emulators side-by-side. In the one on the right, I'll start a script that repeats a message and never stops. By ending the line with &, Bash tells me the PID of the script process (and runs it in the background). Now in the terminal on the left, I can enter kill 4224, and the script on the right terminates.

Because every PID is unique, kill will only affect the individual process specified and its children. However, it's not always convenient to determine the PID of a process. As a rule, elevated privileges are required to terminate a process started by another user.

killall 01:19-01:33
The killall command is similar to kill, but instead of using a PID, killall targets processes by command name. For example, if I start the script repeating again and then call killall repeat.sh, the script terminates.

pkill 01:33-02:33
The pkill command is similar to killall but with a different syntax. By default, killall must be given an exact match to the command name. Meanwhile, pkill, by default, is given a regular expression that could match multiple command names. For example, by starting the script once again, it can be terminated simply with pkill repeat. In fact, both pkill and killall support exact name matches and regular expressions through different command-line options.

Being able to terminate a process by its command name can be more convenient than trying to determine the appropriate PID. However, if multiple processes of the same command are running (for example, a background process or a process owned by another user), then pkill and killall may terminate those processes unintentionally. Care should be taken with these commands, especially when run with elevated privileges. pkill and killall support options to limit the user and group ID of processes they target. killall can also be limited by the amount of time the process has been running.

Signals 02:33-04:23
All three of these commands work by sending what is called a signal to the process. Signals are a fundamental part of the Linux operating system, and different signals have different effects. By default, kill, killall, and pkill send SIGTERM for terminate, signal number 15. This directs the process to stop what it's doing and terminate gracefully. However, these commands can be used to send any Linux signal.

SIGINT, or interrupt, signal number 2, is the signal sent when the keyboard sequence Ctrl+C is used. This causes the process to stop what it's doing. If it's an interactive program, it usually returns to a prompt that the user can use to exit gracefully. If the process isn't interactive, it usually terminates. In a way, gentler than SIGTERM.

SIGKILL, or signal number 9, on the other hand, is harsher than SIGTERM. It causes the process to terminate immediately. This should only be used as a last resort, as the process isn't given the opportunity to clean up after itself. It may leave the system in an inconsistent state, resulting in more problems. However, if a program is already malfunctioning, SIGTERM may not work.

To send another signal, for example, SIGKILL, using the pkill command, we can call pkill -KILL repeat or pkill -9 repeat. The syntax for sending other signals is similar to the kill and killall commands.

Other notable signals include SIGSTOP (signal number 19), which causes the process to stop and wait to be resumed with SIGCONT or continue signal number 18. And SIGHUP (for hang up, signal number 1) is used by the system to end processes when the user logs out or closes a terminal, but for some programs, this can be used to restart the process without changing its PID.

Zombie Processes 04:23-05:05
A defunct, or zombie process is one that has terminated but hasn't been properly removed by its parent. A zombie process won't respond to signals, including SIGKILL, and is almost always the result of a bug. For example, using our non-standard zombie_demo program, we can create a parent and zombie child process.

It may be possible to make a parent process remove its zombie children by sending it SIGCHLD. This causes the parent to re-process the signal that its child has terminated, which in some cases might correct the previous failure. Unfortunately, that didn't work in this case. If SIGCHLD fails, the only other way to remove a zombie process is to terminate its parent.

Summary 05:05-05:22
That's it for this demonstration. In this lesson, we went over how to terminate processes on Linux using the kill, killall, and pkill commands, as well as a brief overview of signals used by the system to control processes.

## 10.2.9 Process Termination Facts

### `Ctrl+c`

This lesson covers the following topics:

- Terminate a running process
- Keep running a process after logging out

### Terminate a Running Process

The following commands can be used to terminate a running process.

<table>
<thead>
<tr>
  <th>Command</th>
  <th>Function</th>
  <th>Example</th>
</tr>
</thead>
<tbody>
<tr>
  <td><b>kill</b></td>
  <td>
    <p>
      Terminates a process using a process ID (PID) number and a
      specific kill signal. Kill signals can be sent using a term or a
      numeric value. Options include the following:
    </p>
    <ul>
      <li>
        <b>-SIGHUP</b> , <b>-1</b> tells the process to shut down and
        restart. When it restarts, the process will have the same PID it
        had when the kill signal was sent. SIGHUP is sometimes
        implemented by programs to behave like SIGTERM.
      </li>
      <li>
        <b>-SIGINT</b> , <b>-2</b> stops a process as if the Ctrl+c key
        combination had been used. This option is recommended as the
        first choice when a process will not stop with its exit function
        or init script.
      </li>
      <li>
        <b>-SIGKILL</b> , <b>-9</b> forces a process to stop when it is
        unresponsive to other options for exiting or killing it. Running
        this option does not give the process a chance to clean up any
        resources that it is using, such as memory. Resources allocated
        to the process usually remain allocated to it until it is
        restarted. This option should only be used as a last resort.
      </li>
      <li>
        <b>-SIGTERM</b> , <b>-15</b> stops the process cleanly by giving
        it a chance to release the resources allocated to it. This is
        the default signal used by the kill command if no signal is
        specified. This option can be tried if the <b>-2</b> option
        fails to kill the process.
      </li>
      <li>
        <b>-l</b> lists all of the signals that are available for the
        <b>kill</b> command.
      </li>
    </ul>
  </td>
  <td>
    <b>kill -1 6754</b> shuts down and restarts the process.
    <b><br /><br />kill -9 6754</b>
    forces the unresponsive process to stop running.
    <br />
    <br />
    <b>kill -SIGKILL 6754</b> (which has the same effect as using
    <b>-9</b> ) forces the unresponsive process to stop running.
    <br />
    <br />
    <b>kill 6754</b> stops the process with PID 6754 using the default
    <b>SIGTERM</b> signal.
  </td>
</tr>
<tr>
  <td><b>killall</b></td>
  <td>
    Terminates processes the same way as the <b>kill</b> command, using
    their command name instead of their PID. This command uses the same
    signal commands that <b>kill</b> uses.
  </td>
  <td>
    <b>killall atd</b> kills all processes named atd
    <i >.<br /><br/></i>
    <b>killall -9 atd</b> uses a hard kill to stop the atd process.
  </td>
</tr>
<tr>
  <td><b>pkill</b></td>
  <td>
    Searches for processes that match the search criteria specified and
    then sends them a kill signal.
  </td>
  <td>
    <b>pkill -SIGTERM -f top</b> searches through all of the running
    processes for those with "top" somewhere in their name and sends
    them the SIGTERM signal.
  </td>
</tr>
</tbody>
</table>

### Keep Running a Process After Logging Out

In addition to killing a running process, you may encounter situations where a process must be kept running even after the user has logged out of the system. Normally, when a user logs out of the terminal session, Linux sends a SIGHUP signal to all the programs associated with that shell session. In response, each process will respond as it is programmed to when it receives a SIGHUP signal. However, a process can be told to ignore SIGHUP signals, which will allow it to remain running even if the user logs out of the shell session where it was started.

<table>
<thead>
  <tr>
    <th>Command</th>
    <th>Function</th>
    <th>Example</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td><b>nohup</b> <b>&amp;</b></td>
    <td>
      Allows a command or shell script to continue running in the
      background after logging out from a shell.
      <div>
        <div>
          <div>
            <div class="to-icon large" aria-hidden="true" style="width: 20px">
              <svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div>                    
            <div class="to-info-box-body-content">
              <span>
                <b>nohup</b> does not automatically put the command it
                runs in the background; use the ampersand (&amp;) symbol
                to start a process in the background.</span>
            </div>
          </div>
        </div>
      </div>
    </td>
    <td>
      <b>nohup gedit &amp;</b> starts the gedit process in the background
      and leaves it running after logging out of the shell.
    </td>
  </tr>
  <tr>
    <td><b>screen</b></td>
    <td>
      Uses multiple shell windows from within a single SSH session. Using
      <b>screen</b> , you can:
      <ul>
        <li>
          Keep processes running while you access the shell prompt through
          an SSH connection to enter additional commands.
        </li>
        <li>
          Keep an SSH shell active even if the network connection is
          closed or goes down.
        </li>
        <li>
          Disconnect and reconnect to a shell session from multiple
          locations without having to stop and then restart whatever
          processes were running.
        </li>
      </ul>
      <h2>screen</h2>
      <ul>
        <li>
          Pressing <b>Ctrl+a ?</b> causes the screen help to be displayed.
        </li>
        <li>
          Pressing <b>Ctrl+a c</b> causes a new screen window to be
          created. The old window remains active along with any processes
          that were running within it.
        </li>
        <li>
          Pressing <b>Ctrl+a n</b> toggles between open windows in the
          screen.
        </li>
        <li>
          Pressing <b>Ctrl+a d</b> detaches the screen window and returns
          the user to the original shell prompt. Whatever was running in
          the window remains running. In fact, the user can completely log
          out, and everything will keep running within the detached
          window.
        </li>
        <li>
          Entering <b>screen -r</b> reattaches a detached screen window.
          If multiple detached screen windows exit, the user will be
          prompted to specify which one to reattach to.
        </li>
      </ul>
    </td>
    <td><br /></td>
  </tr>
</tbody>
</table>
