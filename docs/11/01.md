---
lang: zh-CN
title: Section 11.1 System Logging
description: some description
---

As you study this section, answer the following questions:

<ul><li>What is the role of the journald daemon?</li>
<li>What is the function of the <b class="fw-bold">logrotate</b> utility?</li>
<li>Which commands can you use to view text-based log files?</li>
<li>Which command shows all failed login attempts on the system?</li></ul>

In this section, you will learn to:

- Configure journald
- View log files

This section helps you prepare for the following certification exam objectives:

<table class="objectives">
<thead>
<tr>
  <th>Exam</th>
  <th>Objective</th>
</tr>
</thead>
<tbody>
<tr>
  <td>TestOut Linux Pro</td>
  <td>
    4.3 Monitor and manage system access
    <ul>
      <li>Monitor logging</li>
    </ul>
  </td>
</tr>
<tr>
  <td>CompTIA Linux+ XK0-005</td>
  <td>
    <p>
      2.1 Summarize the purpose and use of security best practices in a
      Linux environment
    </p>
    <ul>
      <li>
        Linux hardening
        <ul>
          <li>System logging configurations</li>
        </ul>
      </li>
    </ul>
    <p>
      4.5 Given a scenario, use systemd to diagnose and resolve common
      problems with a Linux system.
    </p>
    <ul>
      <li>
        Common problems
        <ul>
          <li>Journal issues</li>
        </ul>
      </li>
    </ul>
  </td>
</tr>
</tbody>
</table>

## 11.1.1 Linux Log Files

Click one of the buttons to take you to that part of the video.

Linux Log Files 00:00-00:19
Let's spend some time learning about Linux system log files.

Log files are a gold mine of information for system administrators. For example, you can use them to detect intruders trying to break into your system. You can also use them to troubleshoot system issues.

Log File Storage Location 00:19-00:41
System log files are stored in the /var/log directory. There are many files and sub-directories within /var/log that store different system daemons' log files. Some of them are plain text files you can read with any text manipulation utility, like cat or less. Others are binary files that need a special utility designed specifically to read them.

Common Log Files 00:41-02:27
Some of the log files stored in /var/log are very useful, and some aren't. Here's a few of the most important files. The first two are basically the same, boot.log and boot.msg. Some Linux distributions use boot.log, and others use boot.msg. Both contain log entries created as the system boots up. Depending on the distribution you're using, either file can be a valuable troubleshooting tool for startup problems.

There's also the cron log file, which contains messages created by the cron daemon. Next is the dmesg log file, which contains hardware detection information. The faillog file contains failed authentication attempts, which is very useful if you're trying to detect intruders.

Next, we have firewalld, which contains log messages created by the system firewall. There's lastlog, containing information about the last time each user logged into the system. Depending on your distribution, you'll see either mail or maillog. Both contain entries generated by the mail daemon, the MTA, on your system.

There's also the messages file. This is used only on older Linux distributions that run the init daemon. It's the main log file on these distributions; it's where a lot of useful logging information is stored. It's a simple text file accessible with any text manipulation utility. Newer distributions use the systemd daemon instead of init, and it stores the main log messages in the journal instead of in the messages file. Next is secure, containing information about access to network daemons.

There's the rpmpkgs log file containing a list of installed RPM packages. Next is the warn file, which contains warning messages. There's also wtmp, which contains a list of users who have authenticated to the system.

View the System Log Files 02:27-03:19
With this in mind, let's discuss viewing and using your log files to troubleshoot problems. If the kernel or some daemon running on the system encounters a problem, it's probably going to be logged to a log file. Reviewing your log files can provide a wealth of information that isn't displayed on the screen. The journal messages are a great place to start. If you have a systemd-based distribution, access the journal using the journalctl command.

If you need to troubleshoot a problem associated with one specific application or service, you might need to go beyond the journal and look at the log file maintained specifically for that problematic service. For example, you would look in the maillog file on a Fedora system to troubleshoot problems with the postfix daemon. Or, if you were having trouble with the mysqld daemon, you would look in the mysqld.log file located in /var/log/mysql.

Search System Log Files 03:19-04:27
Keep in mind that log files tend to become very long. It's difficult to find specific information just by browsing through them. There are two strategies to get around this problem. The first one is shown here: redirect the output of the command used to view the log file to the grep command, then filter out just one specific term within the log file.

In this example, we needed to locate information in the /var/log/boot.log related starting the OpenSSH daemon when the system boots up. To do this, we run cat /var/log/boot.log, and then we and pipe the output to grep and tell it to look for the text OpenSSH. When we do, only the lines containing the term OpenSSH are displayed in the output of the command.

If your system uses systemd in the journal, you can do the same thing when searching through the system log file with the journalctl command. Just run journalctl -e and pipe the output to the grep command, then tell it what you're looking for. The -e option is important because it tells journal control not to pause the output page by page.

Monitor Log Files 04:27-05:49
You can also use the head and tail utilities to view log file entries. Most log files record entries chronologically, starting from oldest to newest. If you want to view the beginning of the log file, run the head command followed by the name of the log file at the shell prompt, and it will display the first few lines of the file.

This may not be helpful because the first lines in a log file are the oldest. Tail, on the other hand, is useful because it displays the last lines in the file. When you're troubleshooting, you usually only need the last few lines of the log file.

One way to do this is run tail followed by the name of the log file you want to view, and the last few lines of the log file will be displayed. There's an option that increases the tail's utility, which is the -f option you see here.

When you use it, tail will initially display the last lines of the log file specified as usual, but it doesn't exit. It continually monitors the log file and displays each new line as it's added to the log file.

In this example, I used the tail command to view the /var/log/firewalld log file and added the -f parameter. tail will continuously monitor the firewalld log file. As I troubleshoot problems, new messages are added to the file and displayed on the screen.

This is good because the results are instantly displayed without requiring you to run tail repeatedly. Once you're done monitoring the file, break out by pressing Ctrl+C.

Monitor the System Journal 05:49-06:23
If your system is based on the systemd daemon and uses the journald daemon to manage logging, you can do the same thing with the journalctl command while you're viewing the system log.

Run journalctl with the -f parameter. This runs as if we were viewing the journal with the tail command, which we can't do because the journal is a binary file that can only be viewed with a journalctl command. First, it'll display the last few entries in the journal. Then it sits and monitors the journal and adds each new entry to the output as it's added to the journal file.

Summary 06:23-06:41
That's it for this lesson. In this video, we reviewed some of the log files used on the Linux system. First, we reviewed the names of log files and where they're saved. Then we talked about using these log files to troubleshoot system problems.

## 11.1.2 Log File Facts

Log files can provide a system administrator with a wealth of information about how a Linux system is working.

This lesson covers the following topics:

- Common log files
- Centralized logging

### Common Log Files

The following table describes the contents of commonly used log files.

<table>
<thead>
  <tr>
    <th>File/Directory</th>
    <th>Contents</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>
      <b>/var/log/boot.log<br />/var/log/boot.msg</b>
    </td>
    <td>
      The system writes messages generated during the boot process to
      either the boot.log or boot.msg file depending on the distribution.
    </td>
  </tr>
  <tr>
    <td>
      <b>/var/log/faillog<br />/var/log/btmp</b>
    </td>
    <td>
      Login failures for user accounts are listed in either the faillog or
      btmp file, depending on the distribution.
    </td>
  </tr>
  <tr>
    <td>
      <b>/var/log/firewall<br />/var/log/firewalld</b>
    </td>
    <td>
      Depending on the distribution, the system stores log entries for the
      host firewall.
    </td>
  </tr>
  <tr>
    <td><b>/var/log/lastlog</b></td>
    <td>
      The lastlog file holds information about the last time each user
      logged in.
    </td>
  </tr>
  <tr>
    <td><b>/var/log/maillog</b></td>
    <td>
      The maillog file contains reports on mail server status and messages
      related to incoming and outgoing mail.
    </td>
  </tr>
  <tr>
    <td><b>/var/log/messages</b></td>
    <td>
      The messages file is the default file for storing system messages.
      This file may include copies of messages that appear on the console,
      internal kernel messages, and messages sent by networking programs.
      <div>
        <div>
          <div>
            <div class="to-icon large" aria-hidden="true" style="width: 20px">
              <svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div>                    
            <div class="to-info-box-body-content">
              <span>
                The messages file is based on the init daemon, used on
                older Linux distributions.</span>
            </div>
          </div>
        </div>
      </div>
    </td>
  </tr>
  <tr>
    <td><b>/var/log/warn</b></td>
    <td>
      The warn file displays warning messages from many processes by
      default.
    </td>
  </tr>
  <tr>
    <td><b>/var/log/wtmp</b></td>
    <td>
      The wtmp file keeps track of all users who have logged into and out
      of the system, as well as listing every connection and runlevel
      change.
    </td>
  </tr>
  <tr>
    <td><b>/var/log/dmesg</b></td>
    <td>
      The dmesg file is often called the kernel ring buffer. It reports
      messages received in the process of configuring hardware devices as
      the system boots.
    </td>
  </tr>
  <tr>
    <td><b>/var/log/secure</b></td>
    <td>
      The secure file logs any attempts to log in as the root user or
      attempts to use the <b>su</b> command. This file also contains
      information on remote logins and failed root user login attempts.
    </td>
  </tr>
  <tr>
    <td><b>/var/log/sa</b></td>
    <td>
      The / <b>var/log/sa</b> directory stores
      <b>/sa <i class="fs-italicize">[n]</i></b> files, which contain all
      performance information for the day of the month indicated by
      <b><i class="fs-italicize">[n]</i></b> . For example,
      <b>/var/log/sa/sa15</b> contains performance information for the
      fifteenth day of the month, and it will be overwritten on the
      fifteenth day of the next month.
    </td>
  </tr>
  <tr>
    <td><b>/var/log/cron</b></td>
    <td>
      The cron file stores messages related to tasks scheduled with cron.
      It keeps track of which tasks are run and when they were started.
    </td>
  </tr>
  <tr>
    <td><b>/var/log/rpmpkgs</b></td>
    <td>
      On Red Hat systems, the rpmpkgs file tracks installed packages. It
      also records all kernel packages on the system.
    </td>
  </tr>
  <tr>
    <td>
      <b>/tmp/install.log<br />/root/install.log</b>
    </td>
    <td>
      The install.log may or may not be present, depending on the
      distribution. This file records messages related to the installation
      and can be useful for installation records for a computer.
    </td>
  </tr>
  <tr>
    <td><b>/etc/rsyslog.conf</b></td>
    <td>
      The rsyslog.conf file is the main configuration file for the
      rsyslogd, which logs system messages on Linux systems. This file
      specifies rules for logging. For every log message received, rsyslog
      looks at its configuration file /etc/rsyslog.conf to determine how
      to handle that message. If no rule statement matches the message,
      Rsyslog discards it.
    </td>
  </tr>
  <tr>
    <td><b>/var/log/kern.log</b></td>
    <td>
      The var/log/kern.log file provides a detailed log of messages from
      the Linux kernel. These messages may prove useful for
      trouble-shooting a new or custom-built kernel.
    </td>
  </tr>
  <tr>
    <td>
      <b>/var/log/ <i class="fs-italicize">[application]</i></b>
    </td>
    <td>
      Many applications also create logs in the /var/log directory. If you
      list the contents of your /var/log subdirectory, you will see
      familiar names such as /var/log/apache2 representing the logs for
      the Apache 2 web server, or /var/log/samba, which contains the logs for the Samba server.
    </td>
  </tr>
</tbody>
</table>

### Centralized Logging

Since looking at individual log files can be cumbersome, especially if you have multiple servers or tiers in your architecture, a good practice is to centralize your logs in one place. With centralized logging, you are able to search through your logs more quickly, which can help you solve issues faster. To take advantage of centralized logs, several third-party agents or daemons can be installed and used.

The following table list a few daemons used for centralizing logs:

<table>
  <thead>
    <tr>
      <th>Daemon</th>
      <th>Description</th>
    </tr>
  </thead>
<tbody>
<tr>
<td>rsyslog</td>
<td>
A lightweight daemon installed on most common Linux distributions.
It offers fast, high-performance, great security features and a
modular design. It is able to accept inputs from a wide variety of
sources, transform them, and output the result to diverse
destinations. This is the most popular daemon.
</td>
</tr>
<tr>
<td>syslog-ng</td>
<td>
syslog-ng collects logs from any source, processes them in
real-time, and delivers them to a wide variety of destinations.
syslog-ng also allows you to flexibly collect, parse, classify,
rewrite and correlate logs from across your infrastructure and store
or route them to log analysis tools.
</td>
</tr>
<tr>
<td>Fluentd</td>
<td>
Lets you unify the data collection and consumption for better use
and understanding of data. Fluentd tries to structure data as JSON
as much as possible and has a flexible plug-in system that allows
the community to extend its functionality.
</td>
</tr>
<tr>
<td>logstash</td>
<td>
A heavy-weight agent capable of performing more advanced processing and parsing. It is capable of obtaining data from a multitude of sources simultaneously, and after processing, it can then send it to your favorite “stash.”
</td>
</tr>
</tbody>
</table>

## 11.1.3 journald Logging

Click one of the buttons to take you to that part of the video.

journald Logging 00:00-00:27
In this lesson, we're going to discuss system logging on Linux.

Before we begin, please be aware that older init-based Linux distributions use the syslog daemon to manage system logging. However, newer Linux distributions are based on systemd and usually don't use syslog anymore. Instead, they use the journald daemon to manage logging.

We're going to focus just on journald logging in this lesson.

View the Journal 00:27-00:52
The journald daemon maintains a system log called the journal, located in the path that you see here: /var/log/journal.

You can't view the journal using a standard text manipulation utility like cat or less. Instead, you must run the journalctl command. If you enter the journalctl command at the shell prompt with no parameters, then the entire journal is displayed one page at a time.

View Boot Messages 00:52-01:37
One of the neat features of journald is the ability to view system messages that were generated as the system booted up.

To do this, run journalctl -b, then the log messages from the most recent system boot will be displayed. You can also use journalctl to view messages from previous system boots as well.

By specifying journalctl -b 4, we see messages that were created at the fourth boot from the beginning of the journal. But you can also start from the most recent log messages by specifying a negative number. If we specify journalctl -b -2, like we've done here, then we look up the messages from the specified system boot starting at the end of the journal; we see the system messages that were created two boots ago.

View Service-Specific Messages 01:37-02:17
You can also use the journalctl command to display only the log entries that are related to a specific service running on the system.

To do this, you enter journalctl -u and then the name of the daemon whose related journal entries you want to view. In this case, we want to view all the journal entries that are related to the sshd daemon running on the system.

Here you can see information, such as which port the daemon listing is on. We can see the last connection that was closed by the sshd daemon. We can see the last time that someone logged in and accepted a password for the rtracy user, telling us where that user connected from to the sshd daemon, and so on.

Configure the Journal Daemon 02:17-04:10
The behavior of the journal daemon is configured using the /etc/systemd/journald.conf file. Now, this file has many different parameters that you can configure. Some of the more useful ones are listed here.

First, we have MaxFileSec. This specifies the maximum amount of time to store entries in the journal before starting a new file. Basically, it's the way we manage log rotation with the journal. We also have MaxRetentionSec, which specifies the amount of time to store journal entries. Any entries older than the specified time are automatically deleted from the journal file.

We also have ForwardToSyslog. If your system has both the journald and the syslog daemons running, then you can forward your journald messages to the traditional syslog daemon. I never do that, but I guess if you wanted to, you could.

In addition, you can configure MaxLevelStore. This controls the maximum log level of messages stored within the journal file. The way this works is all messages equal to or less than the specified log level will be stored. Any messages above the specified level will not be stored, and will be dropped instead.

So, you can set this parameter to one of the values shown here: emerg, which is level zero, and means only emergency messages would be stored. Alert stores both alert and emergency messages. Crit stores critical, alert, and emergency. Err stores errors, critical, alert, and emergencies.

Following the pattern, warning stores warnings, errors, all the way up the line to emergencies. Notice stores notices and everything else above it. Info stores almost everything. Debug stores absolutely everything, but you don't want to use this option unless you're troubleshooting a system problem. As soon as you're done troubleshooting a problem, switch back to one of these other levels, up here.

Summary 04:10-04:29
That's it for this lesson. In this lesson, we discussed how you can view the system journal on a distribution that uses systemd, using the journalctl command. We also discussed how you can configure the journald daemon using the journald.conf file.

## 11.1.4 Configure journald

Click one of the buttons to take you to that part of the video.

Configure journald 00:00-00:12
We're going to look at logging using journald. Newer Linux distributions that use systemd will use the journald daemon for logging.

Find journald Logs in the File System 00:12-00:26
journald maintains a system log file called the journal located in /var/log/journal. Within this, we see a subdirectory containing the actual journal file. The journal isn't a straight text file. You must use a special command to view it.

Use the journalctl Command to View Journal 00:26-00:59
The command to view the journal is journalctl. If you enter the journalctl command with no parameters, the entire journal is displayed. It starts with the earliest entries and starts working its way through. This can be a large number of entries. We press q to exit.

Using the journalctl command alone isn't very useful since it displays the oldest entries first. If the system has been running for a while, this can take quite a while to accomplish. Looking at the man page for journalctl, we can see two useful options with journalctl: the -r and -f options.

Use -r Option 00:59-01:13
Looking at the -r option, we see that it reverses the outputs, so the newest entries are displayed first. This makes journalctl more useful. We scroll through the page by pressing the space bar. When we're ready to exit, we press q.

Use -f Option 01:13-01:47
We also have the -f option. This'll pull up the most recent entries in the journal and display them onscreen without exiting out. And as new entries are added to the journal, meaning as things happen on the system and are logged, those new entries are added to the bottom of the output. This can be an invaluable troubleshooting tool.

Let's run the command journalctl -f to begin a running list of log entries. We'll open a new terminal window to create new entries that'll appear while our journalctl -f command is running.

First, switch to the root user account. New entries will be added to the journal.

Restart a Service 01:47-02:11
Let's restart the MySQL database service with systemctl restart mysql.

As we're notified that the service is stopped and restarted, entries will be continuously added to the journal.

If a system is having issues, you can open a terminal window with journalctl -f running and then troubleshoot in a second terminal window. You'll be able to view the log messages as they're added to the journal.

Use -b Option 02:11-03:03
Boot messages can be viewed with journald. This is useful in troubleshooting boot issues.

To view boot log messages, you enter journalctl -b. The boot messages from the most recent system boot are displayed.

The journalctl command can also be used to view messages from previous system boots. This is done by specifying a number with the -b option. For example, if we wanted to display messages created during the first boot found at the very beginning of the journal, then enter 1.

The first boot events recorded in the journal are displayed. Enter q to quit. Instead of searching from the beginning of the journal, we can also start at the end of the journal and work our way backward.

Specifying -b and then a negative number, such as -2, will look up the messages from the specified system boot starting from the end of the journal. We see the system messages that were created two boots ago.

Use -u Option 03:03-03:29
The journalctl command can also be used to display only the log entries in the journal that are related to a specific service running on the system. The syntax is to enter journalctl -u followed by the name of the service.

We can use journalctl to view just those messages related to the mysql daemon by entering journalctl -u mysql. We see just those entries related to the mysql database running on this system.

Configure the journald Daemon 03:29-04:53
The behavior of journald is configured using a configuration file in /etc/systemd. We can run an ls command to see the journald.comp file. You'd edit this file to customize the way that journald works.

We're going to open the journald.comp file with vi. There are many different parameters that can be configured in this file. One useful parameter is, MaxFileSec. This specifies the maximum amount of time to store entries in the journal file before you rotate and start a new journal file.

Another useful parameter is MaxRetentionSec. This specifies the amount of time to store journal entries. Any entries older than the specified time will be automatically deleted from the journal file.

MaxLevelStore is also useful. This controls the maximum number of log messages stored in the journal file. All messages that are equal to or less than the log file type specified will be stored. Any messages created above the specified log level will be dropped. By default, this is set to debug, which will retain logs useful in debugging issues. All log messages will be stored. Debug is the highest level; it goes down through info, notice, warning, error, crit, alert, and emerge. If we're looking to reduce the number of log messages stored, we could set this to a value of error. All warning, notice, and info messages wouldn't be stored.

Summary 04:53-05:11
In this demo, we talked about working with journald. We looked at where the journal is stored in the file system. We then practiced using the journalctl command to view the journal and ended this demonstration with how to configure journald.

## 11.1.5 journald Logging Facts

This lesson covers the following topics:

- Journald configuration
- Commands to view the journal

### Journald Configuration

Linux distributions based on the systemd daemon use the journald daemon for logging.

<div>
<div class="to-icon large" aria-hidden="true" style="width: 20px">
<svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div>        
<div class="to-info-box-body-content">
<span>
  Distributions based on SysVinit (init) use the syslogd daemon to
  manage logging.</span>
</div>
</div>

### `/var/log/journal/`

<table>
<thead>
<tr>
  <th>Parameter</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td><b>MaxFileSec</b></td>
  <td>
    Specifies the maximum amount of time to store entries in the journal file before starting a new file.
  </td>
</tr>
<tr>
  <td><b>MaxRetentionSec</b></td>
  <td>
    Specifies the maximum amount of time to store journal entries. Any entries older than the specified time are automatically deleted from
    the journal file.
  </td>
</tr>
<tr>
  <td><b>MaxLevelStore</b></td>
  <td>
    Specifies the maximum log level of messages stored in the journal file. All messages equal to or less than the log level specified are
    stored. Any messages above the specified level are dropped. This parameter can be set to:
    <ul>
      <li><b>emerg</b> (0)</li>
      <li><b>alert</b> (1)</li>
      <li><b>crit</b> (2)</li>
      <li><b>err</b> (3)</li>
      <li><b>warning</b> (4)</li>
      <li><b>notice</b> (5)</li>
      <li><b>info</b> (6)</li>
      <li><b>debug</b> (7)</li>
    </ul>
  </td>
</tr>
<tr>
  <td><b>ForwardToSyslog</b></td>
  <td>
    Configures journald to forward log messages to the traditional syslogd daemon.
  </td>
</tr>
</tbody>
</table>

### Commands to View the Journal

You can view the journal with the following commands:

<table>
<thead>
<tr>
  <th>Command</th>
  <th>Function</th>
  <th>Example</th>
</tr>
</thead>
<tbody>
<tr>
  <td><b>journalctl</b></td>
  <td>
    Views the entire journal. The output begins at the beginning of the journal and pauses one page at a time. To exit out of journalctl,
    press <b>q</b> .
  </td>
  <td>
    <b>journalctl</b> <br />
    Displays the journal, starting with the oldest entries.
  </td>
</tr>
<tr>
  <td><b>journalctl -b</b></td>
  <td>
    Views system boot messages. The messages from the most recent system boot are displayed by default. To display messages from a specific boot, use the following options with this command:
    <ul>
      <li>
        Specify a positive number to display messages from the specified system boot, starting from the beginning of the journal.
      </li>
      <li>
        Specify a negative number to display messages from the specified system boot starting from the end of the journal.
      </li>
    </ul>
  </td>
  <td>
    <b>journalctl -b 2</b> <br />
    Displays messages created during the second boot event from the
    beginning of the journal.
    <h2>journalctl -b -2</h2>
  </td>
</tr>
<tr>
  <td><b>journalctl -u</b></td>
  <td>
    Displays only log entries related to a specific service running on the system.
  </td>
  <td>
    <b>journalctl -u ntpd</b> <br />
    Displays only journal messages relating to the ntpd daemon.
  </td>
</tr>
<tr>
  <td><b>journalctl -f</b></td>
  <td>
    Displays the last few entries in the journal. The journalctl command then monitors the journal and prints new entries as they are added.
  </td>
  <td>
    <b>journalctl -f</b> <br />
    Displays the last few entries in the journal and then prints new entries as they are added.
  </td>
</tr>
</tbody>
</table>

## 11.1.6 Viewing Log Files

Click one of the buttons to take you to that part of the video.

View Log Files 00:00-00:26
In this demonstration, we're going to discuss viewing Linux log files.

Some Linux log files are text files and can be viewed with any tech utility like cat, less, more, head, tail, and so on. But others are binary files that can be viewed only with the appropriate utility. We're going to look at both of those in this lesson.

The /var/log Directory 00:26-00:42
Almost all of your Linux log files are stored in the same place—the /var/log directory. If I do an ls command, you can see many different log files and subdirectories containing log files within /var/log.

The dmesg Command 00:42-01:40
One way to view Linux logging is with the dmesg command. This logging specifically refers to kernel-only logging. So, if there was an issue with the kernel, it'd be logged in here for later reference. One common thing we do with the dmesg command is to redirect the output to a file. There may be situations where if you've paid for support for your Linux distribution, and you're engaged with a tech support representative trying to solve a problem, they may ask to see the contents of dmesg.

We type dmesg and then redirect the output to a file. I'm going to put it in my user's /home directory, and let's call it kernel_out.log. If I do a less command of the kernel_out.log file in my user's /home directory, we can see there's a log file there now. I can take that data and send it off to tech support, and they can analyze it to see what's going on with my system.

The lastlog File 01:40-02:12
Lastlog is a command you can run to check the last login time for a user. When I run the lastlog command, the contents of the lastlog are displayed. I do want to point out one thing here. Even though we're logged in with the GUI, our last login date isn't displayed. This is because not every login method is logged to lastlog. If I were to log in with the TestOut user via ssh, it'd update the "Never logged in" to the last date and time.

Let's clear our screen.

journald 02:12-03:05
Systemd distributions use journald for logging. The main log file is located here in the journal directory. The journal is a binary log file. For example, you can't view it with cat, less, tail, or head.

Instead, you must use the journalctl command. When I run journalctl, the journal contents are displayed on the screen. This is the log file generated when Linux boots for all our systemd services. So, if there were a problem, you could look through this log and figure out what errors would be displayed. If we exit this log, another option is to type journalctl -f, which will show the current logs being written to the journal. It's a live view, so it'll keep scrolling until you exit. However, we'll leave this open and then open a new terminal window along the side.

The logger Command 03:05-04:35
Let's take a look at the logger command. The logger command is used to manually add entries to the system log. With either syslogd or journald, it doesn't matter. It works with both. It's usually just used for testing purposes to ensure your logging configuration is working properly. For our purposes, we're going to use it to simulate some error event occurring on the system, and we're going to see that error event pop up over here in the journal.

I'm going to enter logger, and then the message that I want to save to the system log in the journal. I'm going to send a test error message to the journal. Hit Enter and notice that the message I created with logger is immediately displayed over here in the journal. This is a great way to troubleshoot problems on your system, such as a system service that isn't starting properly.

You run journalctl -f in one window, start the service in the other window, and then you can see the log messages generated as that service starts over here. You can often find really good information for troubleshooting as you do so.

We're going to break out of here and go back to /var/log. Notice there's a directory over here that contains log messages for our cups printing daemon. Not all logs are generated in the journal; they can have their own log location such as this. Documentation of the software or daemon could tell you where the default log location is.

messages 04:35-05:15
Just to show you that logging can differ between different distributions of Linux, we're going to move over to a Redhat system to show you why. We're in the same area as before, which is /var/log. The pwd command will show you your current working directory. Unlike Ubuntu, Redhat uses a common logging area called /var/log/messages. In this area, the general system output is logged to this file. This log is plain text, so we can read it or even tail it to see live messages. If you were using this distribution, you'd be familiar with this log and the other locations we've discussed.

Summary 05:15-05:26
That's it for this demonstration. In this demo, we talked about various methods for viewing Linux logs.

## 11.1.7 Log File Display Facts

As a system administrator, you will encounter both binary and text-based log files. You should be familiar with working with both types of files.

This lesson covers the following topics:

- View and manage text-based log files
- View and manage binary log files

### View and Manage Text-Based Log Files

The following table describes commands to view and manage text-based log files:

<table>
<thead>
<tr>
  <th>Command</th>
  <th>Use To</th>
  <th>Function</th>
</tr>
</thead>
<tbody>
<tr>
  <td><b>cat</b></td>
  <td>Views the contents of a log file.</td>
  <td>
    <b>cat /var/log/messages</b> shows the entire text of the messages log.
  </td>
</tr>
<tr>
  <td><b>grep</b></td>
  <td>Filters text from a text file.</td>
  <td>
    <b>cat /var/log/messages | grep ftp</b> filters the output of the cat command to show only lines that contain the term
    <i>ftp</i> .
  </td>
</tr>
<tr>
  <td><b>tail</b></td>
  <td>
    Shows the last ten lines of a file. Be aware of the following options:
    <ul>
      <li><b>-f</b> displays additions to the log in real-time.</li>
      <li>
        <b>-n</b> <i>#</i> specifies the number of
        lines to display.
      </li>
    </ul>
  </td>
  <td>
    <b>tail /var/log/messages</b> shows the last ten lines of the messages log. <br />
    <b>tail -f /var/log/messages</b> displays the real-time entries of the messages log as they are updated.
  </td>
</tr>
<tr>
  <td><b>head</b></td>
  <td>Shows the first ten lines of a file.</td>
  <td>
    <b>head /var/log/messages</b> shows the first ten lines of the messages log.
  </td>
</tr>
<tr>
  <td>
    <b>less<br />more</b>
  </td>
  <td>Scrolls through individual pages of a file.</td>
  <td>
    <b>less /var/log/messages</b> allows you to scroll through each page of the file.
  </td>
</tr>
<tr>
  <td>
    <b>vi<br />gedit</b>
  </td>
  <td>Opens text files for editing.</td>
  <td>
    <b>vi /var/log/messages</b> opens the messages log for editing.
  </td>
</tr>
</tbody>
</table>

### View and Manage Binary Log Files

The following table lists several commands used to view and manage binary log files:

<table>
<thead>
<tr>
  <th>Command</th>
  <th>Function</th>
</tr>
</thead>
<tbody>
<tr>
  <td><b>dmesg</b></td>
  <td>
    Views the boot logs and troubleshoots hardware errors. The
    <b>dmesg</b> command shows information about all the hardware
    controlled by the kernel and displays error messages as they occur.
  </td>
</tr>
<tr>
  <td><b>dmesg -n</b> <i>#</i></td>
  <td>
    Controls which error messages are sent to the console. For example,
    <b>dmesg -n 1</b> sends only the most critical errors (0 and 1) to the console. Other messages are still logged in the log files.
  </td>
</tr>
<tr>
  <td><b>last</b></td>
  <td>
    Shows all users who have logged in to and out of the system, as well as listing every connection and runlevel change (for example, the contents of the <b>/var/log/wtmp</b> file).
  </td>
</tr>
<tr>
  <td>
    <b>faillog<br />lastb</b>
  </td>
  <td>
    Shows all failed login attempts on the system (for example, the
    contents of the <b>/var/log/btmp</b> file or
    <b>/var/log/faillog</b> file, depending on the distribution).
  </td>
</tr>
<tr>
  <td><b>lastlog</b></td>
  <td>
    Shows a list of the dates and times for the last login for each
    user.
  </td>
</tr>
<tr>
  <td><b>logger</b></td>
  <td>
    Changes the message severity and where logged messages are sent.
  </td>
</tr>
<tr>
  <td><b>logrotate</b></td>
  <td>
    Manages, compresses, renames, and deletes log files based on
    specific criteria (such as size or date).
  </td>
</tr>
<tr>
  <td><b>sar</b></td>
  <td>
    Views system statistics. <b>sar</b> is short for System Activity
    Report. It comes as part of the <b>sysstat</b> (System Statistics)
    package. When used alone, it returns CPU statistics. Common options
    include the following:
    <ul>
      <li><b>-A</b> displays all information.</li>
      <li><b>-b</b> displays I/O statistics.</li>
      <li><b>-B</b> displays swap statistics.</li>
      <li>
        <b>-f /var/log/sa <i>filename</i></b> displays information from the specified file.
      </li>
    </ul>
  </td>
</tr>
</tbody>
</table>

## 11.1.8 logrotate

Click one of the buttons to take you to that part of the video.

logrotate 00:00-00:46
Log files become large, very large. On a system that's used every day, they become huge in just a few months.

In this video, we're going to manage log files using the logrotate utility.

The logroate utility is included with most Linux distributions by default.

This utility helps you manage your log files by automatically rotating, compressing, removing, and mailing them.

In other words, logrotate looks at the log files and says, "This log file is getting really big. We need to back it up start a new file. And all these backup log files from last year should probably be deleted, since we don't need them anymore."

Because managing logs is such an important task, you should configure the cron daemon to run logrotate automatically every day.

logrotate Configuration 00:46-01:10
You can customize the way logrotate handles files using the /etc/logrotate.conf file.

This file contains global parameters that the logrotate program uses to determine how and when to rotate files.

But you can override the global settings for a specific log file by creating your own custom logrotate configuration file in the /etc/logrotate.d directory.

logrotate Syntax 01:10-01:55
To create a configuration file for the logrotate.d directory, all you need to do is create a text file named after the service the log will monitor.

For example, to customize how logrotate handles the log files for the Apache web server running on our system, we can create a file in the logrotate.d directory named apache2.

The first thing we need to do is specify the name of the log file we want to manage. For example, we could specify the path '/var/log/apache2' and then the name of the log file we want to rotate, access_log.

On this same line, we need to add an open curly bracket ({),to indicate that we're ready to list directives, which determine how the file is managed. And then, after we have added all of our directives, we close the list using the opposite curly bracket.

logrotate Directives - compress 01:55-02:23
So, what are the directives you can use with logrotate?

The first directive is compress, which compresses the access_log file.

Next, we have maxage.

This directive specifies that files over a certain age are removed from the system.

For example, if we wanted to delete versions of this log file that are more than a year old, we would add 365. Now, if a backup version of the log file is over 365 days old, logrotate will delete the file.

Use the dateext Directive 02:23-02:38
The next directive we can use is dateext.

This directive causes old versions of our log file to be saved with the saved date as an extension. This way, when you look at the old versions of the file, it's very easy to tell what date range that log file came from.

Use the rotate Directive 02:38-03:33
The next directive is rotate.

This directive specifies that when a new log file is created where one already exists, the original file is rotated.

This means that the original file's name is changed to indicate it's older than the first, and the new log file is given the original name.

For example, since we're working with the access_log file, when it's rotated, the access_log will become access_log.1, and the new file will become access_log. This process continues as often as needed.

The rotate directive specifies how many new or rotated files are created before the oldest file is deleted.

In other words, since I've specified rotate 40, our access_log file will be rotated 40 times. And then, when the next log file is created, the fortieth file will be deleted, and the other files will rotate down, so we still have a maximin of 40 files.

This way, we maintain a minimal set of backup rotated logs on the system.

Use the size Directive 03:33-04:03
We also have a directive named size.

This directive is used to determine how large a log file can become before it's rotated.

To indicate the size, we add an equals sign (=), a plus sign (+), and then the maximum size of our file. In our example, that's 1024. And we'll add the letter k, for kilobytes, to indicate a metric. 1024 kilobytes equals one megabyte.

With this directive set to these parameters, as soon as our log file gets to be one megabyte in size, it's going to be rotated.

Use the notifempty Directive 04:03-04:22
Another directive we can use is notifempty.

This directive tells the system not to rotate the log file if it's empty.

For example, if a service just hasn't written anything to the log file because nothing's been going on, we're not going to worry about rotating the file. This protects you from having a whole bunch of rotated files that are all empty.

Use the missingok Directive 04:22-04:30
Our next directive is missingok.

This command tells the syslog daemon that it's okay not to write an error message if the log file is missing.

Use the create Directive 04:30-05:22
There's also a directive called create, which creates a new empty log file after rotation with the specified permissions, owner, and group.

For example, if we want the file owner to have read write permissions to the file, our first number will be 6. If we want the group owning the file to have just read access, our next number will be 4. And then, by adding the last 4, we indicate that all other authenticated users on our system will also have read only rights.

As another example, if we only want the owner to have rights, we'll use the number of 600. When you're granting permissions, you must always specify three numbers: one for the owner, one for the group, and one for all other users.

Next, we need to specify who will own this file. More than likely, you're just going to want to use root.

Last, we'll specify who the owning group will be. In our example, we're going to use the root group again.

Use the postrotate Directive 05:22-05:59
The last directive we're going to talk about here is postrotate.

postrotate is used to tell the logrotate service what to do after it's rotated the logs for this particular service.

For example, in Apache2, we may need to reload the service itself after the logs are rotated.

To do that, we would put 'postrotate', space, and then the name of the init or systemd script that we're going to use to restart Apache2, '/etc/init.d/apache2', followed by 'reload'.

This command causes the Apache2 service to reload its configuration file and apply any new changes without actually shutting down and restarting the Apache2 service itself.

Summary 05:59-06:26
That's it for this lesson.

## 11.1.9 logrotate Facts

This lesson covers the following topics:

<ul><li>How logrotate works</li>
<li>Commands used with logrotate</li></ul>

### How logrotate Works

Linux distributions include the logrotate utility to automatically manage, compress, rename, and delete log files based on specific criteria, such as size or date. On most distributions, logrotate:

<ul><li>Automatically runs each week as a cron job to periodically maintain
system logs. Old logs are renamed with a numbered extension, and logs
are deleted after four weeks.</li>
<li>Uses /etc/logrotate.conf as the main configuration file. It contains
entries that apply to the whole system.</li>
<li>Uses scripts in /etc/logrotate.d to overwrite the settings in
/etc/logrotate.conf.</li></ul>

### Commands Used with logrotate

#### `/etc/logrotate.conf`

<table>
<thead>
<tr>
  <th>Command</th>
  <th>Function</th>
  <th>Examples</th>
</tr>
</thead>
<tbody>
<tr>
  <td><b>compress</b></td>
  <td>Compresses old log files using <b>gzip</b> .</td>
  <td><br /></td>
</tr>
<tr>
  <td><b>maxage</b></td>
  <td>
    Removes rotated logs that are older than the specified number of
    days.
  </td>
  <td>
    <b>maxage 180</b> deletes every rotated log older than 180 days.
  </td>
</tr>
<tr>
  <td><b>dateext</b></td>
  <td>
    Uses a daily extension on archived files using
    <b>file.YYYYMMDD</b> format.
  </td>
  <td>
    Uses a daily extension on archived files using a
    <i class="fs-italicize">file.YYYYMMDD</i> format.
  </td>
</tr>
<tr>
  <td><b>rotate</b></td>
  <td>
    Specifies the number of times to rotate the log before deleting it.
  </td>
  <td>
    <b>rotate 5</b> rotates the log file five times and then removes it.
  </td>
</tr>
<tr>
  <td><b>size</b></td>
  <td>
    Rotates or removes log files based on file size as follows:
    <ul>
      <li><b>size k</b> specifies the size in kilobytes.</li>
      <li><b>size</b> <b>M</b> specifies the size in megabytes.</li>
      <li><b>size</b> <b>G</b> specifies the size in gigabytes.</li>
    </ul>
  </td>
  <td>
    <b>size 100M</b> deletes or rotates files larger than 100 megabytes.
  </td>
</tr>
<tr>
  <td><b>notifempty</b></td>
  <td>Prohibits empty logs from being rotated.</td>
  <td><br /></td>
</tr>
<tr>
  <td><b>missingok</b></td>
  <td>Prevents errors from being displayed for missing log files.</td>
  <td><br /></td>
</tr>
<tr>
  <td><b>create</b></td>
  <td>
    Creates a log file with a name identical to the one just rotated.
    The command specifies the mode (permissions) of the file as well as
    the owner and group for the file.
  </td>
  <td>
    <b>create 744 root root</b> creates a file with read, write, and
    execute permissions for the owner and read permission for the group
    and everyone, specifies root as the file owner, and specifies root
    as the group.
  </td>
</tr>
<tr>
  <td><b>postrotate</b></td>
  <td>
    Indicates the start of script commands to be executed after log
    files are rotated. The term endscript must be used to indicate the
    end of the script.
  </td>
  <td><br /></td>
</tr>
</tbody>
</table>
