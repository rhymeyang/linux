---
lang: zh-CN
title: Section 15.9 Public Key Authentication
description: some description
---

As you study this section, answer the following questions:

<ul>
<li>
  What is an MD5 checksum? How is it used in public key authentication?
</li>
<li>
  Which file configures the server to accept public key authentication?
</li>
<li>
  Which keys are generated by the
  <b class="fw-bold">ssh-keygen</b> command when you use the
  <b class="fw-bold">-t rsa</b> option?
</li>
<li>
  Which utility should you use to copy encryption keys between Linux
  systems?
</li>
<li>When is the <b class="fw-bold">~/authorized_keys</b> file used?</li>
<li>
  How can you configure a client to automatically provide the private key
  passphrase when establishing an SSH session?
</li>
</ul>

In this section, you will learn to:

- Configure public key authentication

Key terms for this section include the following:

<table class="terms">
<thead>
  <tr>
    <th>Term</th>
    <th>Definition</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>Public key</td>
    <td>
      Keys that are distributed to all hosts with whom the entity wants to
      communicate securely.
    </td>
  </tr>
  <tr>
    <td>Private Key</td>
    <td>Keys that are kept secret and known only to their owners.</td>
  </tr>
  <tr>
    <td>Public key authentication</td>
    <td>
      Authentication that employs a message to be encrypted and decrypted
      with different keys.
    </td>
  </tr>
  <tr>
    <td>Digital signature</td>
    <td>
      Uses an asymmetric key pair to allow a sender's identity to be
      verified by the recipient.
    </td>
  </tr>
  <tr>
    <td>Message digest</td>
    <td>
      A hash value used to help verify the integrity of sent messages.
    </td>
  </tr>
</tbody>
</table>

This section helps you prepare for the following certification exam objectives:

<table class="objectives">
<thead>
  <tr>
    <th>Exam</th>
    <th>Objective</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>TestOut Linux Pro</td>
    <td>
      4.3 Monitor and manage system access
      <ul>
        <li>Manage remote connections</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>CompTIA Linux+ XK0-005</td>
    <td>
      1.5 Given a scenario, use the appropriate networking tools or
      configuration files
      <br />
      <ul>
        <li>Remote networking tools</li>
        <ul>
          <li>Secure Shell (SSH)</li>
          <li>Secure Copy Protocol (SCP)</li>
        </ul>
      </ul>
      <p>1.7 Given a scenario, manage software configurations</p>
      <ul>
        <li>Configure common system services</li>
      </ul>
      <p>
        2.1 Summarize the purpose and use of security best practices in a
        Linux environment
      </p>
      <ul>
        <li>Managing public key infrastructure (PKI) certificates</li>
        <ul>
          <li>Public key</li>
          <li>Private key</li>
          <li>Self-signed certificate</li>
          <li>Digital signature</li>
          <li>Wildcard certificate</li>
          <li>Hashing</li>
        </ul>
      </ul>
      <p>
        2.4 Given a scenario, configure and execute remote connectivity
        for system management
      </p>
      <ul>
        <li>SSH</li>
        <ul>
          <li>Configuration files</li>
          <ul>
            <li>/etc/ssh/sshd_config</li>
            <li>/etc/ssh/ssh_config</li>
            <li>~/ssh/authorized_keys</li>
          </ul>
          <li>Commands</li>
          <ul>
            <li>ssh-keygen</li>
            <li>ssh-copy-id</li>
            <li>ssh-add</li>
          </ul>
        </ul>
      </ul>
      <p>
        3.1 Given a scenario, create simple shell scripts to automate
        common tasks
      </p>
      <ul>
        <li>
          Shell script elements
          <ul>
            <li>&gt;&gt;</li>
          </ul>
        </li>
      </ul>
    </td>
  </tr>
</tbody>
</table>

## 15.9.1 Public Key Authentication

Click one of the buttons to take you to that part of the video.

Public Key Authentication 00:00-00:23
When using SSH, an alternative to authenticating with a username and password is to authenticate using either an RSA or DSA public key. In this lesson, we'll take a look at how public key authentication works for authentication, then we'll go over how to generate and copy our keys, and we'll wrap up with testing logging in with our public key.

SSH Authentication with Public Keys 00:23-02:05
Before we can log in to SSH using our public key, we have to first pre-provision the server with the public key of the user. To do this, we need to manually add the public key from the user on the client system to the authorized_keys file located in the .ssh hidden directory of the user's home directory on the server system that we'll be authenticating as.

For example, we usually log in to this client computer using the ccole account. We need to do some work on the server and want to remote into it and authenticate as the ksmith user. The first step is to generate a public and private key pair for the ccole user. We'll then transfer the public key we just created over to the authorized_keys file located in the .ssh hidden directory inside the home directory of the ksmith user because that's whom we want to authenticate as. Keep in mind that only the public key is transferred over, and the private key must remain on the client computer.

With our keys copied over, we can configure the server to use SSH to authenticate our users. The client computer tells the server which public key to use for authentication. The server checks to make sure it has that key, and if it does, a random number is generated and encrypted using the public key. The encrypted number is sent back to the client, which uses the private key to decrypt the number. The client system then runs MD5 checksum on the number and sends that checksum value to the server. The server also runs an MD5 checksum on the number and then compares the two MD5 checksums. If they match, the key pair is valid, and the user is authenticated.

The first step in this process is to create that public/private key pair. Let's take a look at this process.

Generating the Key Pair 02:05-03:44
To generate our key pair, we want to use the ssh-keygen command on the client computer. When using this command, you can choose to create either a RSA or DSA key pair by using the appropriate switch. The private key will be saved in the .ssh hidden directory in your home directory. It will be named either id_rsa or id_dsa while your public key will be in the same directory but will have an extension of .pub. During the key generation process, you'll be asked to create a passphrase for that key. You want to make sure you do this because if someone gets ahold of your keys, they won't be able to use them without knowing the passphrase. It's also important for you to remember the passphrase of course.

Once our key pairs have been created, we need to copy the public key to the server. The simplest and most secure method is to use the secure copy command. In this example, we're going to copy our RSA key on the client computer to the ksmith account on the server and name it keyfile.

After copying the key to the server, we need to append it to the end of the authorized_keys file in the user's /home/.ssh hidden subdirectory. The easiest way to do this is to connect to the server using a standard SSH connection with the username and password of the user in question and then enter the command cat keyfile >> followed by the path and name of the authorized key file. Make sure you use two greater than signs, as this appends the key to the end of the file. Otherwise, you'll overwrite the entire file and wipe out any existing keys.

Once we've got our key copied over and configured, we want to test everything to ensure we can authenticate using SSH.

Authentication 03:44-04:49
To test our configuration, we simply want to try to establish a new SSH session. If everything is working correctly, you should be prompted to supply the key file's passphrase instead of the standard username and password. Once you enter the passphrase, you should be authenticated on the SSH server. Then if everything matches up between the public key on the server and the public key on the client, then no password or username will be required to establish the SSH session.

If you want to, you can use the ssh-agent command to eliminate the need to enter that passphrase every time you establish an SSH connection with the remote server. The first thing you need to do is run ssh-agent bash on the client system at the shell prompt, and then run ssh-add, followed by the private key that's the companion of the public key you sent over to the SSH server. You'll then be prompted to specify the key file's passphrase. When you do that, the SSH agent will store it in memory, and then it will listen for SSH requests, and when one is created, it will automatically provide the specified passphrase.

Summary 04:49-05:14
That'll wrap up this lesson on public key authentication. In this lesson, we first went over the process of SSH authentication using public keys. We then looked at how to generate our key pairs and copy them to the server. We wrapped up with how to test that the authentication works and add the passphrase, so we're not prompted for it every time we connect to the SSH server.

## 15.9.2 Configure Public Key Authentication

Click one of the buttons to take you to that part of the video.

Configure Public Key Authentication 00:00-00:16
We are going to explore how to configure public key authentication between two systems—one running the SSHD daemon and the other running the SSH client. This will allow us to securely authenticate with the SSH client.

Configure SSHD Daemon 00:16-01:40
We first need to configure the SSH daemon on the destination host to allow public key authentication. To edit configurations for the SSH daemon on this system, I will switch to my root user account. Enabling public key authentication is done in the sshd_config file. To make changes, we will run nano /etc/ssh/sshd_config.

When using nano, an easy way to find the line that will allow you to enable public key authentication, is to press F6, and in the search field, type pubkeya, and press Enter. This takes us to the PubkeyAuthentication line.

The hash character at the beginning of the line identifies this configuration as disabled by default. To enable PubkeyAuthentication, delete the hash character. For public key authentication to work, we also need to enable the AuthorizedKeysFile, so remove that hash character as well. With that done, exit nano and save changes, using the default file name.

Before we can begin using public key authentication on this host, we need to restart the SSH daemon running on the system. To do that, run systemctl restart sshd. With public key authentication enabled on my host, the next step is to switch to the system where the SSH client will be run, and configure the public key authentication there.

Generate a Key Pair 01:40-02:39
Now let's switch to the client machine. I am logged in as Zoey.

First, we need to generate an RSA key pair. Type ssh-keygen. Running the command without any options will, by default, generate an RSA key. Press Enter, and the system begins generating an RSA key pair. And it prompts me to specify where we're going to save the private key in the key pair. By default, it will be saved in my user's .ssh hidden directory using the filename of id_rsa. Press Enter.

Next, enter the passphrase that will be used for this key. It's important to not forget the passphrase. You will need to use it each time you connect using this method. Enter the desired passphrase, and when prompted, enter the passphrase again to verify it.

We are told that the private key has been saved in id_rsa and the public key, the one we share to systems we are connecting to, is in id_rsa.pub.

Copy Public Key to /home Directory 02:39-03:52
To use public key authentication, we need to copy the public key file from this system over to the first system where the SSHD daemon is running. It is important to remember the file needs to be copied in a secure way, such as putting it on a USB drive and walking it over, or using some other secure method, such as the scp command. You do not want to attach the key file to an email and send it through the internet, since email is typically insecure.

I'll use the scp command. Enter scp and then specify that we want to copy the file from our .ssh hidden directory in Zoey's home directory named id_rsa.pub. To copy this to the home directory of the jsmith user, I'll enter jsmith@172.27.239.8: — this is the IP address for the host where we enabled public key authentication earlier.

When I press Enter, I'm prompted to accept the fingerprint key, because this is the first time I've made a connection to this host. Type yes, and press Enter. We now need to provide the password for the jsmith user account. We see that the file has been copied.

Copy Public Key to authorized_keys File 03:52-05:39
Next, we need to copy the file from the jsmith directory to the .ssh/authorized_keys file on the jsmith system. This could be done from the jsmith host, but we can also use SSH from here. Let's open a new SSH session by running ssh jsmith@172.27.239.8. Press Enter, type the password, and we're in. All actions at this point are as if we were working physically on jsmith's host. This is a remote connection to the host. We see the username and hostname have changed.

When we run ls -a, we see the id_rsa.pub file we copied earlier. It is important to verify that the .ssh hidden directory is there. If the directory is missing, you would need to create it. We need to add this public key file from Zoey's system to the authorized_keys file of the jsmith user. We will use the cat command to send its output to the required file. Let's enter cat id_rsa.pub. But now, instead of just displaying the key on the screen, we'll enter two greater than signs (>>) to export the results to the .ssh/authorized_keys file. Using two greater than signs is important because it allows us to add the new key to the end of the file. When we press Enter, the key is added.

To verify, let's run cat again on the .ssh/authorized_keys file. We see the key was added. Notice the key is associated with the Zoey account on the Kali system. With that verified, run exit, which will disconnect from the jsmith Ubuntu system. And now we are working as Zoey on her Kali system.

Test Public Key Authentication 05:39-06:03
We are ready to test the new configuration. Use the up key to bring up the previous command we used to connect using SSH, and press Enter. Instead of being prompted to provide the password for the jsmith user, I'm being prompted to enter the passphrase to unlock the private key. Once entered, select Unlock, and we are connected as jsmith.

Let's close this session by typing exit.

Create Passphrase Shortcut for SSH Client 06:03-06:41
An advantage of using public key authentication, is to configure the system to remember the passphrase for connections. Run ssh-agent bash. Then run ssh-add .ssh/id_rsa. I'm asked to enter the passphrase for the private key. This is the same passphrase we configured when we initially generated the key pair. When I press Enter, the identity has been added. When I establish an SSH connection as jsmith@172.27.239.8, I'm connected without being prompted for the passphrase.

Summary 06:41-07:03
In this demonstration we explored how to configure public key authentication for the SSH server and client. We generated a key pair, copied the public key to the remote server, added the public key to the authorized_key file for the user, and authenticated to the system without providing a password.

## 15.9.3 Public Key Authentication Facts

This lesson covers the following topics:

- Authenticate using a public key
- Enable public key authentication
- Creating self-signed certificates

### Authenticate Using a Public Key

Public key authentication uses a public key instead of a username and password to authenticate an SSH connection.

The following method is used to authenticate using a public key:

<ol>
<li>
  The client specifies which public key the server uses for
  authentication. Then, the server checks to ensure the key has previously
  been authenticated to the server.
</li>
<li>
  If the key is known to the server, it encrypts a random number with the
  public key and sends the encrypted number to the client.
</li>
<li>
  The client decrypts the number with a private key, and uses its own
  public key and the random number to create a hash (MD5 checksum). The
  client sends the hash back to the server.
</li>
<li>
  The server uses the public key and the random number to create its own
  hash (MD5 checksum) and then checks whether both hash values match.
</li>
<li>
  If the hashes match, the server grants access to the user. If the hashes
  do not match, the user is prompted to log in using a password.
</li>
</ol>

A digital signature uses an asymmetric key pair to allow a sender's identity to be verified by a recipient. The sender creates the digital signature with a private key. The recipient decrypts the signature with the corresponding public key to verify the signature. The digital signature provides non-repudiation, meaning that the sender can not repudiate being the sender of the message. Digital signatures do not provide message integrity.

Public keys can also verify the integrity of messages sent. To ensure message integrity, the sender of a message creates a hash value for the message being transmitted. This hash value is called a message digest. The sender sends both the message digest and the message to the recipient. The recipient creates a hash for the message. If the recipient's hash matches the message digest, the integrity of the message is verified.

### Enable Public Key Authentication

Use the following commands and files to enable public key authentication:

<table>
<thead>
  <tr>
    <th>Command</th>
    <th>Function</th>
    <th>Example</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>
      <b>/etc/ssh/sshd_config
        <br />
        etc/ssh/sshd.config</b>
    </td>
    <td>
      Configures the server to accept public key authentication. Commonly
      used options for configuring a public key authentication on the
      server include:
      <ul>
        <li>
          <b>PubkeyAuthentication</b> enables and disables public key
          authentication on the server.
        </li>
        <li>
          <b>AuthorizedKeysFile <i class="fs-italicize">location</i></b>
          specifies the location of the file that contains the public
          keys.
        </li>
      </ul>
    </td>
    <td>
      <b>PubkeyAuthentication yes</b> enables public key authentication on
      the server.
      <b><br />
        AuthorizedKeysFile .ssh/authorized_keys</b>
      specifies the location of the file that contains the public keys.
    </td>
  </tr>
  <tr>
    <td><b>ssh-keygen</b></td>
    <td>
      Creates a key on the client to use when authenticating to a server.
      <b>ssh-keygen</b> options include:
      <ul>
        <li>
          <b>-t</b> <b>dsa</b> creates a DSA key pair (e.g., id_dsa and
          id_dsa.pub).
        </li>
        <li>
          <b>-t rsa</b> creates an RSA key pair (e.g., id_rsa and
          id_rsa.pub).
        </li>
      </ul>
    </td>
    <td>
      <b>ssh-keygen -t dsa</b> creates a DSA key pair.
      <b><br />
        ssh-keygen -t rsa</b>
      creates an RSA key pair.
    </td>
  </tr>
  <tr>
    <td><b>scp</b></td>
    <td>Securely copies the client's public key file to the server.</td>
    <td>
      <b>scp ~/.ssh/id_rsa.pub bjones@hs2.corpnet.com:/home/bjones</b> /
      copies id_rsa.pub to the home directory of bjones.
    </td>
  </tr>
  <tr>
    <td><b>ssh</b></td>
    <td>Logs in to the server.</td>
    <td>
      <b>ssh -l bjones hs1</b> logs in to the hs1 computer as bjones.
    </td>
  </tr>
  <tr>
    <td><b>cat</b></td>
    <td>
      Appends the public key to the <b>~/authorized_keys</b> file. Be
      aware of the following:
      <ul>
        <li>
          Overwriting the file deletes all other keys.
          <div>
            <div class="to-info-box">
              <div class="to-info-box-body">
                <div class="to-icon large" aria-hidden="true" style="width: 20px;"><svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div>
                <div class="to-info-box-body-content">
                  <span>
                    Be sure to use <b>&gt;&gt;</b> instead of
                    <b>&gt;</b> when redirecting the output of the
                    <b>cat</b> command.</span>
                </div>
              </div>
            </div>
          </div>
        </li>
        <li>
          If the same user logs in from multiple clients, the file must
          have all client keys in it.
        </li>
        <li>
          Always remove the public key file after appending it to the
          <b>~/authorized_keys</b> file.
        </li>
      </ul>
    </td>
    <td>
      <b>cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys</b> appends the
      id_rsa.pub file to the end of the authorized_keys file.
    </td>
  </tr>
  <tr>
    <td>
      <b>ssh-agent bash
        <br />ssh-add</b>
    </td>
    <td>
      Configures the client to automatically provide the private key
      passphrase when needed, so that it does not have to be typed for
      every new connection to a server.
      <ol>
        <li>Use <b>ssh-agent bash</b> to enable passphrase agent.</li>
        <li>
          Use <b>ssh-add</b> to specify the name of the private key to add
          to the agent. For protocol 2, this is one of the following:
          <ul>
            <li><b>~/.ssh/id_rsa</b></li>
            <li><b>~/.ssh/id_dsa</b></li>
          </ul>
        </li>
      </ol>
      After the <b>ssh-add</b> command, enter the passphrase when
      prompted. The passphrase stays in memory while the user is logged
      into the client.
    </td>
    <td>
      <b>ssh-agent bash</b> enables passphrase automation.
      <b><br />ssh-add ~/.ssh/id_rsa</b>
      specifies the id_rsa file as the private key.
    </td>
  </tr>
  <tr>
    <td><b>ssh-copy-id</b></td>
    <td>
      Copies the public key of your default identity to the remote host
      using <b>ssh-copy-id user@hostname.com</b> . If you have only one
      ssh key, you do not have to enter your identity.
    </td>
    <td>
      <b>ssh-copy-id</b> copies your default identity to the remote host.
      <br />
      <b>ssh-copy-id user@hostname.com</b> copies the public key of the
      specified user.
    </td>
  </tr>
</tbody>
</table>

### Creating Self-Signed Certificates

A self-signed certificate lets you encrypt communication between your server and a client, but is not signed by any trusted certificate authorities. Therefore, users cannot use the certificate to validate the identity of your server automatically. Self-signed certificates are often used when you don’t have a domain name associated with your server, where the encrypted web interface is not user-facing.

The exact steps to create a self-signed certificate will vary from distribution to distribution. The following is one example of how to create a self-signed certificate on Ubuntu. These steps may need to be modified for other distributions.

To create a self-signed certificate, open a terminal and as root or using sudo, run the following command:

```shell
openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout /etc/ssl/private/my-selfsigned.key -out /etc/ssl/certs/my-selfsigned.crt
```

<table>
<thead>
  <tr>
    <th>Commands / Options</th>
    <th>Description</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td><b>openssl</b></td>
    <td>
      The command used for creating and managing OpenSSL certificates.
    </td>
  </tr>
  <tr>
    <td><b>req</b></td>
    <td>
      Specifies that the X.509 certificate signing request (CSR) will be
      used. X.509 is a public key infrastructure standard that SSL and TLS
      adhere to for key and certificate management.
    </td>
  </tr>
  <tr>
    <td><b>-x509</b></td>
    <td>
      Specifies that the certificate being created will be self-signed,
      instead of a signed certificate.
    </td>
  </tr>
  <tr>
    <td><b>-nodes</b></td>
    <td>
      Specifies that OpenSSL should skip the option to secure our
      certificate with a passphrase. This allows a connection to the
      server (such as an Apache Web server) without user intervention.
    </td>
  </tr>
  <tr>
    <td>
      <b>-days <i>xxx</i></b>
    </td>
    <td>
      Specifies the length of time that the certificate will be considered
      valid, where <i>xxx</i> is the number of days.
    </td>
  </tr>
  <tr>
    <td><b>-newkey rsa:2048</b></td>
    <td>
      Specifies that the a new certificate and new key will be created at
      the same time. The <b>rsa:2048</b> portion says to make an RSA key
      that is 2048 bits long.
    </td>
  </tr>
  <tr>
    <td><b>-keyout</b></td>
    <td>
      Specifies the directory and filename for the private key being
      created.
    </td>
  </tr>
  <tr>
    <td><b>-out</b></td>
    <td>
      Specifies the directory and filename for the self-signed key being
      created.
    </td>
  </tr>
</tbody>
</table>

The following steps may also be required to use the self-signed certificate:

<ul>
<li>Configure the server to use SSL.</li>
<li>
  Adjust the firewall. If you are using the ufw firewall in the enabled
  mode, you might need to adjust the settings to allow for SSL traffic.
</li>
<li>
  Install the self-signed certificate in your server, such as the Apache
  Web server.
</li>
<li>Restart the server.</li>
<li>Test the website with https.</li>
</ul>

