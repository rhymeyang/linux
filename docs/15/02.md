---
lang: zh-CN
title: Section 15.2 User Security and Restriction
description: some description
---

As you study this section, answer the following questions:

<ul>
<li>What are the characteristics of a secure password?</li>
<li>
  Which <b class="fw-bold">chage</b> option sets the minimum number of
  days a user must keep a password?
</li>
<li>
  Which type of resources are affected by the
  <b class="fw-bold">ulimit</b> utility?
</li>
<li>
  When would you need to configure the /etc/security/limits.conf file?
</li>
<li>What is the syntax for the /etc/security/limits.conf file?</li>
<li>What does file auditing allow you to do?</li>
</ul>

In this section, you will learn to:

<ul>
<li>Configure user security and restrictions</li>
<li>Monitor user logins</li>
<li>Audit files</li>
</ul>

Key terms for this section include the following:

<table class="terms">
<thead>
  <tr>
    <th>Term</th>
    <th>Definition</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>
      Linux pluggable authentication module
      <br />
      (PAM)
    </td>
    <td>
      A module that provides dynamic authentication support for
      applications and services on a Linux system, such as login and su.
    </td>
  </tr>
  <tr>
    <td>
      Lightweight Directory Access Protocol
      <br />
      (LDAP)
    </td>
    <td>
      An open-source, vendor-neutral, industry-standard application
      protocol used to locate organizations, individuals, and other
      resources (such as files and devices) on the internet or on a
      corporate intranet.
    </td>
  </tr>
  <tr>
    <td>
      Teletypewriter
      <br />
      (TTY)
    </td>
    <td>
      A text-only virtual console. On Linux, a new text-only console can
      be accessed (logged in to) by pressing a combination of keys, such
      as <b>Ctrl</b> + <b>Alt</b> + <b>F2</b> for TTY2.
    </td>
  </tr>
</tbody>
</table>

This section helps you prepare for the following certification exam objectives:

<table class="objectives">
<thead>
  <tr>
    <th>Exam</th>
    <th>Objective</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>CompTIA Linux+ XK0-005</td>
    <td>
      <p>
        2.1 Summarize the purpose and use of security best practices in a
        Linux environment
      </p>
      <ul>
        <li>
          Authentication
          <ul>
            <li>Pluggable Authentication modules (PAM)</li>
            <li>System Security Services Daemon (SSSD)</li>
            <li>Lightweight Directory Access Protocol (LDAP)</li>
            <li>Single sign-on (SSO)</li>
          </ul>
        </li>
      </ul>
      <p>2.2 Given a scenario, implement identity management</p>
      <ul>
        <li>
          Account creation and deletion
          <ul>
            <li>
              Utilities
              <ul>
                <li>who</li>
              </ul>
            </li>
          </ul>
        </li>
        <li>Account management</li>
        <ul>
          <li>chage</li>
          <li>pam_tally2</li>
          <li>faillock</li>
        </ul>
      </ul>
      <p>2.5 Given a scenario, apply the appropriate access controls</p>
      <ul>
        <li>
          File permissions
          <ul>
            <li>Set user ID (SUID)</li>
          </ul>
        </li>
      </ul>
    </td>
  </tr>
</tbody>
</table>

## 15.2.1 User Security

Click one of the buttons to take you to that part of the video.

User Security 00:00-00:12
In this lesson, we're going to discuss several measures you can take to increase user security. Let's begin with the importance of strong passwords.

Weak Passwords 00:12-00:33
A weak password is one that can be easily guessed or cracked.

Here are some examples of very weak passwords: your last name, your spouse's name, your mother's maiden name, your child's name, your birthdate, your pet's name, the word "password", short passwords, and blank passwords. You would be surprised how often users choose these types of passwords.

Strong Passwords 00:33-01:24
We want to teach users best practices for password security so they can make better choices. A strong password should use at least 10 characters, and more I is because a cracking utility will take longer to crack it. A strong password also contains a combination of numbers and letters. It should contain both upper and lowercase letters. It should not contain words found in the dictionary. If you really want to make your password strong, include many non-alphanumeric characters in the password, such as punctuation marks.

Let's take a look at this password, right here. Do you think this is a strong password? Let's evaluate whether it meets the criteria. Is it longer than ten characters? Yes. Does it use a combination of numbers and letters? Yes.

Upper and lowercase letters? Yes. Does it contain words not found in the dictionary? I don't think you're going to find that word in the dictionary. This would be considered a strong password.

Strong Password Check 01:24-02:02
Be aware that the password management utilities that come with most Linux distributions have default configuration to evaluate your user passwords when you set them to make sure they meet the criteria for a strong password.

For example, here, I'm changing the password for the lmorgan user with the passwd command, and I used a really bad password. Here, I used the password "AAA". The system notified me, saying, "Hey, that's a really bad password. Don't use it." But it let me use it anyway. Even though these utilities notify you if you use a bad password, they'll still let you do it. That's why you must train your users to use good passwords.

Password Aging 02:02-02:52
Now, in addition to using strong passwords, you can also configure your user accounts so that the passwords expire after a certain period of time. This is called password aging. Some security experts no longer consider password aging a best practice; the subject is debated. The idea with password aging is that the longer a user has the same password, the more likely it is to be compromised. By forcing users to periodically rotate their password, you constantly keep intruders guessing. Even if they do manage to get a user's password at some point, it will be rendered useless sooner rather than later.

This practice makes that password invalid after a certain amount of time. Some of the more security-minded organizations mandate a maximum password age of 30 days. Less concerned organizations might go 45, 60, or even 90 days. Most organizations age passwords within 30 to 45 days.

Password Aging 02:52-03:48
In Linux, you configure password aging by using the chage command. The syntax is shown here. We enter chage followed by the option we want to set, an that's followed by the name of the user account that we want to apply that setting to. Some of the more commonly used options are shown here. -m specifies the minimum number of days that are allowed between password changes, while -M specifies the maximum number of days between password changes.

We need to do this because sometimes end users want to keep using their same old password. If we specify a maximum number of days before a user has to change their password, they'll go ahead and change it like they have to, and then they'll quickly change it back to their original password. By specifying a minimum number of days, we force that user to keep that same password for a long time before they're allowed to change it again.

You can also use the -W option to specify the number of warning days before a password change is required.

Password Protection 03:48-04:23
You should also train your users to use good common sense when they're working with passwords. One common security breach occurs when end users write their password and their username on a sticky note and stick it somewhere on their desk. End users may even attach the sticky note to the monitor or to the keyboard! Smarter users may actually try to hide the sticky note under the keyboard. Maybe they'll put it in a drawer or a cabinet. But it's still a significant security issue.

All the intruder has to do is watch the user log in and observe where they've hidden that sticky note with their password on it, and then they have everything they need to break into the system.

Social Engineering 04:23-05:07
With this in mind, we need to shift gears and talk about another security issue that you have to train your users to deal with, and that's the issue of social engineering. This is one of the easiest and most effective tools in a hacker's toolbox.

Social engineering bypasses technical attacks and exploits human weaknesses instead. Here's how a typical social engineering exploit might work. An intruder calls an employee posing as another employee. The attacker says, "Hey, I'm Larry. I work in sales, and I'm on the road. I'm at a client site. I have a very important file that I have to get off of the server, and I can't remember my password." And then Larry will demand that Fred disclose his password so Larry can log in, just this once, to get the file that he needs.

Social Engineering 05:07-05:51
Now, why does this exploit work? It's because most employees want to be team players, and they want to help out in an emergency. This makes them all too willing to hand out their password, granting the intruder access to the system.

Think about how easy this is compared to trying to crack a password and attack a system from outside the company. That takes a lot of time and work. This social engineering exploit takes a few seconds, and all it requires is a cell phone.

Now, some social engineering attempts are less direct. Instead of calling and asking for passwords, the intruder instead will sift through the company garbage, looking for those infamous little yellow sticky notes that have users' passwords and usernames written on them because their boss told them to get rid of them and throw them away. The attacker just has to collect them.

Social Engineering 05:51-06:17
Some social engineering attacks are more upfront than others. For example, the intruder might sift through the trash to find the name of a very high-ranking person in the company. Then our intruder calls our employee, Fred, again. Instead of posing as Larry from sales, the intruder poses as the high-ranking person and threatens to fire Fred if he doesn't share his password. Fred wants to keep his job, so he gives the attacker his password. Now the attacker has access to the system.

Phishing Emails 06:17-08:33
In addition to these exploits, you also need to be vigilent against the flood of phishing emails that have plagued organizations for the last several years. Phishing emails are very successful. In fact, they're responsible for many huge security breaches in the last several years.

A phishing email is drafted so that it appears to come from a legitimate organization. In this example, it looks like we have an email coming from amazon.com. The attacker wants the user to click a link right here. Now, this link looks legitimate, but it actually takes you to a malicious website that looks like amazon.com. This site is designed to trick users into revealing sensitive information, such as their Amazon username and password.

Phishing emails are a low-tech hack, but they're extremely popular because they're very successful. Only one or two employees in an organization have to be unwise enough to open this message and click on the link, and the hacker is in.

To defend against phishing, users need to be able to identify the key characteristics of a phishing email. At first glance, this email looks legitimate, but there are several key attributes that identify it as a scam. For example, it's common for the source address of the message not to match the domain of the company it claims to be coming from. At first glance, it may look like it's coming from amazon.com. The text is very easy to fake. You need to look at the message source and see where it was sent from. You're likely to find that it didn't come from amazon.com at all. You'll find that it came from a rogue email server somewhere else in the world.

In addition, the message will usually try to create a sense of urgency. This email says, "There's a revision to your amazon.com account. We're contacting you to remind you that the review team identified that your account has been limited. Your online access will be blocked if this issue is not resolved immediately." It tells us that if we don't do something about it, we're going to lose whatever privilege is provided by that organization. The idea is to make the target panicky.

Another key giveaway is the fact that if you hover your mouse over the link that they want you to click on, you'll see where that link actually leads, and you'll probably find that the URL within the link itself does not match the text of the link that's actually displayed in the message.

If that link is not pointing to that organization's URL, there's a pretty good chance that the message is an exploit.

Phishing Emails 08:33-09:02
To defend against these types of attacks, you can train your users not to write down their passwords or throw sensitive data in the trash. They should shred it instead. You also need to educate them about social engineering phone calls and how to deal with them.

Most organizations will simply tell their employees to forward calls requesting password information to their help desk. You should also teach your end users how to recognize the characteristics of a phishing email and how to properly respond. Just delete the email. Don't click on the link.

Summary 09:02-09:19
And that's everything for this video. In this lesson, we talked about several key security issues regarding users. We talked about using strong passwords and password aging. And then we discussed social engineering.

## 15.2.2 User Restrictions

Click one of the buttons to take you to that part of the video.

User Restrictions 00:00-00:22
Let's spend some time talking about user restrictions. You can greatly increase your Linux system's overall security by limiting user logins and resource access. Now, there are two general ways you can put these limits in place. You can use either pam_limits or the ulimit command. We're going to look at both of these in this lesson.

pam_limits in /etc/security/limits.conf 00:22-01:35
Let's start with the first option, pam_limits. It's what we call a pluggable authentication module, and we configure it in this file right here, /etc/security/limits.conf. This file has resource limits we can mold with the syntax that's shown here in the comment portion. We specify the domain, type, item, and value. The domain describes the entity that the limit applies to, and you can specify a particular user. Here's an example with an ftp user.

You can also specify a group name. Right here, we're specifying a group instead of a user, which makes the limit apply to all members of that group. Or you can also specify a star to indicate that this limit applies to everybody. Notice here that all these limits are examples in this file, and they're commented out, meaning that they're not actually applied. If you were to remove one of these pound signs, the limit would go into effect.

The next portion is the type. In the domain, we specified who the limit applies to. Under type, we define whether it's a hard or soft limit. A hard limit can't be exceeded at all. A soft limit is one that we do allow the user to exceed temporarily. The next column in each limit is the item. This specifies which resource is being limited.

Items that can be Restricted 01:35-02:33
There are actually several different things you can restrict with pam_limits. For example, you can specify core in the item field to restrict the size of core files. Specifying data restricts the size of the program's data area in RAM, effectively limiting how much RAM a user can consume. fsize restricts the sizes of files that users create.

nofile restricts the number of data files that a user can have open at the same time. stack restricts the CPU stack size, and the cpu item itself restricts the amount of CPU time that a single process can consume.

nproc restricts the number of concurrent processes a user can run at the same time. maxlogin sets the maximum number of simultaneous logins for a given user, and priority sets the priority to run user processes with. Also, the locks item sets the maximum number of locked files to allow. And then finally, we have nice, which sets the maximum nice priority a user is allowed to raise a process to.

Item Values 02:33-02:45
For each item, we have to specify a value, which is just a value for that limit. Down here, for example, we have @student—this specifies the student group. We're going to set a maxlogins value of 4.

pam_limits in /etc/security/limits.conf 02:45-03:29
Let's look at an example of how this works. Suppose that we wanted to configure the rtracy user with a soft CPU limit of 15 minutes. We'd open up our /etc/security/limits.conf file, and then we'd add this line right here. This would be a useful limit if that rtracy user were running some CPU-intensive program that was consuming cycles and cycles of memory.

Likewise, we could create another restriction down here for that same user that'd limit them to two maximum logins at the same time. For that one, we'll set a hard limit this time. Because we set the CPU limit as soft, they'd be allowed to temporarily exceed the value that we specified over here. But because this one is hard, they get two logins and two logins only.

ulimit Command 03:29-05:00
Okay, let's talk about the ulimit command now, which we access from the shell prompt. Here's a big difference—it doesn't matter if you're logged in using a GUI or whether you're working from the shell prompt, pam_limits applies across the board. ulimit, though, applies solely to commands launched from the command prompt.

The syntax is shown here. We type ulimit, followed by the options that specify the limit we want to set, and then a value for that limit. The different options you can use are listed here. The -c option sets a limit on the maximum size of core files, and this is done in blocks. If you set -c to a value of 0, it means that core dumps on the system are effectively disabled.

-f sets a limit on the maximum size of file blocks that are created by the shell. -n sets a limit on the maximum number of open file descriptors, so it effectively sets how many files a user can have open. -t sets a limit on the maximum amount of CPU time—in seconds—that a process can take. The -u option sets the maximum number of processes that are available to a particular user. -d sets the maximum size of a process data segment in RAM—that's in kilobytes, by the way. -m sets a limit on the maximum resident size of a RAM process, and it's also specified in kilobytes. -s sets a limit on the maximum stack size—again in kilobytes. And -H is used to set a hard resource limit, while -S sets it to be soft.

ulimit Options 05:00-05:16
There's also the -a option with the ulimit command. If you do that, it displays all the current resource limits that've been set up to that point. Here's an example of that. We have our core file size, data segment size, scheduling priority, file size, and so on.

ulimit Soft Limit 05:16-05:32
If we wanted to set a soft limit that'd limit the user to a maximum of 50 processes, we'd enter ulimit -S for the soft limit and -u for the maximum number of processes. Lastly, there's the value in this case, which is 50.

Summary 05:32-05:47
And that's all for now. In this lesson, we discussed how to set user restrictions. We looked at how we can use pam_limits to make this happen, and then we talked about doing so with the ulimit command as well.

## 15.2.3 Configure User Security and Restrictions

Click one of the buttons to take you to that part of the video.

Configure User Security and Restrictions 00:00-00:15
We're going to talk about configuring user restrictions. We'll look at this topic from three different aspects: password aging, setting login limits, and setting user limits.

Password Aging 00:15-02:09
In today's security environment, we need to ensure that passwords are configured to expire after a set period of time. This is called password aging. The longer a user has the same password, the more likely the password will be compromised.

To prevent this, we configure aging for user passwords. This is done with the chage command. Let's look at the chage man page. The syntax for using chage is to enter the chage command, followed by a series of options, then the user account to which you want the options applied.

We see the -m option, which specifies the minimum number of days that must pass before a user can change their password. We also have another -M option that specifies the maximum number of days that can pass before the user must change their password. The -W option lets you warn the user that their password is about to expire. The value used here specifies the number of days the user will be warned before the password expires.

Let's exit out of the man page.

As my root user, let's enter the chage command at the shell prompt. Then, to specify the maximum number of days a user can use their password, enter -M60. In about two months, the user's password will expire.

Next, let's specify -W7 to indicate that a warning will be given seven days before the password is about to expire. This'll give my user plenty of time to change the password before it expires.

I need to specify the user, jsmith. When I press Enter, the changes are made.

To verify this, let's look at the shadow file by running cat /etc/shadow.

When I look at the jsmith user account, the 60:7 listed here is the maximum number of days we specified in our command, along with the seven-day warning.

User Limits 02:09-04:06
Next to discuss is configuring user limits. On Linux, you can configure limits such as how many times a user may log in, how much CPU time they may use, how much memory they can use, and so on. This is done using the pam_limits PAM module. PAM stands for Pluggable Authentication Module.

We configure these limits by editing the /etc/security/limits.conf file. The syntax is shown here. Enter a domain, type, item, and value.

The domain can be a user, or it could be a group. If you want to use a group, you must put the @ sign in front of the group name. You could also use an asterisk as a wildcard to apply it to everybody.

Next, we specify the type, which can either be a soft limit that can be exceeded but just temporarily or a hard limit that can never be exceeded.

Then we specify the item. This is the resource or setting that'll be limited.

For example, we can limit data, which allows us to configure a maximum data size. We can specify fsize to restrict the maximum file size. And we have cpu, allowing us to set the amount of CPU time that can be used by a single process in minutes.

There are many different options. Running man limits.conf can help us learn more about all the options available.

Let's create a new limit. We need to enter the name of the user to which we want to apply the limit. I'll use jsmith again.

Next, we want to specify a hard limit, and the item we want to limit is our cpu time. This is the maximum amount of CPU time that a single process run by this user is allowed to consume. To specify how much time that is, I'll enter 10 minutes. Save the changes and exit.

In order for the new configurations to take place, we must reboot the system.

Use ulimit 04:06-05:47
Lastly is the ulimit command. Like the limits.conf file, the ulimit command can set limits on the same things. However, a big difference between making the change with ulimit is that its changes aren't persistent and are only applicable for applications run from within the shell.

If I were to launch a graphical application from the desktop, such as my Firefox Web Browser, then the limits specified in the shell with ulimit won't be applied to Firefox.

This command isn't available on all distributions. On others, the man pages tell you it's obsolete. You may run into systems where it's been implemented to launch programs from the shell using a script. The syntax for ulimit is to enter ulimit, followed by an option, then the limit you want to specify. These limits can be found on the ulimit man page.

Let's first run ulimit -a to view the current limits for my user account—and you see them displayed. We can also use ulimit to set a limit. For example, -f would be used to change the file size, while -t would be used to change the cpu time.

Let's run ulimit -S for a soft limit, and -u lets me set the maximum number of processes available to the user. Then we specify the value we want for this option. For this demo, I'll use 1000, meaning that my user account can only have a maximum of 1000 concurrent processes. When I press Enter, the limit is applied.

To see the change, let's run ulimit -a again, and we see that the max user processes have dropped from 7443 to 1000.

Summary 05:47-06:05
In this demonstration, we talked about how to set up user restrictions on Linux. We first looked at password aging. We then looked at login limits and ended this demonstration by looking at the ulimit command.

## 15.2.4 Monitor User Logins

Click one of the buttons to take you to that part of the video.

Monitor User Logins 00:00-00:21
We're going to discuss a few methods you can use to monitor user logins. Log files your Linux system maintains for you are invaluable in monitoring users.

Practice and experience will help develop an intuitive sense that lets you know when something looks suspicious in one of these files.

wtmp Log File 00:21-01:00
Let's look at some of the log files you can analyze to identify any suspicious activities. First, let's switch to root. Navigate to the /var/log directory and run ls.

There are several different log files in this directory that can be very useful. First, we'll look at the wtmp log file. This log file contains a list of all the users who have ever authenticated to the system. Be aware that this file's saved in binary format. We can't use cat, less, head, or tail to view its content. Nor can you use a text editor like vim or nano.

last Command 01:00-02:42
Instead, you use a command named last to view this file. Since this file can get very long, I'll add -20 so that it will only show us the last 20 logins. When we press Enter, a list of the last 20 logins is displayed. The logins are displayed from most recent to least recent.

The first column in this output is the name of the user who has logged in. The next column gives us information about how the user is—or was, connected. The third column shows where the user made the connection. For the second and third columns, you'll see such things as pts for pseudo terminal or just a number, as seen here, which means that a direct connection was made using a tty connection. The remaining columns display the login times and dates and their current login status.

Let's look at the login record for jsmith. We see that he connected using pts/1, or in other words, pseudo terminal 1. In the third column, we see that he logged in from a remote system with an IP address of 172.20.9.199. Next, we see the date and time he logged in. In the last two columns, we see he's still logged in.

The record just above shows that the user named admin logged out at 16:44 and that he was logged in for 10 minutes. When reviewing this file, look for anything that appears unusual. For example, a login that occurred at an odd hour of the day, such as 3:00 a.m. Is it a guarantee of an attack? Maybe not. It could be someone who's late on their deadline and is working late at night. But it could also be somebody trying to log in when no one is looking.

lastlog Command 02:42-03:29
Another file that can be used is the lastlog file. The contents of this file are shorter. This file contains just a list of all the users in the system and when they last logged in. Hence the filename of lastlog.

You can't view the lastlog file with cat, less, head, tail, or with a text editor. Type lastlog at the shell prompt and press Enter. A list of all the users on the system is displayed and when they last logged in.

Our jsmith user is listed here, and again we see how he was connected, from where the connection was made, and the date and time he logged in. We also see that all service accounts in your password file are also listed. Since they're system accounts, they can't be used to log in. They list as having never logged in.

who Command 03:29-03:54
There are a variety of command line tools that you can use to see who's currently using the system. The first one is the who command. This command lets you see who's currently logged into the system. Here, we see the jsmith user is currently logged in from a remote system, along with our zoey and admin users, who are logged in using a tty direct connection of 1 and 2.

finger Command 03:54-04:12
We can also use the finger utility to see who's currently logged into the system. This one's a little more user-friendly because it shows more information.

When we run finger, the login name followed by the user's full name is displayed. We can see their connection type, login time, and the source from where the connection was made.

fuser Command 04:12-05:05
The last command we'll look at is the fuser command. This command is useful to find a user that's either running a command on your system or who has a file open on your system.

We know that John Smith is currently logged on from a remote system. I can use the fuser command to see if he's running any applications. By running fuser -u /usr/bin/top, we see the top process is running, its process ID is 3159, and that the owner of this process is indeed, jsmith.

The little "e" listed at the end of the process ID tells me that the process being run is an executable. If I had used fuser and specified a word processing file instead of an executable, it would show an f here instead, meaning that the file's opened and being written to.

Summary 05:05-05:23
In this demonstration, we talked about monitoring user logins. We first looked at the last command. We then looked at the lastlog, who, and finger commands and finished by looking at the fuser command.

## 15.2.5 User Security Facts

Your job as a system administrator includes protecting computer systems and the information they contain from harm, theft, and unauthorized use. Your best security measure is to train users to be security-savvy. There are also commands and configuration files you can use to enhance security.

This lesson covers the following topics:

<ul><li>Security considerations</li>
<li>Commands to enhance security</li>
<li>Options for /etc/security/limits.conf</li>
<li>PAM overview</li>
<li>Locking accounts after failed login attempts</li>
<li>LDAP integration</li>
<li>tty security</li></ul>

### Security Considerations

When considering user security, keep the following in mind:

<ul>
<li>
  Users should be trained to use strong passwords. Strong passwords use a
  mixture of numbers and letters (both upper and lowercase) and are more
  than eight characters in length.
</li>
<li>Passwords should expire periodically.</li>
<li>Administrators can limit the resources users can access.</li>
</ul>

### Commands to Enhance Security

The following table describes commands used to promote user security and restrictions.

<table>
<thead>
  <tr>
    <th>Command</th>
    <th>Function</th>
    <th>Examples</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td><b>chage</b></td>
    <td>
      Sets user passwords to expire. Be aware of the following options:
      <ul>
        <li>
          <b>-M</b> sets the maximum number of days before the password
          expires.
        </li>
        <li>
          <b>-W</b> sets the number of days before the password expires
          that a warning message displays.
        </li>
        <li>
          <b>-m</b> sets the minimum number of days that must pass after a
          password has been changed before a user can change the password
          again.
        </li>
      </ul>
      <div>
        <div>
          <div>
            <div class="to-icon large" aria-hidden="true" style="width: 20px;"><svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div>
            <div class="to-info-box-body-content">
              <span>
                Look in the /etc/shadow file to view current limits for
                users.</span>
            </div>
          </div>
        </div>
      </div>
    </td>
    <td>
      <b>chage -M 60 -W 10 jsmith</b> sets the password for jsmith to
      expire after 60 days and gives a warning ten days before it expires.
    </td>
  </tr>
  <tr>
    <td><b>ulimit</b></td>
    <td>
      Limits computer resources used for applications launched from the
      shell. Limits can be hard or soft limits. Soft limits can be
      temporarily exceeded up to the hard limit setting. Users can modify
      soft limits, but only root can modify hard limits.
      <p>Options include the following:</p>
      <ul>
        <li>
          <b>-c</b> limits the size of a core dump file. The value is in
          blocks.
        </li>
        <li>
          <b>-f</b> limits the file size of files created using the shell
          session. The value is in blocks.
        </li>
        <li><b>-n</b> limits the maximum number of open files.</li>
        <li>
          <b>-t</b> limits the amount of CPU time a process can use. This
          is set in seconds.
        </li>
        <li>
          <b>-u</b> limits the number of concurrent processes a user can
          run.
        </li>
        <li>
          <b>-d</b> limits the maximum amount of memory a process can use.
          The value is in kilobytes.
        </li>
        <li><b>-H</b> sets a hard resource limit.</li>
        <li><b>-S</b> sets a soft resource limit.</li>
        <li>
          <b>-a</b> displays current limits. The default shows soft
          limits.
        </li>
      </ul>
    </td>
    <td>
      <b>ulimit -H -f 1024</b> uses a hard limit to limit the size of
      files to 1020 KB. <br />
      <b>ulimit -H -a</b> shows current hard limits. <br />
      <b>ulimit -a</b> shows the current soft limits. <br />
      <b>ulimit -S -u 10</b> sets a soft limit that limits the number of
      processes that a single user can use to ten. <br />
      <b>ulimit -t 600</b> limits CPU time for a process to ten minutes.
      This sets both hard and soft limits. <br />
      <b>ulimit -d unlimited</b> removes all restrictions for process
      memory usage.
    </td>
  </tr>
  <tr>
    <td><b>last</b></td>
    <td>
      Displays a list of all users logged in (and out) since the
      /var/log/wtmp file was created.
      <p>Options include the following:</p>
      <ul>
        <li>
          <b>-n <i class="fs-italicize">num</i></b> limits the number of
          lines that last outputs.
        </li>
        <li>
          <b>-f filename</b> reads from the file filename instead of the
          system's wtmp file.
        </li>
        <li>
          <b>-x</b> prints run level changes, shutdowns, and time changes
          in addition to the normal records.
        </li>
        <li><b>-a</b> displays the hostname in the last column.</li>
        <li><b>-i</b> prints the IP address instead of the hostname.</li>
        <li>
          <b>-w</b> instructs last to print out the fields in the wtmp
          file with full field widths.
        </li>
        <li><b>--debug</b> prints verbose internal information.</li>
        <li><b>-s</b> prints seconds when displaying dates.</li>
        <li><b>-y</b> prints years when displaying dates.</li>
        <li><b>-V</b> prints <b>last's</b> version number.</li>
      </ul>
    </td>
    <td>
      <b>last</b> shows all of the users logged in and out since the
      /var/log/wtmp file was created.
      <p><b>last -a</b> displays the hostname in the last column.</p>
    </td>
  </tr>
</tbody>
</table>

### Options for `/etc/security/limits.conf`

Use the `/etc/security/limits.conf` file to limit resource utilization by users. This file is from the pam_limits module of the Pluggable Authentication Modules (PAM) module set. Entries in `/etc/security/limits.conf` use the following syntax: **Domain Type Limit Value**

The following table describes the entry options in the `/etc/security/limits.conf` file:

<table>
<thead>
  <tr>
    <th>Domain</th>
    <th>Type</th>
    <th>Limit</th>
    <th>Value</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td valign="top">
      When specifying the Entity:
      <ul>
        <li>Specify a single user with a username.</li>
        <li>Use an ampersand (@) to specify a group.</li>
        <li>Use an asterisk (*) as a wildcard.</li>
      </ul>
    </td>
    <td valign="top">
      For the Type:
      <ul>
        <li>Use hard to set a limit that cannot be exceeded.</li>
        <li>Use soft to set a limit that can be exceeded temporarily.</li>
      </ul>
    </td>
    <td valign="top">
      Limits include:
      <ul>
        <li>
          <b class="fw-bold">core</b> limits the size of core dump files.
          The value uses kilobytes.
        </li>
        <li>
          <b class="fw-bold">data</b> limits the amount of RAM an
          application can use. The value uses kilobytes.
        </li>
        <li>
          <b class="fw-bold">fsize</b> limits maximum file size. The value
          uses kilobytes.
        </li>
        <li>
          <b class="fw-bold">nofile</b> limits the number of concurrently
          open data files.
        </li>
        <li>
          <b class="fw-bold">stack</b> limits the stack size (in KB).
        </li>
        <li>
          <b class="fw-bold">cpu</b> limits the amount of CPU time a
          process can use. The value uses minutes.
        </li>
        <li>
          <b class="fw-bold">nproc</b> limits the number of concurrent
          processes a user can have.
        </li>
        <li>
          <b class="fw-bold">maxlogins</b> limits the number of concurrent
          logins.
        </li>
        <li>
          <b class="fw-bold">priority</b> sets process priority limits.
          The value range is from -20 (highest priority) to 19 (lowest
          priority), with 0 being the default.
        </li>
        <li>
          <b class="fw-bold">nice</b> sets the lowest nice value a user is
          allowed to set a process to.
        </li>
        <li>
          <b class="fw-bold">rss</b> limits the total amount of memory a
          user can use. The value uses kilobytes.
        </li>
      </ul>
    </td>
    <td valign="top">Values include integers, such as 1, 5, or 3000.</td>
  </tr>
</tbody>
</table>

The following are examples of entries in the `/etc/security/limits.conf` file:

<table>
<thead>
  <tr>
    <th>Example</th>
    <th>Description</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td><p>jsmith hard fsize 10240</p></td>
    <td>
      Limits the maximum file size that jsmith can create to 10240 KB.
    </td>
  </tr>
  <tr>
    <td><p>@users hard maxlogins 3</p></td>
    <td>
      Limits the number of concurrent logins for members of the user group
      to three.
    </td>
  </tr>
  <tr>
    <td><p>* hard maxlogins 1</p></td>
    <td>Limits concurrent logins for all users to one.</td>
  </tr>
  <tr>
    <td><p>* hard nice 5</p></td>
    <td>Limits processes for all users to a minimum value of 5.</td>
  </tr>
</tbody>
</table>

### PAM Overview

#### login

<ul>
<li>
  Account modules check that the specified account is a valid
  authentication target under current conditions. This may include
  conditions like account expiration, time of day, and that the user has
  access to the requested service.
</li>
<li>
  Authentication modules verify the user's identity by requesting and
  checking a password or other secret. They may also pass authentication
  information on to other systems like a keyring.
</li>
<li>
  Password modules are responsible for updating passwords and are
  generally coupled to modules employed in the authentication step. They
  may also be used to enforce strong passwords.
</li>
<li>
  Session modules define actions performed at the beginning and end of
  sessions. A session starts after the user has successfully
  authenticated.
</li>
</ul>

When using PAM, the system administrator is free to choose how individual service-providing applications will authenticate users. This dynamic configuration is set by the contents of the single Linux-PAM configuration file /etc/pam.conf. Alternatively, the configuration can be set by individual configuration files located in the /etc/pam.d/ directory. The presence of this directory will cause Linux-PAM to ignore /etc/pam.conf.

When working with PAM configuration files, be aware that for the simple syntax, valid control values are as follows:

<table>
<thead>
  <tr>
    <th>Syntax</th>
    <th>Description</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td><b class="fw-bold">required</b></td>
    <td>
      Failure of a PAM will ultimately lead to the PAM-API returning
      failure, but only after the remaining stacked modules (for this
      service and type) have been invoked.
    </td>
  </tr>
  <tr>
    <td><b class="fw-bold">requisite</b></td>
    <td>
      Requisite is similar to required; however, if a module returns a
      failure, control is directly returned to the application or the
      superior PAM stack.
    </td>
  </tr>
  <tr>
    <td><b class="fw-bold">sufficient</b></td>
    <td>
      If a module succeeds and no prior required module has failed, the
      PAM framework returns success to the application or the superior PAM
      stack immediately without calling any further modules in the stack.
      A failure of a sufficient module is ignored, and processing of the
      PAM module stack continues unaffected.
    </td>
  </tr>
</tbody>
</table>

### Locking Accounts After Failed Login Attempts

Often times, hackers or unethical employees attempt to log in using existing accounts that are not their own. Since this is not their account, they will attempt to guess the user's password. This type of attack can be weakened by placing a limit on the number of time the password can be entered incorrectly and after reaching this threshold, locking the account. You can do this using the `pam_tally2` command.

`pam_tally2` comes in two parts, which include `pam_tally2.so` (the pam module) and `pam_tally2`, a stand-alone program, that can be used to interrogate and manipulate the counter file.

To lock and unlock an account after a specific number of incorrect password attempts, you must add two lines to both the `/etc/pam.d/system-auth` and the `/etc/pam.d/password-auth` files.

<ul>
<li>
  In the "auth" section of each file, add the following:
  <br />
  <br />
  <b>auth required pam_tally2.so file=/var/log/tallylog deny=3
    even_deny_root unlock_time=900</b>
</li>
</ul>

<blockquote>
<p>The options for the above line are defined as follows:</p>
<ul>
  <li>
    <b>file=/var/log/tallylog</b> – the default log file where login
    counts are kept. This is a binary file.
  </li>
  <li>
    <b>deny=3</b> – deny access after three attempts and lock the user
    account.
  </li>
  <li><b>even_deny_root</b> – apply this policy for the root user.</li>
  <li>
    <b>unlock_time=900</b> – after failing the specified number of times,
    the account will be locked for 900 seconds (15 minutes), after which
    the account will be unlocked.
  </li>
</ul>
</blockquote>

<ul>
  <li>
    In the "account" section of each file, add the following: <br />
    <b class="fw-bold">account required pam_tally2.so</b>
  </li>
</ul>

Example:

![Example of the pam_tally2 command system-auth file](/images/15/pam_tally2_1.jpg)

![Example of the pam_tally2 command password-auth file](/images/15/pam_tally2_2.jpg)

<div>
<div class="to-icon large" aria-hidden="true" style="width: 20px;"><svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div>
<div class="to-info-box-body-content">
  <span>
    The commands used in this example were for Centos. How
    <b>pam_tally2</b> is implemented on your distribution may vary.</span>
</div>
</div>

### Using pam_faillock

#### pam_tally2

Although similar, the commands added are slightly different, as shown here:

For both files, add the following in the "auth" section:

```txt
auth required pam_faillock.so preauth silent audit deny=3 unlock_time=900 auth [default=die] pam_faillock.so authfail audit deny=3 unlock_time=900
account required pam_faillock.so
```

The options for the above line are defined as follows:

<ul>
<li><b class="fw-bold">audit –</b> enables user auditing.</li>
<li>
  <b class="fw-bold">deny</b> – used to define the number of attempts
  (three in this case), after which the user account should be locked.
</li>
<li>
  <b class="fw-bold">unlock_time</b> – sets the time (900 seconds = 15
  minutes) for which the account should remain locked.
</li>
</ul>

### LDAP Integration

LDAP stands for Lightweight Directory Access Protocol. It is an application protocol used over an IP network to manage and access the distributed directory information service.

When authenticating or authorizing a user, pam_ldap first maps the user's login name to a distinguished name by searching the directory server. This is possible using the local system's identity, specified in pam_ldap.conf.

To authenticate a user, pam_ldap attempts to bind to the directory server using the distinguished name of the user (retrieved previously). Both simple and SASL authentication mechanisms are supported. In the former case, one should take care to use transport security to prevent the user's password from being transmitted in the clear.

Pam_ldap stores its configuration in the pam_ldap.conf file. See your man pages for the configuration options available for your distribution.

### System Security Services Daemon (SSSD) and Single Sign-On (SSO)

The SSSD software suite provides a set of daemons to manage access to remote authentication mechanisms. This is analogous to Active Directory Domain Services on Microsoft Windows, but is designed for Unix-like OSs, such as Linux. One of the primary uses of SSSD is for single sign-on, where access to multiple services on a network are accessed by authenticating to a single host, which then forwards the successful login to the desired service.

### tty Security

When a root user attempts to log in to a system using tty, the pam_securetty module uses the /etc/securetty file to decide which virtual terminals (tty#) root is allowed to log in from. In older distributions, /etc/securetty was referenced by programs like login directly, but PAM handles this on its own. Therefore, changes to the /etc/securetty file affect anything using PAM with a configuration file that uses pam_securetty.

When using the /etc/securetty file, consider the following:

<ul>
<li>
  If /etc/securetty does not exist, root is allowed to login from any tty.
</li>
<li>
  If /etc/securetty exists and is empty, root access will be restricted to
  single-user mode or programs that are not restricted by pam_securetty
  (such as su, sudo, ssh, scp, and sftp).
</li>
<li>
  Removing a tty# (where # is a number) entry from this file will disable
  a root user from logging on using the associated /dev/tty# terminal.
</li>
<li>
  A pseudo-terminal (pty) is a pair of virtual character devices that
  provide a bidirectional communication channel. One end of the channel is
  called the master; the other end is called the slave. The slave end of
  the pseudo-terminal provides an interface that behaves exactly like a
  classic terminal. Adding entries to the /etc/securetty file (such as
  pts/[0-9]) allow programs that use pseudo-terminals and pam_securetty to
  log in to root, assuming the allocated pty is one of the ones listed.
</li>
</ul>

Best practice is to exclude these entries because it is a security risk since it would allow, for example, someone to login to root via telnet, which sends passwords in plain text.

## 15.2.6 Auditing Files

Click one of the buttons to take you to that part of the video.

Audit Files 00:00-01:03
In this demonstration, we're going to discuss how to perform an audit for two types of files—files that are owned by root that have the SUID permission set, and files where others have both the write and execute permission set. This is important because these types of files can represent a security issue.

To be able to search for these types of files throughout my entire system, I first need to switch to my root user account. When you run a file that is owned by root and has the SUID permission set, the process that is created is granted access to the file system based on the user who owns that executable file, not the user who ran the command from the shell prompt. This means that the process runs as root, which, depending on the file, may be a potential security risk. While there are some processes that must be configured to use the SUID permission, it's important to make sure that only those that do require this permission are configured that way.

SUID Permission 01:03-02:31
To run an audit for these types of files, you can use the find command. When you use this command, you first need to specify where the search should begin. This would typically be run from the root of the system. However, to speed this up for this demo, I'll start looking in the /usr directory. Next, we then need to specify what we're looking for, which in this case is a file, so I'll enter -type f, for file. Then, we need to specify that we want to look for the permissions that have been set on the files. To do that, I'll add -perm, for permissions.

In this case, I want to look for files whose owner has the SUID permission assigned. To do that, I'll add -u+s. The -u stands for the owner and the +s means we're looking for the SUID permission. So put together, it means we are looking for any file where the owner has been assigned the SUID permission. And to end this command, I'll add -ls to list any matches that the find command locates on the screen. Because I limited this search to just the /usr tree, this ran quickly, and you see it found several files that did have the SUID permission set.

At this point, you would want to review the list of files found and make sure they need to be configured using this permission, which for these files is correct.

Executable and Writable 02:31-03:41
Another type of audit check that should be run, is to check for files that are writable and executable by others, meaning any authorized user that's not the owner and doesn't belong to the file's owning group. Although you'll rarely see this, if it does exist, it could potentially create a security risk because you're allowing anybody on the system to edit and execute that file.

To find these types of files, you use the same command as before, but with a few adjustments. First, for this example, I'm going to change the starting search to the root of the system. Then, I'm going to change the permissions I'm looking for to -o+w. This means that I'm looking for others, -o, that have the write, or +w, permission set. Then, to check for the executable permission, I'll add a comma and -o+x, and we'll leave the -ls so we can view the results. Now, let's press Enter and see what we find. Here, you see that we do have two files, where others have both the write and execute permissions set. So, I would probably want to change these.

Use cron 03:41-04:06
Since files that have the SUID bit set and files that have write and execute set for others represent a significant security risk, you really should create a cron script that runs both of these commands on a regular basis. Maybe every week or every month or so, and output that information to a log file so you can see if somebody has created a security breech using these types of permissions.

Summary 04:06-04:27
That's it for this demonstration. In this demonstration we talked about auditing files. We first showed you how to look for files that are owned by root that have the SUID permission set. Then, we looked for files where the execute and write permissions have been given to others.

## 15.2.7 File Auditing Facts

File auditing involves looking for files that pose a security risk to the computer.

This lesson covers the following topics:

- File types that pose a risk
- Commands used to audit

### File Types that Pose a Risk

File types that pose a security risk to a computer include:

<ul>
<li>
  Executable files owned by the root user that have the SUID (Set User ID)
  permission. With the SUID permission, executables will run with the
  owner permissions, not with the permissions of the user who runs them.
</li>
<li>
  Executable files owned by the root group that have the SGID (Set Group
  ID) permission. With the SGID permission, executables will run with the
  group permissions, not with the permissions of the user who runs them.
</li>
<li>
  Files that have the write and execute permissions for others (everyone
  on the Linux system who is not a user or group owner of the file). If
  the file is writable by others, anyone can replace the file with a
  malicious script to create a security risk.
</li>
</ul>
<div class="to-info-box-body">
<div class="to-icon large" aria-hidden="true" style="width: 20px;"><svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div>
<div class="to-info-box-body-content">
  <span>
    There is a limited number of files on a Linux system owned by the root
    or the root group that legitimately need the SUID or SGID permission
    set. Before changing permissions, first, verify whether they have
    actually been set appropriately.</span>
</div>
</div>

### Commands Used to Audit

The following table lists several file auditing commands:

<table>
<thead>
  <tr>
    <th>Command</th>
    <th>Function</th>
    <th>Examples</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td><b class="fw-bold">find / type f -perm</b></td>
    <td>
      Audits for files that pose a security risk. Be aware of the
      following options:
      <ul>
        <li>
          <b class="fw-bold">-o=x</b> audits for the execute permission
          for others.
        </li>
        <li>
          <b class="fw-bold">-o=w</b> audits for the write permission for
          others.
        </li>
        <li>
          <b class="fw-bold">-g=x</b> audits for the execute permissions
          for group owners.
        </li>
        <li><b class="fw-bold">-g=s</b> audits for the SGID bit.</li>
        <li><b class="fw-bold">-u=s</b> audits for the SUID bit.</li>
      </ul>
      <div>
        <div class="to-info-box">
          <div class="to-info-box-body">
            <div class="to-icon large" aria-hidden="true" style="width: 20px;"><svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div>
            <div class="to-info-box-body-content">
              <span>
                Include the <b>-ls</b> option to display the results with
                the long listing.</span>
            </div>
          </div>
        </div>
      </div>
    </td>
    <td>
      <b class="fw-bold">find / -type f -perm -u=s -ls
        <br />
        find / -type f -perm -g=s -ls
        <br />
        find / -type f -perm -o=x -ls
        <br />
        find / -type f -perm -g=x -ls
        <br />
        find / -type f -perm -u=x,o=w -ls</b>
      <br />
    </td>
  </tr>
  <tr>
    <td><b class="fw-bold">crontab -e</b></td>
    <td>Schedules the auditing task to run on a regular basis.</td>
    <td><br /></td>
  </tr>
</tbody>
</table>
