---
lang: zh-CN
title: Section 8.14 Archive and Backup
description: some description
---

As you study this section, answer the following questions:

<ul><li>What type of file would the file marketing.tar.gz represent?</li>
<li>Which <b >tar</b> command option decompresses a file?</li>
<li>Which utilities can decompress a file with a .bz2 extension?</li>
<li>When would you use the <b >dd</b> command to copy information instead of the <b >cp</b> command?</li></ul>

In this section, you will learn to:

- Create a compressed tar file
- Extract from tar files

Key terms for this section include the following:

<table class="terms">
<thead>
  <tr>
    <th>Term</th>
    <th>Definition</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>Full backup</td>
    <td>
      A copy of all the files that exists at the point in time when the
      backup is taking place.
    </td>
  </tr>
  <tr>
    <td>Incremental backup</td>
    <td>
      An incremental backup stores files that have been changed or added
      since the last backup has been made.
    </td>
  </tr>
  <tr>
    <td>Differential backup</td>
    <td>
      A differential backup copies all of the files that have been
      updated since the last full backup.
    </td>
  </tr>
  <tr>
    <td>Snapshot clones backup</td>
    <td>
      A snapshot is copy of blocks of data that make up a set of files
      at a point in time. This feature allows you to take point-in-time
      snapshots of the files on a system without causing the downtime
      inherent in traditional backups.
    </td>
  </tr>
  <tr>
    <td>Image backup</td>
    <td>
      A single computer file or set of files that contain the contents
      of a hard disk created by copying the disk sector-by-sector. It's
      also called a system image.
    </td>
  </tr>
  <tr>
    <td>
      Message Digest Algorithm 5
      <br />
      (MD5)
    </td>
    <td>An algorithm that produces a 128-bit hash value.</td>
  </tr>
  <tr>
    <td>
      Secure Hash Algorithm
      <br />
      (SHA)
    </td>
    <td>
      A cryptographic hash function that takes an input and produces a
      160-bit (20-byte) hash value known as a message digest. SHA is
      typically rendered as a 40-digit hexadecimal number.
    </td>
  </tr>
</tbody>
</table>

This section helps you prepare for the following certification exam objectives:

<table class="objectives">
<thead>
  <tr>
    <th>Exam</th>
    <th>Objective</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td width="260">TestOut Linux Pro</td>
    <td>
      2.2 Manage the file system
      <ul>
        <li>Create and manage archives and backups</li>
      </ul>
    </td>
  </tr>
  <tr>
    <td>CompTIA Linux+ XK0-005</td>
    <td>
      1.2 Given a scenario, manage files and directories
      <br />
      <ul>
        <li>File compression, archiving, and backup</li>
        <li style="list-style: none; display: inline">
          <ul>
            <li>tar</li>
            <li>cpio</li>
            <li>dd</li>
            <li>gzip</li>
            <li>bzip2</li>
            <li>xz</li>
            <li>zip</li>
          </ul>
        </li>
        <li>Copying files between systems</li>
        <li style="list-style: none; display: inline">
          <ul>
            <li>rsync</li>
            <li>nc</li>
          </ul>
        </li>
      </ul>
      <p>
        1.5 Given a scenario, use the appropriate networking tools or
        configuration files
      </p>
      <ul>
        <li>Remote networking tools</li>
        <li style="list-style: none; display: inline">
          <ul>
            <li>rsync</li>
            <li>Secure Copy Protocol (SCP)</li>
            <li>SSH File Transfer Protocol (SFTP)</li>
          </ul>
        </li>
      </ul>
    </td>
  </tr>
</tbody>
</table>

## 8.14.1 File Archives

Click one of the buttons to take you to that part of the video.

File Archives 00:00-00:39
In this lesson, we're going to discuss using the tar command to create file archives. tar is a commonly used Linux backup tool, and it stands for "tape archiver" because originally, it was used—and still can be, by the way—to back up data to a tape drive. Nowadays, though, the tar utility is mostly used to take a list of specified files and copy them into a single archive file called a tar file. This can be compressed with a compression utility to produce what's called a tarball. The tar utility can also send backup jobs to a variety of media, like a tape drive or removable hard disk drive.

Create a New Archive 00:39-02:43
The syntax for creating a new archive is shown here. First enter tar and then add the -c option, which tells tar to create a new archive file. The -v can optionally work here as well. It stands for verbose mode. It displays each file that's added to the archive. Next, is the -f option to specify the name of the new archive file. Finally, we specify the directory or file to add.

For example, let's back up the home directory here, save it in a directory named homeback.tar, and put it on an external USB hard drive that's mounted on the /media/usb directory. We run tar, followed by the -cvf options. We specify the name of the backup file we're creating, which is /media/usb—that's where the USB drive is mounted—and the name of the file, homeback.tar. This backs up the /home directory.

Notice this message here stating that it's removing leading forward slashes from member names. This is the default, and it's important. Removing the forward slashes converts absolute paths to relative paths by default. This allows us to restore these files into any directory. Let's do a test restore into the /tmp directory. We'll create a directory named home within the /tmp directory and then create all the subdirectories and files within it. No problem. Alternately, you could disable this functionality and leave the absolute path in the archive file. This would restore these files and directories to their original paths. If the original files that were backed up are there, they'll be overwritten by the new ones.

If you want to write the archive to a tape drive, just replace the filename parameter with the tape drive's device filename. On most distributions, the first SCSI tape drive is referenced with the /dev/st0 device file. So to back up the /home directory to a tape drive, run tar -cvf /dev/st0 and then specify the directory as /home.

Extract an Archive 02:43-03:28
Once an archive is created, you can start extracting files from it. To do so, you still use the tar command, but use the -x option this time.

Let's extract all the files from the backup that we just created, /homeback.tar. To do this, run tar -xvf and specify the filename, which is /media/usb/homeback.tar. Now all the archive's files are restored in the current directory. Notice here that the leading forward slash was removed from each file, and we're extracting the archive file in the /tmp directory. When it's done, we should see a directory in /tmp named home with all the files in their own subdirectories.

tar Options 03:28-06:25
There are many more options available for you to customize tar. Check out the tar man page to see all of them. Here are some useful ones. First, as we already saw, is the -c option for creating a new archive file. Then -d is used for comparing files inside the archive file against files that already exist on the system. It'll also identify any differences it finds. Another useful option is -J. It'll compress an archive file you're creating by running it through the xz utility. Or if you're extracting files from an archive that was compressed with xz, it'll decompress the tar archive using xz and then extract the files. -j does a similar thing, except that it uses bzip compression instead. The -P option prevents tar from stripping the leading forward slash from the file name. This preserves each file and directory's full path. Use this one with caution, as we discussed earlier.

The -r option adds files to the end of an existing tar archive. -t lists the contents of the archive file. The -u option appends files to an existing tape archive if it has a modification date that's newer than the existing files there. It's a great option when you only want to back up files that've changed. The -x option extracts files from the archive, as we mentioned earlier. And -z is similar to the two -j options. Finally, the -X option excludes certain files from the archive. This is done by listing the files you don't want included in a text file and then using -X followed by that exclusion file.

Now, let's revisit our previous example and shrink the archive file with compression. The archive will run through the xz compression utility by adding the -J option to the command like this: tar -cJvf followed by the same parameters as before. Here's the backup file and directory name. Notice the backup filename is slightly different. We added a .xz extension to the end. This isn't necessary, but it's a good practice because it shows which utility was used for compression. This makes it easier when you extract files because you use the same option for compression and extraction. Remember, there are three compression options with tar: bzip2, gzip, or xz. The .xz or .lzma extensions indicate compression through xz. The .bz2 extension indicates compression through bzip. And the .gz extension indicates compression through gzip.

In our example, we have an .xz extension, so we know that xz was used to compress the archive. This means that we'll use the -x option for file extraction. We also use the -J option to first decompress the archive file with the xz utility.

Summary 06:25-06:43
That's it for this lesson. In this lesson, we discussed how to manage file archives on Linux using the tar command. We looked at using tar to create an archive, extract files from an archive, and compress archive files as well.

## 8.14.2 Using tar

Click one of the buttons to take you to that part of the video.

Use tar 00:00-00:18
In this demonstration, we're going to look at using the tar command to manage archive files. An archive file is basically a single file on your system that contains other files. If you want to save space, you can actually take an archive file and compress it down.

tar Help 00:18-00:36
Before we start, let's take a look at getting help for tar by typing tar --help. Understand that tar is a very extensive tool. It can do a lot of different things. We only have time in this demo to look at its basic functionality, but you should open up the tar man or help page and become familiar with all its options.

tar Options 00:36-01:55
A couple of key ones that you should know are listed right here. First of all, we've got -c and -x. If you needed to create a new archive file and then add files into it, you'd use the -c option. On the other hand, if you already have an archive file and want to pull files out of it, use the -x extract option. Another useful option is -r. You'd use it in situations where you already have an existing archive file and you want to just add a couple of files to it. Rather than recreating it completely, you can use -r to just drop those files in at the end of the archive.

A similar option is -u. This is for newer versions of files that already exist in the archive. Let's say that we want the newer versions to replace the older ones. This tells tar to take a look at the file timestamps, and if the ones being added are newer, to go ahead and overwrite them.

Another useful option with tar is -t, which we can use to see just what files exist within an archive. I like to use the -v option as well. Understand that if you don't use the -v option with tar, you'll have no idea what's going on. And if you're managing a very large archive, either creating or extracting files from it, you won't know what's going on. And if that archive file is very large, you might assume that something is hung, when in fact it's just processing.

New Compressed Archive 01:55-02:23
Remember earlier I said that you can compress an archive file in order to save space? You have three different options you can choose from to make this happen. You can use the -J option to compress the archive file with the xz utility. You can use the -j option to use the bzip2 compression utility. Or you can use the -z option down here to compress the archive using the gzip utility. Which one is better? They all work about the same to be honest.

Create a New Archive File 02:23-02:58
With that in mind, let's clear our screen and create a new compressed archive. On this system, we have a shared folder named shared. It resides in the /mnt directory. These files are used by various users on the system. And as the system administrator, I want to create a backup of this directory periodically so that I don't lose any data on it. Let's do that.

First, we'll use sudo and then type tar to start the command. Because we're creating a new archive file, I need to use -c for create, and I'm going to throw the v option in there for Verbose because I want to see what's happening as that file is being created.

Compress the Archive File 02:58-03:23
Let's also compress the archive after we create it. Remember, we can use bzip2, gzip, or xz. I'm going to go ahead and specify z for gzip. Now I have to put in the f option to specify the name of the archive file that I want to create. Let's go ahead and just create it in /tmp, and let's name it backup.tar. And then I'm going to add an extra extension on .gz.

Extra Extensions 03:23-03:46
Is that required? No, but it's a good practice because it tells anybody who goes to extract this archive file which compression algorithm was used. By specifying an extension of .gz, I know that it was compressed with the gzip utility. So now everyone knows which options to use with the tar command. If I'd compressed it with bzip2, I would've used an extension of .bz2, and so on.

Archive Content 03:46-04:04
Now I have to specify what I want to put in the archive. Let's just put in the contents of /mnt/shared. Okay, hit Enter, and here you can see all the files that were added to the archive. If we were to change to the /tmp directory, we could do an ls and see that the archive file was created.

Files from Backup 04:04-05:29
So why is this example helpful? Let's suppose that an end user accidentally deleted all the files in the /shared directory. Everybody is mad at that person, but luckily for them, we can restore all those files from backup by pulling them out of the archive we just created. Let's go ahead and extract it here into my /tmp directory. I run the tar command again, but this time, I need to specify -x instead of -c because I'm extracting rather than creating now.

I'm going to use the v option again for verbose to see what's going on as each file is extracted. I also need to specify z to decompress the already compressed archive file with the gz utility. And then I use f to specify the filename, backup.tar.gz.

I'm not going to specify an extraction location in this command, and so it's going to extract right here in /tmp. But if I wanted to, I could specify a path where I wanted the files to be extracted to. Don't forget to use sudo if you don't have permissions to the area where it's being extracted.

If I do an ls command, you'll notice that there's a new directory now. By default, tar preserved the original directory file structure, so we have an /mnt directory here. By switching to /mnt and then to /shared, we're able to view all the files that were extracted from the compressed tar file. From there, you could copy individual files to the original shared folder location if you needed.

Summary 05:29-05:45
That's it for this demonstration. In this demo, we talked about using tar to manage archive files. We first talked about how to create a new archive file, and then we looked at how to extract files from it as well.

## 8.14.5 Archive Facts

Being able to backup, restore, and compress files helps in protecting and copying files, and even disks or partitions.

This lesson covers the following topics:

<ul><li>Using tar</li>
<li>Using gzip</li>
<li>Using xz</li>
<li>Using bkzip2</li>
<li>Using zip</li></ul>

### Using tar

The tar (tape archive) utility takes the contents of several files and stores them as a single file. The tar command can be used to backup directories or entire file systems. To help others know that the tar utility must be used to extract files from it, by convention, an archive file created with tar is assigned an extension of .tar.

<table>
<thead>
<tr>
  <th>Command</th>
  <th>Options and Descriptions</th>
  <th>Examples</th>
</tr>
</thead>
<tbody>
<tr>
  <td><b>tar</b></td>
  <td>
    <table>
      <tbody>
        <tr>
          <td><b>-A</b></td>
          <td>Appends one tar file to another archive file.</td>
        </tr>
        <tr>
          <td><b>-c</b></td>
          <td>Creates a new archive.</td>
        </tr>
        <tr>
          <td><b>-d</b></td>
          <td>
            Identifies differences between the files in an archive
            file and the same files in the file system.
          </td>
        </tr>
        <tr>
          <td><b>-v</b></td>
          <td>
            Displays a list of all files being written into the
            archive.
          </td>
        </tr>
        <tr>
          <td><b>-f</b></td>
          <td>
            Specifies the file to create or unpack. Without this
            option, tar uses standard input and output as the
            destination.
          </td>
        </tr>
        <tr>
          <td><b>-x</b></td>
          <td>
            Extracts the files. If no destination directory is
            specified, then tar extracts the files to the current
            working directory.
          </td>
        </tr>
        <tr>
          <td><b>-z</b></td>
          <td>
            Compresses and decompresses a file using the gzip utility
            (normally named with a .gz extension).
          </td>
        </tr>
        <tr>
          <td><b>-j</b></td>
          <td>
            Compresses and decompresses a file using the bzip2 utility
            (normally named with a .bz2 extension).
          </td>
        </tr>
        <tr>
          <td><b>-J</b></td>
          <td>
            Compresses and decompresses a file using the xz utility
            (normally named with a .xz or .lzma extension.
          </td>
        </tr>
        <tr>
          <td><b>-C</b></td>
          <td>
            Changes to a specific directory to extract the files.
          </td>
        </tr>
        <tr>
          <td><b>-t</b></td>
          <td>Lists the contents of an archive.</td>
        </tr>
        <tr>
          <td><b>-P</b></td>
          <td>
            Tells tar to not strip the leading / from filenames as
            they are added to the archive.
          </td>
        </tr>
        <tr>
          <td><b>-r</b></td>
          <td>Adds files to the end of an existing tar archive.</td>
        </tr>
        <tr>
          <td><b>-u</b></td>
          <td>
            Adds files to the end of an existing tar archive only if
            they are newer than the existing files in an archive.
          </td>
        </tr>
        <tr>
          <td>
            <b>-X <i class="fs-italicize">file_name</i></b>
          </td>
          <td>
            Causes tar to exclude the file names contained in the
            specified file when creating an archive file.
          </td>
        </tr>
      </tbody>
    </table>
  </td>
  <td>
    <b>tar -cf /root/tarbackups/oct17backup.tar /home</b> <br />
    Writes a backup of the /home directory to the
    <b>/root/tarbackups/oct17backup.tar</b> file.
    <h2>tar -cvf /root/tarbackups/oct17backup.tar /home</h2>
    <h2>tar -xvf /root/tarbackups/oct17backup.tar -C /home</h2>
  </td>
</tr>
</tbody>
</table>

### Using gzip

The gzip command reduces the size of the named files using Lempel–Ziv coding (LZ77). Whenever possible, each file is replaced by one with the extension .gz, while keeping the same ownership modes, access and modification times. The default extension is -gz for VMS, z for MSDOS, OS/2 FAT, Windows NT FAT and Atari.) If no files are specified, or if a file name is a dash (-), the standard input is compressed to the standard output. gzip will only attempt to compress regular files, in particular, ignoring symbolic links.

<table>
<thead>
  <tr>
    <th>Command</th>
    <th>Options and Description</th>
    <th>Examples</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td><b>gzip</b></td>
    <td>
      <table>
        <thead>
          <tr>
            <th>Option</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><b>-c</b></td>
            <td>Writes the file to standard output.</td>
          </tr>
          <tr>
            <td><b>-d</b></td>
            <td>Decompresses the file.</td>
          </tr>
          <tr>
            <td><b>-l</b></td>
            <td>Displays information about files in an archive.</td>
          </tr>
          <tr>
            <td><b>-r</b></td>
            <td>
              Recursively compresses all files in directories and
              subdirectories.
              <div>
                <div>
                  <div>
                    <div class="to-icon large" aria-hidden="true" style="width: 20px">
                      <svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div>                              
                    <div class="to-info-box-body-content">
                      <span>This is the same as the<b>tar -z</b> command.</span>
                    </div>
                  </div>
                </div>
              </div>
            </td>
          </tr>
        </tbody>
      </table>
    </td>
    <td>
      <b>gzip file</b> .tar
      <br />
      Compresses an archive file created with tar. The original
      uncompressed file is removed.
      <h2>gzip -c file.tar &gt; file.tar.gz</h2>
      <h2>gzip -d file.tar.gz</h2>
    </td>
  </tr>
</tbody>
</table>

### Using xz

The xz command is a general-purpose data compression tool with command line syntax similar to gzip and bzip2. The native file format is the .xz format, but also the legacy .lzma format and raw compressed streams with no container format headers are supported.

The xz command compresses or decompresses each file according to the selected operation mode. If no files are given or the file is a dash (-), xz reads from the standard input and writes the processed data to standard output. xz will refuse (display an error and skip the file) to write compressed data to standard output if it is a terminal. Similarly, xz will refuse to read compressed data from standard input if it is a terminal.

<table>
<thead>
  <tr>
    <th>Command</th>
    <th>Options and Descriptions</th>
    <th>Examples</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td><b>xz</b></td>
    <td>
      <table>
        <thead>
          <tr>
            <th>Option</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><b>-z</b></td>
            <td>Compresses a file.</td>
          </tr>
          <tr>
            <td><b>-d</b></td>
            <td>Decompresses a file.</td>
          </tr>
          <tr>
            <td><b>-k</b></td>
            <td>
              Keeps the original file unchanged.
              <div>
                <div>
                  <div>
                    <div class="to-icon large" aria-hidden="true" style="width: 20px">
                      <svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div>                              
                    <div class="to-info-box-body-content">
                      <span>This is the same as the<b>tar -J</b> command.</span>
                    </div>
                  </div>
                </div>
              </div>
            </td>
          </tr>
        </tbody>
      </table>
    </td>
    <td>
      <b>xz file</b> <br />
      Compresses the archive file and removes the original file.
      <h2>xz -k file</h2>
      <h2>xz -d</h2>
    </td>
  </tr>
</tbody>
</table>

### Using bzip2

Compared with gzip, the bzip2 command will create smaller archives but has a slower decompression time and higher memory use.

bzip2 compresses files using the Burrows-Wheeler block sorting text compression algorithm, and Huffman coding.
The command-line options are deliberately very similar to those of GNU gzip, but they are not identical.

bzip2 expects a list of file names to accompany the command-line flags. Each file is replaced by a compressed version of itself, with a name of original_name.bz2. Each compressed file has the same modification date, permissions, and, when possible, ownership as the corresponding original, so that these properties can be correctly restored at decompression time.

<table>
<thead>
<tr>
  <th>Command</th>
  <th>Options and Descriptions</th>
  <th>Examples</th>
</tr>
</thead>
<tbody>
<tr>
  <td><b>bzip2</b></td>
  <td>
    <table>
      <thead>
        <tr>
          <th>Option</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><b>-z</b></td>
          <td>Compresses a file.</td>
        </tr>
        <tr>
          <td><b>-d</b></td>
          <td>Decompresses a file.</td>
        </tr>
        <tr>
          <td><b>-k</b></td>
          <td>
            Keeps the original file unchanged.
            <div>
              <div>
                <div class="to-info-box-body">
                  <div class="to-icon large" aria-hidden="true" style="width: 20px">
                    <svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div>                              
                  <div class="to-info-box-body-content">
                    <span>This is the same as the<b>tar -j</b> command.</span>
                  </div>
                </div>
              </div>
            </div>
          </td>
        </tr>
      </tbody>
    </table>
  </td>
  <td>
    <b>bzip2 file.tar</b> <br />
    Compresses the tar archive file and removes the original file.
    <h2>bzip2 -k file.tar</h2>
    <h2>bzip2 -d</h2>
  </td>
</tr>
</tbody>
</table>

### Using zip

The zip program puts one or more compressed files into a single zip archive, along with information about the files (name, path, date, time of last modification, protection, and check information to verify file integrity). An entire directory structure can be packed into a zip archive with a single command. This program is useful for: packaging a set of files for distribution, archiving files, and saving disk space by temporarily compressing unused files or directories.

The zip command is a compression and file packaging utility for many operating systems including Linux, Unix, and Windows. It is analogous to a combination of the Linux tar commands and is compatible with PKZIP (Phil Katz's ZIP for MSDOS systems). A companion program named unzip unpacks zip archives.

### `zip [options] zipfile files_list`

<table>
<thead>
<tr>
  <th>Command</th>
  <th>Options and Descriptions</th>
  <th>Examples</th>
</tr>
</thead>
<tbody>
<tr>
  <td><b>zip</b></td>
  <td>
    <table>
      <thead>
        <tr>
          <th>Option</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td><b>-d</b></td>
          <td>
            Removes a file from the zip archive. When a zip archive
            includes multiple files, use this option to remove a file
            from the archive.
          </td>
        </tr>
        <tr>
          <td><b>-u</b></td>
          <td>
            Updates the file in the zip archive. The opposite of -d,
            meaning you can use this option to add a new file to the
            zip file already created.
          </td>
        </tr>
        <tr>
          <td><b>-m</b></td>
          <td>Deletes the original files after zipping.</td>
        </tr>
        <tr>
          <td><b>-r</b></td>
          <td>Lets you zip a directory recursively.</td>
        </tr>
        <tr>
          <td><b>-x</b></td>
          <td>
            Lets you exclude the file's files while creating the zip
            of multiple files, such as a directory.
          </td>
        </tr>
        <tr>
          <td><b>-v</b></td>
          <td>
            Verbose mode or print diagnostic version information.
          </td>
        </tr>
      </tbody>
    </table>
  </td>
  <td>
    <b>zip –r <i class="fs-italicize">my.zip mydir</i></b> <br />
    Will recursively zip the files in the mydir directory. The results
    are saved to the my.zip file.
    <h2>zip –m my.zip myfile.txt</h2>
  </td>
</tr>
</tbody>
</table>

## 8.14.6 The cpio command

Click one of the buttons to take you to that part of the video.

The cpio Command 00:00-00:22
In this lesson, we'll look at using the cpio archiving program in Linux. The cpio utility is a backup and archiving tool like tar, but it does have its differences. For example, unlike tar, you attach a list of files to be added to the archive with the standard input.

Create a cpio Archive 00:22-02:43
With tar, you specify as a command option which directory or file you want to add to the archive. But to send cpio a list of files to back up, you use the cat command. This will display the contents of a text file that contains the files you want to include. Here's how you do it: run cat, followed by the filename, and then pipe the output to the input of the cpio command.

Another way is to use the find or ls command to generate the list of files. Using cat helps when you have lots of files spread throughout the system. find works best when you want to find a specific file that matches a specific pattern. And using ls helps when you want to add files from a single directory structure to the archive.

For example, let's back up the contents of rtracy's /home directory. Here, we want to generate a listing of all the files within the directory and send it to the input of the cpio command. Then we redirect the output from the cpio command to a file in the file system.

We can use the find command here. First, let's switch to rtracy's home directory and run find. Specify a period to start in the current directory. Then specify depth and print. Now find will generate a list of all files in the current directory. The -print option simply prints the full name of each file to its standard output. -depth sends find through the contents of the current directory and then through each subdirectory. We could've also used the ls command to look recursively at all the subdirectories to generate our file list.

Notice that we've taken the output of the find command and piped it to the input of the cpio command. cpio will use this list to create the archive. We specify -o to create a new archive and the v option for "Verbose". This displays each file and directory name that's being added to the archive.

With cpio, you must redirect the output to a file in the file system. If you omit the greater-than sign, it won't work. Okay, here we have a USB drive mounted in the /media/usb directory. We'll create a new backup file, a cpio archive file on the USB drive named backup.cpio.

Compress a cpio Archive 02:43-03:31
You can compress a cpio archive by adding the gzip utility to the pipe. Here, we've used the same find command. Now we're going to pipe the output to the input. We have the standard in of the cpio command, and we have the -o and -v options again to create the archive.

Instead of redirecting to output to the backup file, we'll pipe the output of cpio to the input of the gzip command. This compresses the archive file. Then we redirect the output of gzip to the file in the file system. Notice the .gz extension we added. When we need to extract files from the archive, this .gz extension reminds us that gzip was used to compress the archive, and gunzip is needed to decompress it.

Extract Files from a cpio Archive 03:31-04:04
To restore files from a non-compressed archive, use this command: cpio -iv. This will verbosely extract files from the filename that's being sent to the standard input. And we use the less-than sign to send the filename to the standard in of the cpio command. Note that no matter what you're using cpio for, everything has to go to its standard input. When we run the command, the files and directories within the archive are extracted to the current directory, which is a /tmp directory.

Extract Files from a Compressed cpio Archive 04:04-04:51
Now remember, since the backup.cpio.gz archive was compressed with the gzip utility, it needs to be decompressed first with the gunzip command. The decompressed result is the backup.cpio file, and now we can use the cpio command to extract files from the archive.

Another option is to add the -c option to the gunzip command and specify the name of the compressed archive file. And then you pipe the output of the gunzip command to the input of the cpio command with the -i option to extract the files. Here, the -c option tells gunzip to write the output of the command to the standard out, which leaves the original file intact. This then allows cpio to process it.

Summary 04:51-05:15
That's it for this lesson. In this lesson, we discussed how to use the cpio utility to create archive files and directories. Then we talked about how to compress a cpio archive. Next, we looked at how to extract files from a cpio archive and finished by going over how to extract files from a compressed cpio archive.

## 8.14.7 The dd command

Click one of the buttons to take you to that part of the video.

The dd Command 00:00-00:27
In this lesson, we'll look at using the dd command for managing files and directories in your Linux file system. The dd utility's main purpose is to convert and copy records or files, and since most data in Linux is handled like a file, it has many uses. It can do many things like disk imaging, forensics, and backing up master boot records. The key difference between dd and the other file copy utilities is that dd copies data using records.

Copy a File with dd 00:27-01:05
The default file size for a record with dd is 512 bytes. The syntax for copying a file is shown here. Enter dd, then if= and the name of the input file, space, the of=, and the name of the output file. Let's specify the boot.log file that resides in this home directory. For the output file, write it to a file named boot.log and copy it to the /tmp directory. Here you can see the process.

Even though you can copy a file with dd, it's probably not the best utility for simply copying a file. cp or mv might be better for that.

Copy a Partition with dd 01:05-02:02
Instead, dd is best for non-traditional file copying. For example, because it uses records to copy data, it's great for copying an entire disk partition to a single file. So, we can use a single command-line tool to implement a powerful form of drive imaging.

Additionally, dd can be used to create an image file of a disk partition. This file can then be moved to another system, and the image can be extracted with dd to create a new disk partition on a blank hard disk drive. This works because all records, or blocks, within the partition are copied and then restored as an exact copy of the original.

The syntax is dd, then specify the device file name of the partition to be copied and then the name of the output file to create. In this example, we copied the entire /dev/sdb1 partition to a file named partbak.dd on a USB drive. This process will take some time. When done, we can use dd to restore that partition onto another hard disk drive.

Copy a Disk with dd 02:02-02:27
The dd command can also be used to create an image file of an entire hard disk drive. The syntax is very similar, but here specifies the device file for the hard disk itself. Here we're taking the entire sdb hard disk drive and copying each bit to a file named driveback.dd on an external USB drive. Then that file can be cloned onto another disk using the dd command. And just reverse the input and output file names to restore.

Back Up the MBR 02:27-03:08
You can also use dd to back up the master boot record and its partition table if your hard drives use the MBR partitioning scheme. Here's the syntax. Enter dd and then the input file, which is the device's file name. Then enter the file name to be created for the output. This time we use the bs parameter to specify the record size.

The first 512K block of the hard drive with MBR partitioning is where the master boot record and the partition table reside. So, we specify grabbing this first block with a count=1 parameter. Here we're looking at the main hard drive in the system /dev/sda. Our master boot record will now back up to this file.

Summary 03:08-03:26
That's it for this lesson. In this lesson, we talked about how you can use the dd command to copy files and partitions. Then, we looked at how to copy a disk with dd. And we finished the lesson by discussing how to use dd to back up the master boot record.

## 8.14.8 Using cpio

Click one of the buttons to take you to that part of the video.

Intro to cpio and dd 00:00-00:23
In this demonstration, we're going to talk about the cpio and dd utilities. cpio is a file archival utility on Linux, similar in functionality to tar. The dd utility is a data transfer tool that can be used to copy individual files as well as read and write entire partitions and disks.

The cpio Utility 00:23-02:29
The cpio command can extract from and write to cpio format archives. In the current directory, there's an archive called archive.cpio. We can get a list of the contents of this archive using the cpio -t < archive.cpio command. The t flag causes cpio to list the contents. This 1 block refers to the size of the archive, where a block is a unit related to the way the system copies and transfers file data.

You may notice that this syntax is a bit unusual. We used a redirect operator instead of a command line argument. Let's talk about that. The "IO" in cpio refers to input and output. In general, data goes in and out of cpio through standard input and output, and we'll be using pipes and redirect operators to handle this.

Let's say we want to extract just file1.txt here. To do that, we can use cpio -i file1.txt < archive.cpio. The i flag causes cpio to extract. Then the file is extracted into the current directory. Now let's say that we want to make a new cpio archive containing these two files: archiveme1.txt and archiveme2.txt. This is possible because cpio is designed to be used in combination with utilities like ls and find. When adding files to an archive, cpio takes the list of files to be added from the standard input. We can use ls archiveme*.txt to list only the files in the current directory that match that pattern. So, to create an archive using those files, we direct the output of ls into cpio with a pipe, like this: ls archiveme*.txt | cpio -o > archive2.cpio. Now let's move on to dd.

The dd Utility 02:29-04:38
The dd command can be used to copy files, similar to cp. In the current directory, we have a file named file1.txt. We can make a copy of that file using dd if=file1.txt of=file2.txt, where "if" means input file and "of" means output file. Using dd instead of cp can sometimes be useful for copying very large files, as dd supports an option called status=progress, which indicates how much data has been transferred, though it's not commonly used for this purpose.

Instead, dd is most useful for its ability to read and write directly to drives and partitions. There are a variety of uses for this, but a fairly common one is to create a bootable USB drive using a downloaded Linux installation image. In this directory, we have a copy of the latest Ubuntu installation image, and we have a USB flash drive connected to the system that's ready to have the image written to it.

Okay, two warnings here: First, using dd to write directly to a disk will overwrite any partitions and files already there. There won't be any way to reliably recover the data. Second, if the disk has a filesystem that's currently mounted or a swap partition that's in use, dd won't issue any warnings. Serious issues can happen while the data is being overwritten. With that said, let's try it out.

Our USB drive is /dev/sdb, and lsblk shows that there are no partitions, no filesystems, and no mount points. So we're good to go. The command is sudo dd if=ubuntu.iso of=/dev/sdb status=progress. We need elevated privileges to modify system devices, and because this process can take several minutes, it's good to be able to monitor the status.

Summary 04:38-04:50
And that's it for now. To recap, in this demo, we talked about the cpio and dd utilities.

## 8.14.9 cpio and dd Facts

This lesson covers the following topics:

- Use cpio
- Use dd

### Use cpio

#### cpio

- Copies files to an archive (copy-out mode).
- Extracts files from an archive (copy-in mode).
- Copies files to a different directory tree (copy-pass mode).

<table>
<thead>
  <tr>
    <th>Command</th>
    <th>Options</th>
    <th>Examples</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td><b>cpio</b></td>
    <td>
      <table>
        <thead>
          <tr>
            <th>Option</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><b>-o</b></td>
            <td>Creates the archive in copy-out mode.</td>
          </tr>
          <tr>
            <td><b>-v</b></td>
            <td>
              Causes cpio to display verbose output, showing file names
              as they're added or removed.
            </td>
          </tr>
          <tr>
            <td><b>-i</b></td>
            <td>Extracts files by invoking copy-in mode.</td>
          </tr>
          <tr>
            <td><b>-u</b></td>
            <td>Overwrites existing files.</td>
          </tr>
          <tr>
            <td><b>-d</b></td>
            <td>
              Creates directory paths (if needed) during extraction.
            </td>
          </tr>
          <tr>
            <td><b>-t</b></td>
            <td>Displays archive contents without extracting files.</td>
          </tr>
          <tr>
            <td><b>-p</b></td>
            <td>Copies files to a new directory (copy-pass mode).</td>
          </tr>
        </tbody>
      </table>
    </td>
    <td>
      <b
        >ls ~/4archive | cpio -ov &gt;
        <i class="fs-italicize">filename</i> .cpio <br
      /></b>
      Creates a cpio archive from the files in the ~/4archive directory
      <h2>cpio -iv &lt; filename.cpio</h2>
      <h2>ls ~/copyme | cpio -pvd ./newdirectory</h2>
    </td>
  </tr>
</tbody>
</table>

### Use dd

#### dd

<ul><li>Back up and restore the entire hard disk or partition</li>
<li>Back up the Master Boot Record (MBR)</li>
<li>Copy and convert magnetic tape format</li>
<li>Convert between ASCII and EBCDIC formats</li>
<li>Convert lowercase to uppercase</li></ul>

<table>
<thead>
  <tr>
    <th>Command</th>
    <th>Options</th>
    <th>Examples</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td><b>dd</b></td>
    <td>
      <table>
        <thead option="">
          <tr>
            <th>Option</th>
            <th>Description</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td><b>bs=BYTES</b></td>
            <td>
              Read and write up to bytes at a time (the default is 512;
              overrides ibs and obs)
            </td>
          </tr>
          <tr>
            <td><b>cbs=BYTES</b></td>
            <td>Convert bytes at a time</td>
          </tr>
          <tr>
            <td><b>conv=CONVS</b></td>
            <td>
              Convert the file as per the comma-separated symbol list
            </td>
          </tr>
          <tr>
            <td><b>count=N</b></td>
            <td>Copy only <b>N</b> input blocks</td>
          </tr>
          <tr>
            <td><b>ibs=BYTES</b></td>
            <td>Read up to bytes at a time (the default is 512)</td>
          </tr>
          <tr>
            <td><b>if=FILE</b></td>
            <td>Read from <b>FILE</b> instead of stdin</td>
          </tr>
          <tr>
            <td><b>iflag=FLAGS</b></td>
            <td>Read as per the comma-separated symbol list</td>
          </tr>
          <tr>
            <td><b>obs=BYTES</b></td>
            <td>Write bytes at a time (the default is 512)</td>
          </tr>
          <tr>
            <td><b>of=FILE</b></td>
            <td>Write to <b>FILE</b> instead of stdout</td>
          </tr>
          <tr>
            <td><b>oflag=FLAGS</b></td>
            <td>Write as per the comma separated-symbol list</td>
          </tr>
          <tr>
            <td><b>seek=N</b></td>
            <td>Skip <b>N</b> obs-sized blocks at start of output</td>
          </tr>
          <tr>
            <td><b>skip=N</b></td>
            <td>Skip <b>N</b> ibs-sized blocks at start of input</td>
          </tr>
          <tr>
            <td><b>status=LEVEL</b></td>
            <td>
              The level of information to print to stderr -
              <b>none</b> suppresses everything but error messages,
              <b>noxfer</b> suppresses the final transfer statistics,
              and <b>progress</b> shows periodic transfer statistics
            </td>
          </tr>
        </tbody>
      </table>
    </td>
    <td>
      <b>dd if=/dev/sda of=/dev/sdb</b> <br />
      Will clone one hard disk to another hard disk
      <h2>dd if=hdadisk.img of=/dev/sdb3</h2>
      <h2>dd if=/dev/hda1 of=~/partition.img</h2>
    </td>
  </tr>
</tbody>
</table>

## 8.14.10 Backup Strategy Facts

File backups can be performed using a number of Linux commands. However, an overall backup strategy will make the backup process more efficient and ensure all files are backed up in a timely manner.

This lesson covers the following topics:

- Backup types
- Off-site and off-system storage plans
- Integrity checks

### Backup Types

There are different types of backup that you should be familiar with. Each type has its own pros and cons, so consider which scenario works best for you.

<table>
<thead>
  <tr>
    <th>Backup Type</th>
    <th>Description</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>Full backup</td>
    <td>
      A full backup is a copy of all the files that exist at the point
      in time when the backup is taking place. If a backup took place
      last week, when a full backup runs again this week, every single
      file will be backed up again, even if nothing has been updated.
      This option can be expensive, given that each time a new backup
      runs, you will need, at the very least, double the amount of
      backup storage as you did before.
    </td>
  </tr>
  <tr>
    <td>Incremental backup</td>
    <td>
      An incremental backup stores files that have been changed or added
      since the last backup was made. This type of backup can save a
      considerable amount of storage capacity since only the updated
      files are backed up. In this scenario, every time a backup runs,
      only the files updated since the last backup are updated. Newly
      added files will also be backed up which is a good option when
      running backups regularly.
    </td>
  </tr>
  <tr>
    <td>Differential backup</td>
    <td>
      A differential backup copies all of the files that have been
      updated, but only against the last full backup. An incremental
      backup would backup files changed since the last full or
      incremental backup. A differential backup will update files that
      have changed since the last full backup.
    </td>
  </tr>
  <tr>
    <td>Snapshot clones backup</td>
    <td>
      Snapshot clones is a technology that allows you to take
      point-in-time snapshots of the files on a system without causing
      the downtime inherent in traditional backups. A snapshot is not an
      independent backup of a set of data files. Rather, a snapshot is
      set of pointers to blocks of data that make up a set of files at a
      point-in-time. When a change is made, the original blocks are
      kept, and changed blocks are added. When a new snapshot is taken,
      another set of pointers is created that points to the blocks that
      make up the file at that point-in-time.
      <p>
        The term clone is used when restoring. The blocks for a selected
        snapshot are written to a new storage location as a traditional
        set of files. This set of files is considered a clone of the
        original snapshot.
      </p>
      <p>
        The benefit of snapshots and clones is the rapid accessibility
        of point-in-time data, which also allows for a quick rollback
        when data is corrupted. The disadvantage of snapshot technology
        is that it requires more storage space and may impact production
        performance during the clone process since primary data is being
        accessed.
      </p>
    </td>
  </tr>
  <tr>
    <td>Image backup</td>
    <td>
      A disk image is a single computer file or set of files that
      contain the contents of a hard disk. It is usually created by
      coping the disk sector-by-sector instead of file-by-file. A disk
      image is often called a system image, especially when it is an
      image that contains a computer operating system. Image backups are
      an important part of a backup strategy, especially after software
      or system updates are installed.
    </td>
  </tr>
</tbody>
</table>

### Off-Site and Off-System Storage Plans

You should consider having an off-site or off-system storage plan. This is especially important in cases where a natural disaster destroys the hardware and data stored locally. There are several tools that can assist you when you back up using off-site or off-system storage.

<table>
<thead>
  <tr>
    <th>Backup Tool</th>
    <th>Description</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>rsync</td>
    <td>
      The rsync tool can copy local files from/to a remote host using a
      remote shell - SSH - or a remote rsync daemon. It is a
      file-copying tool with the capability of reducing the amount of
      data transferred and making replicas, copies, and backups. To make
      it even more difficult for others to access your data, there is
      the option to harden SSH, improving security.
    </td>
  </tr>
  <tr>
    <td>nc</td>
    <td>
      The Netcat utility is a cross-platform tool for reading and
      writing data across network connections using the TCP or UDP
      protocols. It is frequently used to monitor or debug network
      connections, transfer data, or scan for open ports.
    </td>
  </tr>
  <tr>
    <td>SFTP</td>
    <td>
      SFTP (SSH File Transfer Protocol or Secure File Transfer Protocol)
      is packaged with SSH and works over a secure connection. It has
      the ability to leverage a secure connection to transfer files
      between local and remote systems. SFTP is usually preferred over
      FTP because of its security features and ability to piggyback on
      an SSH connection.
    </td>
  </tr>
  <tr>
    <td>SCP</td>
    <td>
      The SCP tool securely copies files and directories between remote
      hosts without starting an FTP session or logging into the remote
      systems. SCP uses SSH to transfer data, so it requires
      authentication, but it does encrypt both the file and any
      passwords exchanged.
    </td>
  </tr>
</tbody>
</table>

### Integrity Checks

You can check the integrity of a backup to ensure that the data has been backed up or transferred without error. One way to do this is to use a hash algorithm that produces a "fingerprint" of the downloaded file. A hash algorithm inputs the backup data and outputs a unique character string. If the source and backed-up data produce the same fingerprint, you can be confident that the data is identical. There are two hash algorithms that are commonly used to check integrity.

<table>
<thead>
  <tr>
    <th>Algorithm</th>
    <th>Description</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>MD5</td>
    <td>
      The MD5 (Message Digest Algorithm 5) algorithm produces a 128-bit
      hash value. It was originally used as a cryptographic hash
      function but was found to suffer from extensive vulnerabilities.
    </td>
  </tr>
  <tr>
    <td>SHA</td>
    <td>
      A cryptographic hash function which takes an input and produces a
      160-bit (20-byte) hash value known as a message digest, and
      typically rendered as a hexadecimal number, 40 digits long. The
      SHA (Secure Hash Algorithm) algorithm is slowly replacing the MD5
      algorithm.
    </td>
  </tr>
</tbody>
</table>
