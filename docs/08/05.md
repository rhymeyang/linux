---
lang: zh-CN
title: Section 8.5 File Systems
description: some description
---

As you study this section, answer the following questions:

<ul><li>How would you make <b >mkfs</b> automatically calculate the size of the data blocks for the file system?</li>
<li>Which command can you use to create the ReiserFS file system type?</li>
<li>How would you create and activate a swap partition?</li>
<li>Which file systems provide journaling?</li>
<li>What is the difference between the ext3 and ext4 file system types?</li></ul>

In this section, you will learn to:

- Format a hard disk with ext3 and ext4
- Create and activate a new swap partition

Key terms for this section include the following:

<table class="terms">
<thead>
<tr>
  <th>Term</th>
  <th>Definition</th>
</tr>
</thead>
<tbody>
<tr>
  <td>File system</td>
  <td>
    A system that specifies how data is organized and stored on
    storage media.
  </td>
</tr>
<tr>
  <td>Swap file</td>
  <td>
    A partition that the operating system uses as virtual memory.
  </td>
</tr>
<tr>
  <td>
    New Technology File System
    <br />
    (NTFS)
  </td>
  <td>The file system used by Microsoft operating systems.</td>
</tr>
</tbody>
</table>

This section helps you prepare for the following certification exam objectives:

<table class="objectives">
<thead>
<tr>
  <th>Exam</th>
  <th>Objective</th>
</tr>
</thead>
<tbody>
<tr>
  <td>TestOut Linux Pro</td>
  <td>
    2.1 Manage storage devices
    <ul>
      <li>Create and manage disk file systems</li>
      <li>Create and manage swap partitions</li>
    </ul>
  </td>
</tr>
<tr>
  <td>CompTIA Linux+ XK0-005</td>
  <td>
    1.3 Given a scenario, configure and manage storage using the
    appropriate tools
    <br />
    <ul>
      <li>File system management</li>
      <li style="list-style: none; display: inline">
        <ul>
          <li>XFS tools</li>
          <li>Ext4 tools</li>
          <li>Btrfs tools</li>
        </ul>
      </li>
      <li>Mounting local and remote devices</li>
      <li style="list-style: none; display: inline">
        <ul>
          <li>/etc/fstab</li>
          <li>mount</li>
        </ul>
      </li>
    </ul>
  </td>
</tr>
</tbody>
</table>

## 8.5.1 Linux File System Types

Click one of the buttons to take you to that part of the video.

Linux File System Types 00:00-00:22
In this lesson, we'll review several Linux file system types. A file system stores data on storage devices. It performs input and output operations, or I/O operations. This means it tells the kernel where the data is stored, how to access it, and where to write new information.

ext2 00:22-01:15
Let's begin by looking at the ext2 file system, or second extended file system. This system was released in 1993. It stores data in a hierarchical fashion of files, directories, and subdirectories.

The maximum ext2 file size is 2 terabytes (TB), and the maximum volume size is 4 TB. It supports filenames up to 255 characters, Linux permissions, and file compression.

The ext2 file system is a widely used Linux file system, but it has one key weakness: it takes a very long time to recover after an abrupt shutdown.

When shutting down the Linux system, the OS needs to cleanly dismount the file system. This ensures that all pending file system transactions are committed to disk before shutdown. If the shutdown happens before the clean dismount procedure is complete, it can create problems.

e2fsck 01:15-02:01
If this happens, at the next startup, the ext2 file system automatically runs e2fsck, which stands for ext2 file system check. This utility tries to fix any problems from the unexpected shutdown. If it finds unallocated files or unclaimed blocks of data, it writes that information to a special directory called lost+found in an effort to ensure data integrity.

But it takes a long time to do this. This is because the e2fsck utility will analyze the entire system. On a minimal Linux system, this can take 10-15 minutes. But on an extensive system, this process can take several hours. Having the system down so long can be a serious issue, so other people developed other Linux systems that don't have this problem.

ext3 02:01-03:25
The first of these is ext3, an updated version of ext2. Most of the file system utilities used by ext2 are used by ext3, but ext3 has the addition of the journaling process. The journaling process rectifies the unclean system shutdown by recording a transaction to the journal and marking it as pending or complete before committing the transaction to the hard disk drive.

In this example, we need to write data to a file named schedule.odt. After it's saved to schedule.odt, the ext3 file system marks the transaction as complete. The ext3 file system tracks all file transactions and keeps a log of the most recent transactions and whether they're complete.

After an abrupt shutdown, the ext3 system replays the journal when the system comes back up. This allows ext3 to verify the data on the disk and bring it back to a consistent state using the information stored in the journal. This eliminates the need to check the entire system, as ext2 does. ext3's disk recovery time is dramatically shorter, only seconds or minutes.

The disadvantage of ext3 is that the journaling process uses more system memory, so it slows down the disk I/O process slightly. Regardless, most system administrators prefer ext3 to ext2.

ext4 03:25-03:59
Now, as time went on, the ext3 file system was also updated. ext4 was released in 2008 and supports volume sizes up to 1 exabyte (EB) and file sizes up to 16 TB. You can have a maximum of 4 billion files in an ext4 file system, and the maximum filename length is 255 characters.

ext4 also uses a journal with the addition of checksums that verify the integrity of the journal file. This improves the overall reliability of the system because checksums help prevent corruption.

btrfs 03:59-05:44
Now let's change gears and look at the btr file system, or btrfs, which is a completely different Linux file system. The btrfs uses a newer storage technology called copy-on-write. It allows you to create a file system on Linux that is similar to the NSS file system that's on Novell products as well as the storage technology on later versions of Windows.

The copy-on-write technology provides storage pools and storage snapshots. A storage pool is composed of all the storage space on your storage devices. This is similar to LVM. Once you've allocated storage devices to a storage pool, you can define storage volumes from the storage pool and mount them at various mount points in the Linux file system.

For example, here, we've defined a storage volume that's mounted in /home, which is where all our user's /home directories reside. If we want to add capacity, we can install a new hard drive in the system, then allocate its space to the pool, where the volume is mounted in /home. The volume size is automatically increased without the need to resize partitions, restore data, or back up data.

btrfs also provides snapshot functionality. Snapshots protect your data by essentially taking a picture of what your data looks like at specific intervals and saving it on separate media.

For example, we have snapshots 1, 2, and 3 of storage volume 1. If a file gets lost or corrupted, we can grab the appropriate snapshot, say, number 2, and drop it back into the file system. This allows us to restore the lost file in seconds.

So, which file system should you use? That depends on your personal preference and the needs of your specific Linux deployment.

Summary 05:44-06:03
Well, that's it for this lesson. In this lesson, we discussed some of the Linux file system types you can use. We looked at ext2, ext3, and ext4. Then we ended this lesson by talking about the btr file system and how it works.

## 8.5.2 File System Creation

Click one of the buttons to take you to that part of the video.

File System Creation 00:00-00:17
In this lesson, we'll look at creating Linux file systems. Once you have storage space available through partitions in Linux, you'll need to format it with a file system to be able to utilize the available space.

Role/Function of a File System 00:17-01:33
To make a file system on a partition on a hard disk in the Linux system, use the mkfs command, which stands for make file system. You can use the mkfs utility to make an ext2, 3, or 4 file system. You can even use it to create a FAT32 or NTFS file system that would allow that partition to be used on both Linux and Windows. Note that mkfs is a front end for the actual commands used to make each file system shown here. You can find actual commands on your Linux system.

For example, to create an ext4 file system, mkfs runs the mkfs.ext4 command, same for ext3, ext2, btr file system, FAT file system, NTFS file system, and so on. You can skip mkfs and just run the specific command. These commands are listed in the /sbin directory. If you choose to do this, go to the man page for the specific command to see its syntax. Most administrators use the mkfs front end, and it works just fine.

mkfs Command 01:33-04:44
To create a new file system on a partition, you can also run the mkfs command and then use the -t option to specify the file system type instead of mkfs.. Here, we're creating an ext4 file system, which runs the mkfs.ext4 command, and then we specify the partition. Here, we'll create on /dev/sdb5.

There are several more options available with the mkfs command. For example, the -b option specifies the block size of 1024, 2048, or 4096. Generally, if you'll be storing very large files, use a large block size. If you'll be storing many small files that frequently change, then use a smaller size, such as 1024, because the larger block wouldn't use space efficiently.

You can also use the -N option to specify the number of inodes in the system. An inode stores information about a file, like the size, location, owner, and permissions. Remember that each file has its own inode except hard link files, which share inodes.

With all other Linux files having their own inode, specifying a fixed number of inodes limits the total number of files allowed on the file system. Once the limit's reached, it won't allow new file creation. The -i option is for specifying the size of the inode. By default, mkfs will size the inode to be the same as the block size, which's usually just fine.

The -j option creates a journal, but you'd only need this for an ext2 file system since newer versions already use journals. If no options are included, the default values will be used. This is often sufficient.

Defaults work well because an optimal block size and number of inodes are calculated for you based on the partition size. In this example, we're using the mkfs command to create an ext4 file system on the /dev/sdb5 partition. Here mkfs determined these optimal parameters based on the very small partition size.

Understand that the default values are automatically determined based on the partition size and will vary. Here, mkfs decided 4096 kilobytes was the best block size. The number of blocks and inodes was also determined. Please note that multiplying the number of blocks by the block size will tell you the size of the overall file system, so about 5GB here.

Also, notice that it specifies that superblock backups will be stored in the blocks listed here. The superblock's the block at the beginning of the partition called block 0. It contains information about the structure of the entire file system on that partition. Here, mkfs is placing redundant copies of this block in these locations as backups in case Block 0 has a problem.

Use mkfs to Create Non-Linux File Systems 04:44-05:32
You can also use mkfs to create an XFS file system, a fast, flexible file system that's been ported over to run on Linux. The XFS support needs to be added to the Linux kernel before you can create an XFS file system. This is done by default during the installation of a few distributions like Fedora.

You can also create non-Linux file systems with the mkfs command. For example, you can create a FAT partition or an NTFS partition. To create a FAT partition, which's readable between Linux and Windows, use the -t vfat option with the mkfs command. You can even create an NTFS file system on a partition; just use -t ntfs.

Summary 05:32-06:03
That's it for this lesson. In this lesson, we discussed file system creation on Linux partitions. First, we discussed the role and function of a file system. Then, we looked at using the mkfs command to make ext2, 3, and 4 file systems. We ended this lesson by discussing how you can use mkfs to create non-Linux file systems, such as FAT or NTFS.

## 8.5.3 Swap Area Management

Click one of the buttons to take you to that part of the video.

Swap Area Management 00:00-01:32
In this lesson, we'll discuss using swap partitions. You can format a swap partition in a Linux system and use it for virtual memory. You do this using the mkswap command. Using virtual memory allows your system to run more programs than you have physical space for.

For example, here, we have a Linux system. The green box represents the total amount of RAM installed in the system. The operating system uses a lot of the available RAM to run, and each application also uses some memory.

Now, most of the physical memory is being consumed. Let's suppose we need to run another program that needs more memory than we have left. To make this work, Linux analyzes the processes that are currently running in memory, selects the processes that are idle, and moves them out of physical RAM and onto a hard disk drive. This maps memory locations that don't exist in the physical memory to a partition on a hard drive.

The swapped processes continue to function as if they were moved to a different memory location, not to a hard drive. Since the disk is much slower than physical memory, it's a good place for idle processes to run, and we get more physical space for the new application we want.

Now, if this red application needs to be used again, it's swapped back into physical memory, and another idle process is moved to the swap area. You can see how the swap area gets its name—processes move in and out constantly, which allows the system to run more processes than its physical RAM can support.

Multiple Swap Areas 01:32-02:06
Linux systems allow either a partition or an entire hard disk to be used for the virtual memory. The entire drive is usually too much space. Instead, we define a partition on the hard drive and use it for virtual memory. It's possible to have multiple swap partitions, and this can be beneficial if they're on multiple storage devices.

Here, we'll put an extra hard disk in the system and define a swap area on it and on the main hard disk. Now, the system has two swap areas. If this is a heavily used system, its performance will speed up quite a bit now.

The mkswap Command 02:06-02:51
To use a virtual memory partition for swapping, you need to prepare it with the mkswap command. Start by creating the partition and set the partition type for swapping to type 82 if you're using fdisk or 8200 if you're using gdisk. The default when using fdisk or gdisk is to create a type 83 partition, which is a Linux data partition. So be sure to change it to 82 or 8200.

mkswap's syntaxt is shown here. Enter mkswap plus the device file name for the partition you want as the swap partition. For example, for the logical partition sdb6, enter mkswap and then the device file name, /dev/sdb6.

The swapon Command 02:51-03:33
After you use the mkswap command to create the swap partition, use the swapon command to activate it. Enter swapon plus the name of the swap partition. Here, we'll enter swapon /dev/sdb6.

To view a listing of the swap areas that are defined and enabled on your system, use the swapon command with the -s parameters. Here, you can see there are two swap partitions on two storage devices.

This also shows the priority of the devices. The device with priority -1 is assigned primary usage, and the device with -2 priority is used secondarily if the primary device is busy.

The swapoff Command 03:33-04:03
If you need to disable a swap area, use the swapoff command followed by the device file name of the swap partition. If you have multiple swap partitions to activate, you can use the swapon -a command to activate them all at the same time. This will go through your /etc/fstab file to activate any swap partitions within it. You can also disable all the swap partitions at the same time using the swapoff command with the -a option.

Summary 04:03-04:20
That's it for this lesson. In this lesson, we reviewed how to manage swap areas on a Linux system. First, we looked at the mkswap command, and then we reviewed the swapon and swapoff commands.

## 8.5.4 Mounting Standard Partitions

Click one of the buttons to take you to that part of the video.

Mount a File System 00:00-00:17
In this demonstration, we're going to review how to mount and unmount a file system from the command line. We'll also talk about adding entries to the fstab file and how to mount and unmount LVM logical volumes.

Mount File Systems from the Command Line 00:17-03:34
Let's run the sudo fdisk command with the -l option. This will list the drives attached to my system. We see that /dev/sda contains my Linux operating system. We'll want to run sudo fdisk -l on /dev/sdb to view a list of the partitions that have currently been defined on this second hard disk drive in my Linux system.

We have sdb1 and sdb2, which are standard Linux data partitions. The file systems have been created on the partitions, but we can't save data on them because the partitions are not mounted in the Linux file system.

File systems are mounted within directories in the file system hierarchy. They are not assigned drive letters as you would see in Windows. In Windows, if you added a hard disk with two partitions on it to the system, by default, you would see two drive letters added to Windows Explorer, drive D and drive E.

It's different in Linux. We have a single file system. All of our partitions are mounted somewhere in that file system. We want to change directories to the /mnt directory. Mnt is short for mount. Most distributions provide a mount directory by default. Its purpose is to do as its name implies: it's a place to mount file systems.

We want to create two subdirectories within /mnt to mount each partition to. Let's create a directory called shared within /mnt and a directory called private. If we run ls, we see that private and shared are defined within the mount directory.

There are two ways we can mount these partitions in their directories. One is from the command line with the mount command. We can run sudo mount -t followed by the type of file system on the partition we're going to mount. In this case, we're going to mount sdb1, which has an ext4 file system.

Next, we specify the device path for the partition that we want to mount. Type /dev /sdb1. Lastly, we specify where we want the partition mounted. We type /mnt/shared. Hit Enter, and this partition is mounted in the shared directory we created.

When we cd to the /mnt/shared directory, we've actually switched to a completely different hard disk partition. My Linux system is installed on the sda hard disk drive. While in the /mnt folder in the terminal, I was on a partition in sda. By changing to the shared directory we created, I've switched over to the mounted partition on sdb. Therefore, any data that's store in the /mnt/shared directory will be stored on the sdb hard disk drive.

Let's mount the second partition. Run sudo mount -t ext4 /dev/sdb2. This time, we want it mounted in /mnt/private. We can check the status of mounted file systems using the mount command with no options. Just enter mount.

When we do, we see that /dev/sdb1 is mounted in the directory we specified with an ext4 file system, and /dev/sdb2 is mounted in /mnt/private with an ext4 file system.

Unmount File Systems from the Command Line 03:34-05:19
Okay. Next, we're going to talk about unmounting partitions. This is commonly done if you're using removable external storage devices like a thumb drive or an external USB drive.

Let's first unmount the /dev/sdb1 file system. This will unmount it from the /mnt/shared directory, making any data that's on that partition inaccessible. Enter sudo umount and then enter the name of the device file for the partition, /dev/sdb1, and press Enter. When we run sudo mount, we see that sdb1 is no longer mounted in the /mnt/shared directory.

With the umount command, you can either specify the device file, or you can specify the name of the directory where that partition is currently mounted. In this case, we're going to unmount sdb2 by entering sudo umount /mnt/private.

Run the mount command. We see both partitions are unmounted. Any data that was saved on those partitions will not appear until the partitions are mounted again. We can switch into the /shared directory and run an ls command. Because we haven't mounted that partition in that directory, we're actually looking at data on sda, our Linux system drive.

This one can be confusing for new Linux users. Once the umount command has been executed, the /shared directory becomes a normal, regular directory on the default partition where it's located. If files are saved to this directory and then we mount a partition into that same directory, the files that were stored originally will not be accessible anymore. They're still saved on sda; they're just not accessible because we have mounted a different partition into that directory. As soon as we umount that partition, then the original files saved in that directory, sda, will become available.

Summary 05:19-05:32
And that's everything for this demo. In this demonstration, we talked about how to mount and unmount a Linux file system from the command line.

## 8.5.5 Mounting LVM Partitions

Click one of the buttons to take you to that part of the video.

Mount a File System 00:00-00:11
In this demonstration, we're going to discuss how to mount and unmount a LVM Logical Volume from the command line.

Mount LVM Logical Volumes 00:11-02:09
This Linux system has two LVM hard disks installed, sda and sdb. We're going to run sudo lvscan. We have a volume group named LVM-Demo. Within the LVM-Demo volume group, we have two volumes defined, shared and private.

The ubuntu-vg volume group was created by default when the system was initially installed. The two volumes we have in the LVM-Demo volume group have ext4 file systems defined on them, but they're not mounted. We can mount these into the file system like a standard disk partition.

Let's use sudo mkdir to make two directories in /mnt. The first one is named sharedlvm, and the second is named privatelvm. The directory name does not have to match the LVM volume name. We can name these directories however we like.

Now we run the sudo mount command. We use the -t option, then ext4 to specify the file system. Then we specify the device file for the LVM volume found in the /dev directory.

Things are a little different when dealing with LVM. Instead of specifying a physical partition, such as /dev/sdb1, we instead specify /dev and the name of the volume group where the volume resides, in this case LVM-Demo, and then the name of the volume itself, LVM-Shared.

We need specify where we want to mount the volume group in the file system, /mnt/sharedlvm. Let's run the command again for the private volume. Enter sudo mount -t ext4 /dev/LVM-Demo/LVM-Private. We want the LVM mounted in /mnt/privatelvm. Press Enter. When we run the mount command, we see that two logical volumes have been mounted in the Linux file system. When we switch to those directories, we're able to store data within those volumes.

Unmount LVM Logical Volumes 02:09-02:48
Next, we'll look at unmounting LVM Logical Volumes. With the umount command, you can either specify the device file or the name of the directory where that partition is currently mounted.

First, we're going to unmount the shared LVM. Type sudo umount /dev/LVM-Demo/LVM-Shared and press Enter. We're going to use the mount directory to unmount the private LVM. Type sudo umount /mnt/privatelvm. When we run the mount command, we see that both LVMs have been unmounted. We will be unable to access data saved to those LVMs while they were mounted.

Summary 02:48-03:01
And that's a wrap for this demo. In this demonstration, we talked about how to mount and unmount LVM logical volumes.

## 8.5.6 Adding Entries to /etc/fstab

Click one of the buttons to take you to that part of the video.

Mount a File System 00:00-00:10
In this demonstration, we're going to review how to permanently mount a file system using the fstab file.

Add an Entry Using the fstab File 00:10-02:31
Partitions loaded via the mount command are only persistent as long as the system stays running. On reboot, any mounted partitions or drives will be gone. Therefore, if we want the file system to be mounted persistently across system reboots, we have to add an entry to the /etc/fstab file. Open the file using sudo with a text editor. There's default file mounting specified in the file. These lines are for loading the Linux operating system from the hard drive. Exit the text editor.

Let's run the sudo lsblk command. This'll list the drives attached to my system. We see that /dev/sdb has two partitions: sdb1 is our partition for shared files, and sdb2 is our partition for private data. Open the fstab file in a text editor. Add a new line and an additional entry that'll mount sdb1 and sdb2 every time the system boots.

We enter the device filename for the partition. We start with /dev/sdb1, then a tab. Then we enter the name of the directory where we want the partition mounted /mnt/shared, then another tab.

We specify the file system type we want to use, ext4, and enter another tab. Then type defaults. defaults specifies that the basic default mount options will be used, meaning the partition will be mounted as read and write.

Then we enter a one (1) and a space, then a two (2). This one specifies that the file system can be dumped. If you have a zero, such as here with our Linux file system, it means the file system isn't allowed to be dumped. The two specifies the order in which the file systems should be checked whenever the system boots up.

The root partition, as we see, should have a value of one in this field. All other file systems should have a two because the root file system is the one where the operating system is installed. We're going to use a two for this file system.

Let's add an entry for our other partition, /dev/sdb2. We want it mounted in /mnt/private. It uses the ext4 file system. We'll use our defaults mount options and the same numbers for dumping and the file system checking.

Write changes to the file, and we've finished configuring the fstab file. The two entries will automatically mount the two partitions in the directories when the system boots.

Summary 02:31-02:42
In this demonstration, we talked about how to mount a Linux file system by adding entries to the fstab file.

## 8.5.7 File System Management Facts

The file system determines how a computer's files are organized on a hard drive.

This lesson covers the following topics:

- Linux file system types
- Formatting commands
- File system tips

### Linux File System Types

Linux supports many different file system types. The following table describes several common file systems.

<table>
<thead>
<tr>
  <th>Type</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>ext2</td>
  <td>
    The Second Extended File System (ext2) is one of the oldest Linux
    file systems still available.
    <ul>
      <li>
        ext2 stores data in a standard directory and file hierarchy.
      </li>
      <li>The maximum file size supported is 2 TB.</li>
      <li>An ext2 volume can be up to 4 TB in size.</li>
      <li>File names can be up to 255 characters long.</li>
      <li>Linux users, groups, and permissions are supported.</li>
      <li>
        ex2 does not use journaling (which is used in most modern file
        systems). As a result, ext2 takes a long time to recover if
        the system shuts down abruptly.
      </li>
    </ul>
  </td>
</tr>
<tr>
  <td>ext3</td>
  <td>
    The Third Extended File System (ext3) is an updated version of
    ext2 that supports journaling.
    <p>
      Before committing a transaction to a storage device, the ext3
      file system records the transaction to the journal and marks it
      as incomplete. After the disk transaction is complete, the file
      system marks the transaction as complete in the journal. By
      doing this, ext3 can keep track of the most recent file
      transactions and whether or not they were completed. This allows
      ext3 to recover much more quickly than ext2 in the event of an
      unclean system shutdown.
    </p>
  </td>
</tr>
<tr>
  <td>ext4</td>
  <td>
    ext4 is the fourth generation file system in the ext file system
    family. ext4 includes all of the features found with ext2 and ext3
    with the addition of the following features:
    <ul>
      <li>
        Support for file sizes up to 16 TB and disk sizes up to 1
        exabyte (EB).
      </li>
      <li>Supports up to four billion files in the file system.</li>
      <li>
        Uses checksums to verify the integrity of the journal file
        itself.
        <div>
          <div>
            <div>
              <div class="to-icon large" aria-hidden="true" style="width: 20px">
                <svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div>                          
              <div class="to-info-box-body-content">
                <span>
                  Checksums help improve the overall reliability of
                  the system because the journal file is the most
                  heavily used file of the disk.</span>
              </div>
            </div>
          </div>
        </div>
      </li>
    </ul>
  </td>
</tr>
<tr>
  <td>swap</td>
  <td>
    A swap file system is used as virtual memory (the portion of the
    hard disk used to temporarily store portions of main memory) by
    the operating system.
    <div>
      <div>
        <div>
          <div class="to-icon large" aria-hidden="true" style="width: 20px">
            <svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div>                      
          <div class="to-info-box-body-content">
            <span>
              A recommended practice is to make the swap file size
              between 1 and 1.5 times the amount of memory on the
              computer.</span>
          </div>
        </div>
      </div>
    </div>
  </td>
</tr>
<tr>
  <td>NTFS</td>
  <td>
    Microsoft operating systems use NTFS (New Technology File System).
    Linux provides limited support for NTFS.
  </td>
</tr>
<tr>
  <td>VFAT</td>
  <td>
    VFAT is a FAT32 file system for Linux and does not support
    journaling. VFAT includes long name support. Support for VFAT must
    be compiled into the kernel for the system to recognize the VFAT
    format.
  </td>
</tr>
<tr>
  <td>XFS</td>
  <td>
    <p>
      The XFS file system was developed for the Silicon Graphics IRIX
      operating system. An XFS file system is proficient at handling
      large files, offers smooth data transfers, and provides
      journaling. It also can reside on a regular disk partition or on
      a logical volume.
    </p>
  </td>
</tr>
<tr>
  <td>Btrfs</td>
  <td>
    Btrfs is a Linux file system that uses a copy-on-write file
    system. Using copy-on-write technology, Btrfs provides several key
    features not found in earlier file systems, including storage
    pools and snapshots.
    <ul>
      <li>
        Instead of using traditional disk partitions, Btrfs allows you
        to create storage pools from the storage devices in your
        system. From the storage pool, you can then allocate space to
        specific storage volumes. Instead of mounting partitions, you
        mount storage volumes at mount points in the file system.
      </li>
      <li>
        The snapshot functionality provided by Btrfs protects data. It
        can be configured to take snapshots of your data at specified
        intervals and save it on separate media. If a file ever gets
        lost or corrupted, you can restore a previous version of the
        file from a snapshot.
      </li>
    </ul>
  </td>
</tr>
</tbody>
</table>

### Formatting Commands

A disk partition must be formatted using a file system. The following table describes the commands needed to format a partition.

<table>
<thead>
<tr>
  <th>Command</th>
  <th>Function</th>
  <th>Example</th>
</tr>
</thead>
<tbody>
<tr>
  <td><strong>mkfs</strong></td>
  <td>
    Creates an ext family file system or a fat file system. The
    <b>mkfs</b> command uses the following options:
    <ul>
      <li>
        <b>-t <i>[file_system_type]</i></b>
        determines the file system. File system types include:
        <ul>
          <li>
            <b>ext2</b> (identical to the <b>mkfs.ext2</b> command)
          </li>
          <li><b>ext3</b> (identical to <b>mkfs.ext3</b> )</li>
          <li><b>ext4</b> (identical to <b>mkfs.ext4</b> )</li>
          <li><b>vfat</b> (identical to <b>mkfs.vfat</b> )</li>
        </ul>
      </li>
      <li>
        <b>-b</b> specifies the block size. Supported values are 1024,
        2048, or 4096.
      </li>
      <li>
        <b>-i</b> determines how many inodes are on the partition and
        uses the same values as <b>-b</b> .
      </li>
      <li><b>-j</b> appends a journal to an ext2 file system.</li>
    </ul>
    <div>
      <div>
        <div>
          <div class="to-icon large" aria-hidden="true" style="width: 20px">
            <svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div>                      
          <div class="to-info-box-body-content">
            <span>
              Without the <b>-b</b> and <b>-i</b> options,
              <b>mkfs</b> calculates the optimal values for you
              automatically.</span>
          </div>
        </div>
      </div>
    </div>
  </td>
  <td>
    <ul>
      <li>
        <b>mkfs -t ext2 /dev/sda4</b> creates an ext2 file system on
        the fourth partition on the first hard disk drive.
      </li>
      <li>
        <b>mkfs -t ext3 /dev/sda1</b> creates an ext3 file system on
        the first partition on the first hard disk drive.
      </li>
      <li>
        <b>mkfs -t ext3 /dev/sdc2</b> creates an ext3 file system on
        the second partition on the third hard disk drive.
      </li>
      <li>
        <b>mkfs -t ext4 /dev/sdb1</b> creates an ext4 file system on
        the first partition on the second hard disk drive.
      </li>
    </ul>
  </td>
</tr>
<tr>
  <td><strong>mkswap</strong></td>
  <td>
    Creates a swap partition. A swap partition is the location on the
    hard drive where an operating system writes memory information
    when it runs out of RAM.
    <ul>
      <li>
        The <b>swapon</b> command must be run to activate the swap
        partition.
      </li>
      <li>
        The <b>swapoff</b> command is used to deactivate swap
        partitions.
      </li>
    </ul>
    <div>
      <div>
        <div>
          <div class="to-icon large" aria-hidden="true" style="width: 20px">
            <svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div>                      
          <div class="to-info-box-body-content">
            <span>
              Both <b>swapon</b> and <b>swapoff</b> use the
              <b>-a</b> option to enable or disable all swap
              partitions listed in <b>/etc/fstab</b> .</span>
          </div>
        </div>
      </div>
    </div>
  </td>
  <td>
    <ul>
      <li>
        <b>mkswap /dev/sda2</b> formats the second partition on the
        first hard drive as the swap partition.
      </li>
      <li>
        <b>swapon /dev/sda2</b> activates the second partition on the
        first hard drive as the swap partition.
      </li>
      <li><b>swapon -a</b> activates all swap partitions.</li>
      <li>
        <b>swapoff /dev/sda2</b> deactivates the second partition on
        the first hard drive as the swap partition.
      </li>
      <li><b>swapoff -a</b> deactivates all swap partitions.</li>
    </ul>
  </td>
</tr>
<tr>
  <td><strong>mke2fs</strong></td>
  <td>
    Create an ext2, ext3, or ext4 file system. Command options include
    the following:
    <ul>
      <li>
        <b>-b</b> specifies the block size of the file system in bytes
        (valid sizes are 1024, 2048, and 4096 bytes per block).
      </li>
      <li><b>-j</b> creates the file system with an ext3 journal.</li>
      <li><b>-L</b> sets the volume label for the file system.</li>
      <li>
        <b>-n</b> displays what <b>mke2fs</b> would do if it created a
        file system, but does not actually create the file system.
      </li>
      <li>
        <b>-t</b> specifies the file system type (such as ext2, ext3,
        or ext4) to be created.
      </li>
    </ul>
  </td>
  <td>
    <ul>
      <li>
        <b>mke2fs /dev/sda2</b> creates an ext2 file system on the
        second partition on the first hard disk drive.
      </li>
      <li>
        <b>mke2fs -j /dev/sda1</b> creates an ext3 file system on the
        first partition on the first hard disk drive.
      </li>
      <li>
        <b>mke2fs -t ext4 /dev/sdc3</b> creates an ext4 file system on
        the third partition on the third hard disk drive.
      </li>
    </ul>
  </td>
</tr>
</tbody>
</table>

### Files System Tips

Keep the following in mind when working with file systems:

<ul>
<li>
  You cannot format an extended partition. However, you can create
  logical partitions inside an extended partition and format them.
</li>
<li>
  File systems use an inode (information node) table to store
  information about files. An inode specifies where a file's data
  physically exists on a disk. Inodes also contain additional
  information, including:
  <ul>
    <li>File size</li>
    <li>Modification, access, and creation times</li>
    <li>Permissions</li>
    <li>Ownership</li>
  </ul>
</li>
<li>
  Each file system has a superblock, which contains information about
  the file system, such as:
  <ul>
    <li>File system type (such as ext2 and ext3)</li>
    <li>Size (for example, 10GB or 360GB)</li>
    <li>Status</li>
  </ul>
</li>
<li>
  Linux maintains multiple redundant copies of the superblock in every
  file system.
</li>
</ul>
