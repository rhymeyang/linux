---
lang: zh-CN
title: Section 2.12 Locating and Searching Files
description: some description
---

As you study this section, answer the following questions:

<ul><li>What are the advantages to using <b >locate</b> over <b >find</b> ? What are the disadvantages?</li>
    <li>When would you use the <b >which</b> command to locate a file?</li>
    <li>Which command can you use to locate a file?</li>
    <li>Which command can you use to locate a command and get information about it?</li>
    <li>What does it mean when a command is hashed?</li>
    <li>How can you discover a command's category?</li>
<li>Which commands can you use to search for text within files?</li></ul>

In this section, you will learn to:

<ul><li>Find Linux commands</li>
    <li>Find files</li>
    <li>Find file content</li>
<li>Use grep</li></ul>

This section helps you prepare for the following certification exam objectives:

<table class="objectives">
   <thead><tr><th  >
     Exam</th>
    <th >
     Objective</th></tr></thead>
   <tbody><tr><td>TestOut Linux Pro</td>
     <td>1.1 Use command line utilities
      <ul><li>View, search, and edit the contents of text files</li></ul>
      <p>2.2 Mange the file system</p>
      <ul><li>View information about directories and files in the file 
				system</li></ul></td></tr>
    <tr><td>CompTIA Linux+ XK0-005</td>
     <td>3.1 Given a scenario, create simple shell scripts to automate common tasks
      <br>
      <ul><li>Shell script elements
        <ul><li>Shell parameter expansion
          <ul><li>Globbing</li></ul></li>
         <li>Regular expressions</li></ul></li>
       <li>Shell built-in commands</li>
       <li>Common script utilities</li>
       <ul><li>find</li>
        <li>grep</li>
        <li>egrep</li></ul></ul></td></tr></tbody></table>

## 2.12.1 File Location Utilities

### File Location Utilities 00:00-00:13

In this lesson, we'll look at the variety of utilities that you can use to search for files in the Linux file system. Let's start with the find utility.

### The find Command 00:13-01:54

The syntax is shown here. First, enter find at the shell prompt, and then specify where the search will be conducted. In this example, we specified /home. By default, the find command will look for the specified file in /home and all the subdirectories of /home and any subdirectories in the subdirectories. We use the -name parameter to specify the file we want.

In this case, we're looking for a file named files.txt. The find command will search in home and then all its subdirectories for a matching file name. The output will report where it found any matching files. In this example, it found it in /home/rtracy.

You can also use regular expressions with find for a more general search. For example, we want to find all log files stored on the system, assuming all log files have a .log extension. So, we enter find and then specify where to search. In this case, we want to search the entire file system for any file with a .log extension. So, we specify the search location as just / because that's the top of the file system tree. By starting there, find will search the root and all subdirectories, subdirectories of subdirectories, and so on. Then we use the -name parameter to specify what we want to find with \*.log. Now star is an example of a regular expression. That means to match any file name that ends with .log. Here we see that it found several files that end in .log and outputs their location and file names.

### The find Options 01:54-02:25

The find utility includes many other options you can use to make searching more flexible. You can go to the find utilities man page to see all the options. Two useful ones are listed here. First is the -user option. Use this to search for files that are owned by a specified user.

The second is the -size option which is used to search for files of a specified size. You can specify a fixed size or smaller or larger than a certain size.

### The `locate` Command 02:25-02:53

In addition to find, you can use the locate utility to search for Linux files. Even though the locate utility is similar to the find command, it produces results faster. This is because it works differently. The find command looks through every directory in the path that was specified. The locate command first builds an index of all files in the system, so when a search is run, it looks at its index. This is much more efficient.

### Install `locate` 02:53-06:07

Before you can use the locate utility, you need to install it on the system. Make sure the find utils package is installed on your system. You can install it manually using RPM, dpkg, zypper, or Yum/dnf. Once installed, create an index of all files in the file system. The index is called `locatedb` and is stored in the /bar/log directory. The file system will change periodically, making an update to the index necessary. An update happens by default daily.

If you need the index updated more often, you can use the updatedb command in the shell prompt. Because updatedb does all the legwork for the locate utility, it can take a long time to complete and uses many resources during the process.

Once the index is populated, you can use the locate command to search for files. The syntax using the locate command is shown here. First, we ran the locate command, then we specified the file we want to find. In this example, we're searching for the sshd_config file. The locate command searches the index for that text string in a file name.

And here it returned two files. It found the `/etc/ssh/sshd_config` file, as well as the man page for that file because its file name contains the search term of sshd_config.

You can use the /etc/updated.com file to configure the behavior of the updatedb utility. For example, the PRUNEFS directory within this file can be used to specify files you want to be excluded from scanning and the index.

For example, here we have the cifs file, which refers to Windows shares that've been mounted locally in the file system using the Samba service. We're essentially mapping a drive to a share on a Windows server. We don't want the locate utility to index the files on that share, and since the file system used to mount that share is a cifs file system, we'll exclude it from the list of file systems the updated command will include in the index.

Also, notice that we have iso9660 listed in the list. This prevents updatedb from indexing files on removable optical disc drives. We do this because we don't want removable drives that can be changed frequently to be included. The PRUNEPATHS directive can create a list of directories in the file system that you want updatedb to skip when scanning.

Notice that the /media and /mnt directories were included in this list because removable external devices can be mounted into these directories. These file systems will change frequently, so it doesn't make sense to include them in the index. We have the same situation with /var/spool/cups. This is where print jobs are queued and will often be changing.

### The `which` Command 06:07-06:30

Let's switch gears here now and talk about the which command which is used to display the full path to a particular shell command or utility. For example, to find out where the ls command resides in the file system, just type which ls at the shell prompt. It returns the full path to the ls command, which is /bin/ls.

### The `whereis` Command 06:30-06:56

You can also use the whereis command to find files. You can use the whereis to locate several key pieces of information about a file, such as the source code, the binary executable file itself, and the manual page of the file. In this example, I ran the whereis ls command at the shell prompt, and the output shows the executable location and the man pages for that command's location.

### Summary 06:56-07:18

Well, that's it for this lesson. In this lesson, we discussed finding files with either the find command or the locate command. Then, we talked about how you can use the which command or the whereis command to find information about a particular shell command or utility.

## 2.12.2 Finding Linux Commands

### Identify Linux Commands 00:00-00:09

In this demonstration, we're going to look at shell prompt utilities you can use to search for Linux commands.

### The `which` Command 00:09-01:19

Let's begin with the which command. This works to locate the executable file for a particular Linux command. In other words, which searches through directories in the PATH environment variable to locate particular commands. Let's enter echo $PATH in the shell prompt to view the directories in our PATH environment variable. We see a list of directories—each separated by a colon—that are contained in the PATH environment variable.

The which command looks in each of these directories and finds the executable file for the command that I specify. If a match is found, the appropriate directory pops up for me. Let's enter which java. This tells which to look through the PATH directories and find the executable file for the java command. Press Enter, and it locates that executable in /user/bin. So you know, when we run the java command, we're running the /user/bin/java executable file. We can do the same thing with other commands.

And one thing to be conscious of: the which command only looks in the directories specified in the PATH environment variable. It doesn't look anywhere else in the file system, so which won't find files that don't reside in PATH variable directories.

### The `whereis` Command 01:19-01:54

Another utility that searches for information about a Linux command is the whereis utility. It performs a similar function to which, but displays more information. For example, whereis displays the location of the command's executable, but it also displays the command's man page location. It can also tell you where the command's source code is.

Let's run whereis ln to find information about the ln command. We have the directory where ln resides. We also see the associated man pages and where they're located. Source code information isn't displayed, though, because sources aren't installed on this system.

### The `type` Command 01:54-04:12

The last one we're going to look at is the type utility. It analyzes a command and identifies whether it's an alias, function, keyword, or built-in command. There are commands that are built in to the shell itself, and these ones don't have an executable file in the file system. They're built directly into the shell's code. In addition to a built-in command, it could also be an external command. The ln command that we looked at earlier is an example of this since it has an executable somewhere else in the file system. The command you type in could also be an alias, in which case, the alias itself won't have a file in the file system. The alias points to another command located somewhere else.

Let's enter type to see some information about the cd—standing for "change directory"—command. Now, cd is one that's built in to the shell itself. There's no external executable. Let's run type again and look for information about the ln command. Like we talked about, ln is one that's not built in to the shell. It's an external command with an executable that resides in the file system.

For external commands, there's a possibility that you'll see different output from the type command. You should be aware of these. When we looked for ln, type reported back the directory where that command resided. Let's run type again and search for information about the vi command. Again, we see that type tells us where the vi command is located in the file system.

Okay, let's load vi and exit out without making any changes. Run type vi again. So, type still supplies the PATH to the vi command, but also tells us that it's been hashed. This means that the command has recently been run, and its location is now stored in the shell's hash table. Since type already knows where the command is, it doesn't have to search through the directories in your PATH environment variable to find it.

Here's another example. Run alias to see a list of all the alias commands that are defined on the system. We see that running ll runs the ls -l command, and running lll runs ls -al. These are aliases that are defined when the system starts. Okay, let's do type lll. We're told that lll isn't a command, but an alias that points to ls -al. This is verified in the output of the alias command that we ran earlier.

### Summary 04:12-04:28

That's all for now. In this demo, we looked at several shell utilities that can find useful information about Linux commands for us. Those were the which, whereis, and type commands.

## 2.12.3 Finding Files

### Finding Files 00:00-00:10

In this demonstration, we're going to look at several Linux shell utilities you can use to find files on your system.

### find Utility 00:10-04:29

Let's begin with find. The find utility is used to search the Linux file system to locate a particular file. For example, let's take a look at the contents of my home directory. I'm currently in the /home/testout directory. Here, you can see a listing of all the different files within this directory. Let's suppose that we need to search for the logfile.txt, right here. We've created this log file at some point, and now we can't remember where it's located. Since we've forgotten the location, let's try to locate it with the find utility.

The syntax is to type find and then specify where you want to start searching from. By default, the find utility begins at the directory you specify and then searches through all of the subdirectories beneath that search location. For example, if I wanted to search the entire file system, I could specify a / and the name of the file that I want to search for. This search will take a long time to complete because it's going to have to go through lots of directories. In this case, though, let's suppose that we know we created it in some home directory. We just can't remember which one.

So let's constrain our search to /home. Using this syntax, the find command will start its search in /home and will look in all its subdirectories as well. This will greatly decrease the amount of time it takes for this command to run. Next, we need to specify what we want to search for. find can search for a lot of different file attributes, one of which is filename. If we want to search by name, we use the -name option. Then we specify the name of the file that we want to look for, such as logfile.txt. This tells find to begin searching in the /home directory and then to search through all the subdirectories of /home for logfile.txt.

It's not a bad idea to put the name of the file that you're searching for in quotes. Here's the issue: if the filename you're looking for doesn't contain spaces, you can get away with no quotes. But if it does have space, definitely enclose the entire name in quotation marks. Otherwise, the find utility is going to be confused as to what it is you're actually asking it to do. Okay, press Enter, and it goes through and searches /home and all the subdirectories—and it locates the file in question. In addition to filename, the find command can also search through regular expressions, meaning that the utility will try to find all the files that match that regular expression, not just one particular filename.

Within the subdirectories of /var, there are a variety of different log files. I want to search for all of the files that end with a .log extension, meaning that I'm looking for a lot of different files that all have the same extension. We're going to specify where exactly we want the search to start. Let's start in /var. Then we type -name to specify the search for a particular filename. Then we specify a regular expression instead of the filename itself. In this case, we'll do a very simple one. We'll use a \*.log. The star there is a wildcard, meaning that any filename that ends in .log will be matched, and find will display the results on screen. Since this directory might require higher privileges to read, we'll make sure to use sudo. Once we run this, it prompts us for your password. You can see that several files in the /var directory match because they all end in .log.

In addition to locating files based on filename, the find command can also be used to locate files that are owned by a particular user. To do this, we enter find and specify where we want to start searching—just like before. Let's look in the /home directory, which will search /home and all of its subdirectories again. We just specify -user instead of -name. We're only concerned about the file owner, so we'll enter the name of the user that we want to locate. We'll find all the files that are owned by the testout user in /home and all of its subdirectories. Okay, press Enter. And here, you can see all of the files that are owned by the testout user. Go ahead and clear the screen. In addition to find, you can also use another utility called locate to find files in Linux.

### locate Utility 04:29-06:00

The locate utility works quite differently. Instead of explicitly searching through the file system each and every time you run the command, locate builds its own initial database that contains an entry for every single file in the file system. So when you run a search using locate, it'll actually search within the database itself, not the file system—which runs much faster. Be aware that before you can use the locate command, you have to have it installed on your system. Some distributions install locate by default—others don't.

If we try running the command right now as locate logfile.txt, it doesn't work. However, they're really helpful here and tell us which package to install. Let's go ahead and install this one. It might prompt you to say yes or no to the installation. Okay, now that locate is installed, we need to build the database. If this isn't done, there's obviously no information to search.

To manually trigger this, you type updatedb. You can see that this does require sudo, so we'll rerun the command with sudo this time. This doesn't have to be done all the time, as it's usually a scheduled task. If we run the same command as we did before, we see that it works.

When I use the locate command with the word vim, you can see that there are many files that have vim in the filename, which are related to the vim file editor. The nice thing about locate is that it has the ability to look for all files with one name, even if you don't have the full filename.

### Summary 06:00-06:16

And that's it for this demonstration. In this demo, we talked about how to find files on Linux. First, we looked at using the find command. Then we looked at using the locate command to find files as well.

## 2.12.4 File Search Facts

A Linux administrator must possess the skills to find the location of files in a file system.

This lesson covers the following topic:

- Commands to find a file

### Commands to Find a File

Use the commands in the following table to find file locations.

<table><thead><tr><th>Command</th>
<th>Description</th>
<th>Examples</th></tr></thead>
<tbody><tr><td><b >find</b></td>
<td>Searches through all files based on the file system by name, file size, time created, and other options. Be aware of the
following <b >find</b> command options:
<ul><li><b >-name</b> locates a file or directory by name in a specific path. When using <b >-name</b> :
<ul><li>Enclose name strings in single quotes.</li>
<li>Use wildcards for partial names.</li>
<li>Use <b >-iname</b> to ignore case.</li></ul></li>
<li><b >-user</b> finds files owned by a specific user.</li>
<li><b >-size</b> finds files of a specific size. Use the following options:
<ul><li><b >c</b> for bytes</li>
<li><b >k</b> for kilobytes</li>
<li><b >M</b> for megabytes</li></ul></li>
<li><b >-mtime</b> finds files last modified before or after a specified number of days ago.</li>
<li><b >-type [ <i >f</i> or <i >d</i> ]</b> specifies whether to find files or directories.</li>
<li><b >-maxdepth</b> specifies how many levels down to search.</li>
<li>- <b >print0</b> finds filenames with spaces.</li>
<li><b >-o</b> specifies the <i >or</i> parameter when searching with multiple criteria.</li>
<li><b >.</b> (period) specifies the search locations as the current directory and subdirectories.</li></ul></td>
<td><ul><li><b >find /user/home -name '*.txt'</b> finds all files with an extension of .txt in the /user/home directory.</li>
<li><b >find / -name '*paper*'</b> looks through the entire directory for any filenames or directory names that
contains "paper" (e.g., termpaper.odt or wallpaper.jpg).</li>
<li><b >find /user/home -size -300k</b> finds all files in the /user/home directory smaller than 300 K.</li>
<li><b >find /user/home -size +300k</b> finds all files in the /user/home directory larger than 300 K.</li>
<li><b >find /user/home -mtime -5</b> finds all files in the /user/home directory modified within the last five days.</li>
<li><b >find / -type f -name '*paper*'</b> finds only filenames that contain "paper".</li>
<li><b >find / -type d -name '*paper*'</b> finds only directory names that contain "paper".</li>
<li><b >find -maxdepth 3 / -name '*.txt'</b> finds .txt files three directory levels down from the root
directory.</li>
<li><b >find -print0 -name '*.txt'</b> finds .txt files with spaces in the name (e.g., myreport.txt and my
report.txt). Without the - <b >print0</b> option, only files without spaces are listed.</li></ul></td></tr>
<tr><td><b >locate</b></td>
<td>Searches for files in the file system. The <b >locate</b> utility maintains a database containing a listing of all the files
and directories in the file system. Be aware that the <b >locate</b> command:
<ul><li>Searches through an index instead of the actual file system. Because of this, the locate command usually runs much
faster than the find command.</li>
<li>Searches all files if no path is specified.</li>
<li>Maintains an index of all files and directories in the <i >/var/log/locatedb</i> file.</li>
<li>Uses the <b >updatedb</b> command to update the index. (The <i >/etc/updatedb.conf</i> file is used to configure for updatedb.)</li>
<li style="list-style: none; display: inline">
<div><div class="to-info-box"><div class="to-info-box-body"><span class="to-icon large" aria-hidden="true"><svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></span><div class="to-info-box-body-content"><span>
The index is updated on a regular schedule. This means it is possible for locate to find a file in the index that no longer exists in the actual file system. Likewise, it is possible for locate not to find a new file in the file system that has not been added to the index yet.</span></div></div></div></div></li></ul>
<h2 >locate</h2>
<ul><li><b >-c</b> counts the number of entries rather than list them.</li>
<li><b >-e</b> lists files only after verifying that they exist.</li>
<li><b >-i</b> ignores case.</li>
<li><b >-l</b> limits the number of files listed.</li>
<li><b >-b</b> searches for the string in only file or directory base names.</li></ul></td>
<td><ul><li><b >updatedb</b> updates the index file (/var/log/locatedb).</li>
<li><b >locate /user/home paper</b> locates all files with the string <i >paper</i> as any part of the filename or directory path under the /user/home directory.</li>
<li><b >locate lib</b> locates all files with the string <i >lib</i> anywhere in the filename or directory path.</li>
<li><b >locate -c lib</b> counts the number of files with the string <i >lib</i> (e.g., 46512).</li>
<li><b >locate -e .odt</b> verifies that all .odt files listed in the file index actually exist before it lists them.</li>
<li><b >locate -i LibraryFines.csv</b> finds the libraryfines.csv file regardless of case.</li>
<li><b >locate -l 25 lib</b> lists only the first 25 files from the file index that contain the string <i >lib</i> .</li>
<li><b >locate -b lib</b> displays /var/lib and /user/home/libraryfines.csv but not /var/lib/usbutils/usb.ids.</li></ul>
<div><div class="to-info-box"><div class="to-info-box-body"><span class="to-icon large" aria-hidden="true"><svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></span><div class="to-info-box-body-content"><span>
If the search pattern contains no globbing characters, such as the wildcard character (*), locate behaves as if the pattern begins and ends with a wildcard. For example, searching for <i>paper</i> is the same as searching for <i>*paper*</i> .</span></div></div></div></div></td></tr>
<tr><td><b >which</b></td>
<td>Displays the path to a command and determines whether a package is installed.</td>
<td><ul><li><b >which ls</b> shows the path to the ls binary (executable) file.</li>
<li><b >which photorec</b> shows the path to the photorec binary file if photorec is installed and in found in the PATH.</li></ul></td></tr>
<tr><td><b >whereis</b></td>
<td>Displays the path to a Linux command's binary files, manual pages, and source code (if sources are installed). Be aware
of the following <b >whereis</b> command options:
<ul><li><b >-b</b> lists the path to the binary file (similar to <i >which</i> ).</li>
<li><b >-m</b> lists the path to the man page files.</li>
<li><b >-s</b> lists the location of the source code.</li>
<li><b >-u</b> lists entries that do not have source code, binary file, and man page locations.</li></ul>
<p>When no options are specified, whereis shows all available data.</p></td>
<td><ul><li><b >whereis ls</b> lists information about the ls command.</li></ul></td></tr>
<tr><td><b >type</b></td>
<td><p>Displays a command's type. Possible categories include:</p>
<ul><li>A built-in shell command</li>
<li>A command that the shell calls</li>
<li>An aliased command</li>
<li>A function</li></ul>
<p>If a called command has been used recently, the output says that the command is hashed, which means that it is in
the shell's hash table.</p></td>
<td><ul><li><b >type cd</b> displays <i >cd is a shell built-in</i> .</li>
<li><b >type more</b> displays the path to the binary file for <i >more</i> .</li></ul></td></tr></tbody></table>

> The term **file globbing** refers to the use of wildcards (e.g., _ , _._ , _.txt) to match specific files.

## 2.12.5 Content Search Utilities

### Content Search Utilities 00:00-00:12

In this lesson, we're going look at content search utilities for a Linux system. These are used to search for content within files.

### The `grep` Command 00:12-00:26

Linux provides a useful utility called grep that you can use to search for a specific text string. For example, you can use it to search for a message, or a specific directive within a configuration file. You can even use grep to search through multiple files at once.

### Bookmark Title Here 00:26-01:01

To use grep, run the grep command at the shell prompt, then specify the search string or expression you want to search for. Here, I'm running grep and looking for the text string firewalld. Then I specified which file I want to search within. In this example, I'm looking for the text firewalld within a file named boot.log located in the /var/log directory. This will display any log entries within this file related to the firewalld daemon on my system. And grep returns each line within that file containing an instance of that search term.

### The `grep` Command Options 01:01-01:41

The grep command offers some useful options in your searches. The first is -i, which causes grep to ignore case in the text string. Without this option, grep is case sensitive. The -i option is helpful when you are unsure of case in your string.

Another useful option is the -l option, which alters grep's response from displaying an entire line to displaying only the file name where the matching content was found. You can also use the -n option to display matching numbers. Next, is the -r option, which causes grep to search recursively through all the subdirectories of the specified path. This helps when you're unsure which file to search in for the string.

### The `egrep` Command and Regular Expressions 01:41-02:13

When you need to search for more complex patterns such as searching for files using regular expressions instead of a text string, you can use egrep or grep -E. Regular expressions are strings consisting of metacharacters and literals. Literals means the letters A through Z and numbers.

Metacharacters are different from literals because they represent other characters. They can be used to specify a character's location or matching text within a string. You can use regular expressions with egrep to create some very complex search patterns.

### The Star (`*`) and Period (`.`) Metacharacters 02:13-02:56

There are many metacharacters you can use in a regular expression. Here we have the more common ones.

First is the star (`*`) character. It tells grep to match on any number of additional characters. For example, if we search with the term `'Stuff*'`, then grep will match with any word that begins with stuff, such as Stuffing, Stuff1, Stuffy, etc. The star character is like a wild card for matching.

Next, we have the period (`.`). A period matches a single character. For example, if we search for `'Stuff.'` with grep, it'll match text such as Stuff1 and Stuffy but not Stuffing because Stuff1 and Stuffy both match a single character where the period is located. Stuffing has three characters where the period is.

The caret (`^`) and dollar sign (`$`) Metacharacters 02:56-03:38
Next, you can use the caret symbol (`^`) to match an expression if it appears at the beginning of the line. In this example, we use `^Stuff` and it will match any line that begins with the word Stuff.

In contrast, you can use the dollar sign to match an expression that appears at the end of a line. So, if we search for `'Stuff$'`, it'll match only instances where Stuff is at the end of the line.

There are many more metacharacters you can use. To explore the options, go to the shell prompt and type man regex. This will display the man page for regular expressions which contains lots of information and examples. The internet can also provide you with additional ways you can construct flexible search terms using regular expressions.

### Escaped Characters in Regular Expressions 03:38-04:11

It's important to know how to have egrep differentiate when a character should be seen as a metacharacter or as plain text. We do this by escaping characters as metacharacters by putting a backslash (\) in front of it to distinguish it as plain text.

For example, if we are searching a log file for any instance of the text string www.spam.com. The periods will be read as metacharacters by egrep. To escape the periods, we put backslashes in front of each one. Now, egrep will search for www.spam.com as a text string with no variables.

### The `fgrep` Command 04:11-04:34

Another variation on the grep command is called fgrep which stands for fixed string grep. It's used to search for matching lines of text in the file being searched using direct string comparisons.

The syntax is 'fgrep' at the shell prompt followed by the pattern you are searching for and then the file name to search within. This is the same as running grep with the -F option.

### Summary 04:34-04:53

That's it for this lesson. In this lesson, we talked about searching for content within Linux files. We first looked at the grep command. Then we looked at using the egrep command with regular expressions. And then, we ended this lesson by looking at the fgrep utility.

## 2.12.6 Find File Content

### Searching Individual Files with grep 00:00-00:56

grep is a standard Linux utility that can search for words or patterns of text in files. In the current directory are several files that contain various sample text. Using the command grep 'World' file1.txt, I can search file1.txt for the word "World." The output is the line within the file containing the pattern we searched for; in this case, the output is colored to indicate the search pattern within the line.

If we look for a pattern that doesn't occur in the file, for example, grep 'Goodbye' file1.txt, then a lack of output indicates that the pattern wasn't found. And if we look for a pattern that occurs on more than one line, for example, grep 'Hello' file1.txt, then the output lists all occurrences.

### Searching Multiple Files with grep 00:56-01:51

We can search multiple files with the same grep command. For example, to search for the sequence of letters 'a', 'b,' and 'c' in file2.txt and file3.txt, we can use grep 'abc' file2.txt file3.txt. Rather than listing all the files ourselves, we could use wildcard characters to select multiple files. For example, grep 'abc' ./\* will search all the files in the current directory for the pattern.

Even more powerful than searching the files in just one directory, we can use grep with the -R flag (for recursive) to search a directory and all of its sub-directories: grep -R 'abc' . (dot for the current directory). And we see the output includes files in sub-directories.

### Searching Terminal Output with Pipes and grep 01:51-02:22

In addition to being able to search files, grep can search the output of other commands when used with a pipe. This way, grep functions as a filter to only show lines of output that match the given pattern. For example, the env command can be used to list all the environment variables currently in the shell. We can use env | grep 'TERM' to pipe the output of env into grep, and the output is a list of the environment variables whose name or value includes the word "TERM."

### `grep` Tips 02:22-03:57

It's not required to put quotation marks around the search pattern when using grep, but it can be a good idea if the search contains spaces or other characters that may be misinterpreted by the shell. By default, grep is case-sensitive, meaning that capital letters in the search pattern only match capital letters in the file, and so on. This can be turned off by using the `-i` flag (for ignore case). For example, `grep -i 'hello' file1.txt`.

If we want more information about where a line of text occurs in the file, we can add the -n flag (for number) to show the line number of each match. For example, `grep -n 'Universe' file1.txt`. Here we can see the pattern occurs on line four.

`grep` also supports a more advanced form of pattern matching called "regular expressions." Instead of being required to provide the exact text to match, a regular expression can match multiple variations on the same pattern. To use regular expressions with grep, we add the -E flag or use the command egrep, which is a convenience wrapper for `grep -E`.

An example of using grep with a regular expression is this, which shows all sequences of three lower-case letters in all files under the current directory. While regular expressions are a useful tool, this demo isn't specifically about regular expressions, so for now, we won't dive into the details of this syntax.

### Summary 03:57-04:12

This has been a demo of using the grep command to search the contents of files, filter the output of commands, and select extended features of the `grep` command.

## 2.12.7 Content Search Facts

A Linux administrator must possess the skills to locate text within the contents of a file.

This lesson covers the following topics:

- File search commands
- The diff command

### File Search Commands

#### grep

<table><thead><tr><th class_="firstTableHeader" scope="col" >
     Command</th>
    <th scope="col" >
     Description</th>
    <th scope="col" >
     Examples</th></tr></thead>
   <tbody><tr><td><b >grep</b></td>
    <td>Searches through files for a specified character string. By default, <b >grep</b> is context sensitive and displays the
        string in the context of the line containing the string.
     <ul><li><b >-A <i >[number]</i></b> prints a specified number of lines following the matching lines.</li>
      <li><b >-a</b> searches binary (executable) files as though they were text files.</li>
      <li><b >-B <i >[number]</i></b> prints a specified number of lines before the matching lines.</li>
      <li><b >-C <i >[number]</i></b> prints a specified number of lines of context around the matching lines.</li>
      <li><b >-c</b> shows the number of matches of the string for the file.</li>
      <li><b >-E</b> uses regular expressions for the text pattern.</li>
      <li><b >-e <i >[pattern]</i></b> specifies a literal pattern.</li>
      <li><b >-f</b> searches for multiple strings using a file that lists the string patterns.</li>
      <li><strong >-i</strong>
       ignores case sensitivity in a search string.</li>
      <li><b >-l</b> lists just the names of the files with a match. This is used 
			to search multiple files.</li>
      <li><b >-m <i >[number]</i></b> shows only a specified number of matches for a file.</li>
      <li><b >-n</b> displays the line number of the lines containing the term.</li>
      <li><b >-r</b> searches the directory and all subdirectories for files containing the term.</li>
      <li><b >-v</b> displays non-matching lines.</li>
      <li><b >--include= <i >[file_name]</i></b> searches only in files with names that match a specified string.</li>
      <li><b >--exclude= <i >[file_name]</i></b> searches in files with names that do not match a specified string.</li>
      <li><b >-w</b> searches for whole words only.</li></ul></td>
    <td><ul><li><b >grep -A 3 Midway ~/docs/WWII-report</b> searches WWII-report for the pattern "Midway" and prints the
          line and the next three lines.</li>
      <li><b >grep -a var11 /bin</b> searches all files, including binary files, in the /bin directory for the pattern
          "var11".</li>
      <li><b >grep -C -3 Midway ~/docs/WWII-report</b> shows the specified 
			number of lines preceding and following the matching lines.</li>
      <li><b >grep -c Midway ~/docs/WWII-report</b> shows a number 
			representing the number of times the pattern "Midway" was found in
          the WWII-report file.</li>
      <li><b >grep -e '--count' ~/docs/doc1</b> looks for the pattern "--count" in the doc1 file rather than
          interpreting it as an option.</li>
      <li><b >grep -l -r Midway ~/docs</b> shows the name of all files in the /home/user/docs directory that contain the term
          "Midway".</li>
      <li><b >grep -m 2 battle ~/docs/WWII-report</b> shows only the first two times the term "battle" is found in the
          file.</li>
      <li><b >grep -n -i customVariable1 ~/java/program1.java</b> shows the line numbers of lines that have the term
          "customVariable1" in the program1.java file. This ignores the case.</li>
      <li><b >grep -r battle ~/docs/</b> searches the directory and all subdirectories for the term "battle".</li>
      <li><b >grep -w tank ~/docs/WWII-report</b> searches only for the whole word "tank" in the file.</li></ul></td></tr>
   <tr><td><b >egrep</b></td>
    <td>Uses regular expressions in the search strings. The <b >egrep</b> command uses the same options and syntax as <b >grep</b> and is identical to <b >grep -E</b> . Constructors for <b >egrep</b> regular expressions include:
     <ul><li><b >^</b> matches terms that occur at the beginning of a line.</li>
      <li><b >$</b> matches terms that occur at the end of a line.</li>
      <li><b >\&lt;</b> matches words that begin with the term.</li>
      <li><b >\&gt;</b> matches words that end with the term.</li>
      <li><b >[ <i >asdf</i> ]</b> matches any one of the characters in the brackets.</li>
      <li><b >[ <i >0-9</i> ]</b> matches any of the range of numbers 0-9.</li>
      <li><b >[^ <i >xyz</i> ]</b> omits any one of the letters in the list</li>
      <li><b >.</b> matches any single character.</li>
      <li><b >[ <i >asdf</i> ]+</b> matches one or more of the characters in the list.</li>
      <li><b >*</b> matches any number or none of the preceding single character.</li>
      <li><b >|</b> matches either of the terms.</li>
      <li><b >\</b> displays the literal value of a character used for expressions.</li>
      <li><b >()</b> groups expressions.</li></ul></td>
    <td><ul><li><b >egrep ^FAILURE ~/error_logs</b> matches the term "FAILURE" when it is at the beginning of the line in
          error_logs.</li>
      <li><b >egrep tty7$ ~/.bash_history</b> matches the term "tty7" when it is at the end of the line.</li>
      <li><b >egrep \&lt;are ~/myfile</b> matches all words or strings that begin with "are" (e.g., "are",
          "area", and "arena").</li>
      <li><b >egrep \&gt;are ~/myfile</b> matches all words or strings that end with "are" (e.g., "are",
          "hare", and "aware").</li>
      <li><b >egrep watche[ds] ~/myfile</b> matches either "watched" or "watches".</li>
      <li><b >egrep exhibit[0-9] ~/myfile</b> matches "exhibit1", "exhibit3", or "exhibit8".</li>
      <li><b >egrep [^Xx]mas ~/myfile</b> matches "Christmas" but not "xmas" or "Xmas".</li>
      <li><b >egrep .are ~/myfile</b> matches "hare" and "care", but not "aware" or
          "are".</li>
      <li><b >egrep file[0-9]+ ~/myfile</b> matches "file0", "file10", and "file15636".</li>
      <li><b >egrep fil* ~/myfile</b> matches "fil", "filll", and "fillllllllllllllll".</li>
      <li><b >egrep fil.* ~/myfile</b> matches "file", "fill", "file102", and
          "filings".</li>
      <li><b >egrep men|women ~/myfile</b> matches "men" or "women".</li>
<li><b >egrep Hello\? ~/myfile</b> matches "Hello?".</li></ul></td></tr>
<tr><td><b >fgrep</b></td>
<td>Uses a file as the source for the string patterns. When searching for fixed strings rather than regular expressions, <b >fgrep</b> :
<ul><li>Uses the same options as the <b >grep</b> command and has the same syntax.</li>
<li>Is identical to <b >grep -F</b> , but searches faster than <b >grep</b> .</li>
<li>Interprets the pattern as a list of fixed strings, any of which can be matched.</li></ul></td>
<td><ul><li><b >fgrep Midway Nimitz ~/docs/myfile</b> searches myfile for lines containing "Midway" or "Nimitz".</li></ul></td></tr></tbody></table>

### The diff Command

#### diff

<table><thead><tr><th class_="firstTableHeader" scope="col" >
     Command</th>
    <th scope="col" >
     Description</th>
    <th scope="col" >
     Examples</th></tr></thead>
   <tbody><tr><td><b >diff</b></td>
    <td>Displays the differences between two files, line by line. The output can contain the following characters:
     <ul><li>&lt; <i >[text]</i> : only the first file contains this text.</li>
      <li>&gt; <i >[text]</i> : only the second file contains this text.</li>
      <li>a : text has been added.</li>
      <li>c : text has changed.</li>
<li>d : text has been deleted.</li></ul>
<h2 >diff</h2>
<ul><li><b >-c</b> displays differences in context mode.</li>
<li><b >-u <i >[number]</i></b> prints a specified number of lines in a unified context.</li>
<li><b >-i</b> ignores the case and treats uppercase and lowercase the same.</li>
<li><b >-w</b> ignores all white space.</li>
<li><b >-y</b> displays the output in two columns.</li></ul></td>
<td><ul><li><b >diff file1.txt file2.txt</b> displays the differences using the default display mode.</li>
<li><b >diff -c file1.txt file2.txt</b> displays the differences using the context mode.</li></ul></td></tr></tbody></table>
