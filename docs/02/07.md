---
lang: zh-CN
title: Section 2.7 Redirection, Piping and Command Substitution
description: some description
---

As you study this section, answer the following questions:

<ul><li>What are the three default file descriptors that Linux uses to
          classify information for a command?</li>
    <li>What is the difference between redirection and piping?</li>
    <li>When might you choose to redirect the input of a command?</li>
    <li>How can you overcome the 128 KB shell command size restriction?</li></ul>

In this section, you will learn to:

<ul><li>Use redirection</li>
<li>Use piping</li></ul>

Key terms for this section include the following:

<table class="terms">
  <thead>
    <tr>
      <td>Term</td>
      <td>Definition</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Standard stream</td>
      <td>
        Preconnected input and output communication channels available to
        Linux shells and processes.
      </td>
    </tr>
    <tr>
      <td>stdin</td>
      <td>
        A standard stream that provides data that is typically streamed from
        the keyboard.
      </td>
    </tr>
    <tr>
      <td>stdout</td>
      <td>
        A standard stream that accepts normal output information to be
        streamed to the console screen or shell window.
      </td>
    </tr>
    <tr>
      <td>stderr</td>
      <td>
        A standard stream that accepts normal error information to be
        streamed to the console screen or shell window.
      </td>
    </tr>
    <tr>
      <td>Redirection</td>
      <td>
        The process of modifying a shell command to divert the standard
        input, output, and error streams to locations other than the
        default.
      </td>
    </tr>
    <tr>
      <td>Piping</td>
      <td>
        The process of redirecting the output from one command to be the
        input of another command.
      </td>
    </tr>
    <tr>
      <td>Here documents</td>
      <td>A block of text that is redirected as input to a command.</td>
    </tr>
    <tr>
      <td>Command substitution</td>
      <td>
        A feature of the bash shell that substitutes the output of one shell
        command as the arguments for another shell command.
      </td>
    </tr>
  </tbody>
</table>

This section helps you prepare for the following certification exam objectives:

<table>
<thead>
  <tr>
    <td>Exam</td>
    <td>Objective</td>
  </tr>
</thead>
<tbody>
  <tr>
    <td>CompTIA Linux+ XK0-005</td>
    <td>
      1.1 Summarize Linux fundamentals
      <ul>
        <li>
          Device types in /dev
          <ul>
            <li>
              Special character devices
              <ul>
                <li>/dev/null</li>
                <li>/dev/zero</li>
                <li>/dev/urandom</li>
              </ul>
            </li>
          </ul>
        </li>
      </ul>
      <p>
        3.1 Given a scenario, create simple shell scripts to automate
        common tasks. <br />
      </p>
      <ul>
        <li>Shell script elements</li>
        <ul>
          <li>Standard stream redirection</li>
          <ul>
            <li>|</li>
            <li>||</li>
            <li>&gt;</li>
            <li>&gt;&gt;</li>
            <li>&lt;</li>
            <li>&lt;&lt;</li>
            <li>&amp;</li>
            <li>&amp;&amp;</li>
            <li>Redirecting</li>
            <ul>
              <li>stderr</li>
              <li>stdout</li>
            </ul>
          </ul>
          <li>Here documents</li>
          <li>
            Common script utilities
            <ul>
              <li>xargs</li>
            </ul>
          </li>
        </ul>
      </ul>
    </td>
  </tr>
</tbody>
</table>

## 2.7.1 Redirection

## 2.7.2 Piping

## 2.7.3 Use Redirection

## 2.7.4 Use Piping

## 2.7.5 Redirection and Piping Facts

Redirection and piping are two Linux shell features that allow the input and output of a command to be a file or another command.

This lesson covers the following topics:

<ul><li>Standard streams and bash shell file descriptors</li>
   <li>Redirection</li>
   <li>Piping</li>
   <li>The tee command</li>
   <li>Here documents</li>
<li>Device files often used with redirection and piping</li></ul>

### Standard Streams and Bash Shell File Descriptors

The bash shell maintains three standard data streams, which are pre-connected input and output communication channels. Unless configured otherwise, bash commands use the following standard streams:

<ul><li>Standard input (stdin) is data that is typically streamed from the keyboard. If a bash command accepts input, by default,
it is gathered from stdin.</li>
<li>Standard output (stdout) is data that is typically streamed to the console screen. By default, bash commands send their
output to stdout.</li>
<li>Standard error (stderr) is data that is also typically streamed to the console screen. If a command needs to output an
error messages or give diagnostics, by default, it sends this output to stderr.</li></ul>

The bash shell assigns a file descriptor to each of the standard streams. A file descriptor is a handle or number that identifies an open file or other data source and how that resource can be accessed. The following table summarizes these ideas.

<table>
  <thead>
    <tr>
      <td>Standard Stream</td>
      <td>File Descriptor</td>
      <td>Associated Device</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>stdin</td>
      <td>0</td>
      <td>Keyboard</td>
    </tr>
    <tr>
      <td>stdout</td>
      <td>1</td>
      <td>Console screen or graphical shell window</td>
    </tr>
    <tr>
      <td>stderr</td>
      <td>2</td>
      <td>Console screen or graphical shell window</td>
    </tr>
  </tbody>
</table>

### Redirection

Linux commands can be modified to divert the standard input, output, and error streams to locations other than the default. This process is called redirection and is implemented using the following command operators:

<table>
  <thead>
    <tr>
      <td>Command Operator</td>
      <td>Description</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><b>&gt;</b> and <b>1&gt;</b></td>
      <td>
        Redirects command output that is normally sent to stdout to the file
        name that follows the operator. The 1 is implied so that
        <b>&gt;</b> and <b>1&gt;</b> are functionally identical.
        <ul>
          <li>
            If the file that follows the operator exists, it is overwritten.
          </li>
          <li>If the file doesn't exist, it is created.</li>
          <li>
            If there is no output generated by the command, the file will be
            empty.
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><b>2&gt;</b></td>
      <td>
        Redirects command output that is normally sent to stderr to the file
        name that follows the operator. The <b>2</b> is mandatory.
        <ul>
          <li>
            If the file that follows the operator exists, it is overwritten.
          </li>
          <li>If the file doesn't exist, it is created.</li>
          <li>
            If there is no error generated by the command, the file will be
            empty.
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><b>&gt;&gt;</b> , <b>1&gt;&gt;</b> and <b>2&gt;&gt;</b></td>
      <td>
        The <b>&gt;&gt;</b> operator functions in the same way as the
        <b>&gt;</b> operator except that any output/errors are appended to
        the file that follows the operator.
        <ul>
          <li>
            The <b>&gt;&gt;</b> and <b>1&gt;&gt;</b> operators appends the
            output sent to stdout.
          </li>
          <li>
            The <b>2&gt;&gt;</b> operator appends the output sent to stderr.
          </li>
          <li>
            If the file that follows the operator exists, it is appended
            with the output/error.
          </li>
          <li>If the file doesn't exist, it is created.</li>
          <li>
            The file will be not be appended if there is no output/errors
            generated by the command. <br />
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><b>&amp;&gt;</b></td>
      <td>
        Redirects both command output that is normally sent to stdout and
        command errors that are normally sent to stderr to the file name
        that follows the operator.
        <ul>
          <li>
            As part of a command, <b>&amp;&gt; myfile.txt</b> is equivalent
            to <b>&gt; myfile.txt 2&gt; &amp;1</b> or
            <b>&gt; myfile.txt 2&gt; myfile.txt</b> .
          </li>
          <li>
            File creation follows the rules for the <b>&gt;</b> operator.
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><b>&amp;&gt;&gt;</b></td>
      <td>
        The <b>&amp;&gt;&gt;</b> operator functions in the same way as the
        <b>&amp;&gt;</b> operator except that both output and errors are
        appended to the file that follows the operator.
        <ul>
          <li>
            As part of a command, <b>&amp;&gt;&gt; myfile.txt</b> is
            equivalent to <b>&gt;&gt; myfile.txt 2&gt;&gt; &amp;1</b> (where
            <b>&amp;</b> indicates that what follows is a file descriptor
            and not a filename) or
            <b>&gt;&gt; myfile.txt 2&gt;&gt; myfile.txt</b> .
          </li>
          <li>
            File creation follows the rules for the <b>&gt;</b> operator.
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><b>&lt;</b> and <b>0&lt;</b></td>
      <td>
        Redirects command input that is normally read from stdin so that it
        is read from the file name that follows the operator. The 0 is
        implied so that <b>&lt;</b> and <b>0&lt;</b> are functionally
        identical.
        <ul>
          <li>
            If the file that follows the operator exists, it is used as
            input.
          </li>
          <li>If the file doesn't exist, an error is shown.</li>
          <li>
            If there is no input needed by the command, the file is ignored.
          </li>
        </ul>
      </td>
    </tr>
  </tbody>
</table>

The following examples demonstrate redirection concepts.

<table>
  <thead>
    <tr>
      <td>Example</td>
      <td>Result</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><b>ls /usr &gt; /tmp/deleteme</b></td>
      <td>
        Writes the list of files in the /usr directory to a file named
        /tmp/deleteme.
      </td>
    </tr>
    <tr>
      <td><b>ls /nonesuch &gt; /tmp/deleteme</b></td>
      <td>
        Creates an empty /tmp/deleteme file (or overwrites it as an empty
        file if it exists) and displays the error message
        <i>/nonesuch not found</i> (because the /nonesuch directory does not
        exist).
      </td>
    </tr>
    <tr>
      <td><b>ls /nonesuch 2&gt; /tmp/deleteme</b></td>
      <td>
        Writes the error message
        <i>/nonesuch not found</i> (because the /nonesuch directory does not
        exist) to a file named /tmp/deleteme. The /tmp/deleteme file will be
        overwritten if it already exists.
      </td>
    </tr>
    <tr>
      <td><b>ls /bin /nonesuch &gt; /tmp/deleteme</b></td>
      <td>
        Writes a listing of the files and directories within the /bin
        directory to the /tmp/deleteme file and displays the error message
        <i>/nonesuch not found</i> to the console screen or shell window.
        The /tmp/deleteme file will be overwritten if it already exists.
      </td>
    </tr>
    <tr>
      <td><b>ls /bin /nonesuch &gt; /tmp/deleteme 2&gt;&amp;1</b></td>
      <td>
        Writes a listing of the files and directories within the /bin
        directory to the /tmp/deleteme file and also writes the error
        message <i>/nonesuch not found</i> to the /tmp/deleteme file. Both
        the list of files and directories within the /bin directory and the
        error message are written to the same file.
      </td>
    </tr>
    <tr>
      <td><b>ls /bin &gt;&gt; /tmp/deleteme</b></td>
      <td>
        Appends the list of files from the /usr directory to the
        /tmp/deleteme file. The /tmp/deleteme file will be created if it
        does not exist.
      </td>
    </tr>
    <tr>
      <td><b>sort &lt; unordered.txt &gt; ordered.txt</b></td>
      <td>
        Uses the contents of the unordered.txt as input to the
        <b>sort</b> command, and then writes the sorted contents to the file
        named ordered.txt. If the ordered.txt file already exists, it will
        be overwritten.
      </td>
    </tr>
  </tbody>
</table>

### Piping

Piping redirects the output from one command to be the input of another command.

<ul><li>A Linux pipe is represented by a vertical bar ( <b >|</b> ).</li>
<li>The pipe functionality is similar to that of using stdout redirection to write the output of one command to an intermediate file, that is then used as input to a second command, using stdin redirection.</li>
<li>A plumbing pipe, where water enters from one end and exits the other, can be used as a mnemonic to help explain how the pipe (|) operator works.</li></ul>

### The tee Command

There may be times when you want to view the output of a command as it is normally sent to the console screen (stdout), but you also want the same output to be saved in a file. This can be done using the tee command.

<ul><li>The output from a command is piped to the tee command.</li>
<li>The file used to store the output is added as a tee command argument.</li>
<li>A plumbing tee, where water flow is divided from one pipe to two separate pipes, can help you understand how the tee command works.</li></ul>

The following examples demonstrate tee command concepts.

<table>
  <thead>
    <tr>
      <td>Example</td>
      <td>Result</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><b>ls /bin | tee binfiles.txt</b></td>
      <td>
        Displays the files and directories contained in the /bin directory
        on the console screen (or shell window) and writes the same
        information to the binfiles.txt file.
      </td>
    </tr>
    <tr>
      <td><b>ls -1 *.txt | wc -l | tee count.txt</b></td>
      <td>
        Pipes a one-column list of files that end with
        <i>.txt</i> in the current directory to the wc (word count) command
        and then take that output, which gives the number of files in the
        list, and pipes that to the tee command that displays this number on
        the console screen (or shell window) and writes the same number to
        the count.txt file.
      </td>
    </tr>
  </tbody>
</table>

### Here Documents

A here document is a block of text that is redirected as input to a command. Here documents are often used in shell scripts.

<ul>
<li>
A command is followed by the <b>&lt;&lt;</b> operator, which is then
followed by a marker, which is traditionally an uppercase word.
<div>
  <div>
    <div>
      <div class="to-icon large" aria-hidden="true" style="width: 20px;">
        <svg
          aria-hidden="true"
          focusable="false"
          data-prefix="fal"
          data-icon="circle-info"
          class="svg-inline--fa fa-circle-info"
          role="img"
          xmlns="http://www.w3.org/2000/svg"
          viewBox="0 0 512 512"><path
            fill="currentColor"
            d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg>
      </div>
      <div>
        <span>
          The term <i>here document</i> may have origins in the practice
          of using the word <i>HERE</i> as the marker.</span>
      </div>
    </div>
  </div>
</div>
</li>
<li>Lines of text are included in the block.</li>
<li>
The end of the block of text is indicated by the same marker that
follows the <b>&lt;&lt;</b> operator.
</li>
<li>The shell passes the block of text to the command as input.</li>
</ul>

The following examples demonstrate here document concepts.

<table>
  <thead>
    <tr>
      <td>Example</td>
      <td>Explanation</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <b
          >cat &lt;&lt; HERE
          <br />
          &gt; Today, we hope you are
          <br />
          &gt; learning a great deal
          <br />
          &gt; about Linux redirection
          <br />
          &gt; and piping from TestOut.
          <br />
          &gt;HERE</b
        >
      </td>
      <td>
        The following lines are displayed on the console screen or shell
        window:
        <p>
          Today, we hope you are
          <br />
          learning a great deal
          <br />
          about Linux redirection
          <br />
          and piping from TestOut.
        </p>
        <p>
          This may be useful when creating shell scripts that present
          explanations and documentation to users.
        </p>
      </td>
    </tr>
    <tr>
      <td>
        <b>lftp machine -uUser,Passwd &lt;&lt;END<br />
          cd your_dir<br />get your_file
          <br />bye
          <br />END</b>
      </td>
      <td>
        Multiple commands are entered during an ftp session. These commands
        are managed using the lftp program. This may be helpful when
        automating a long list of ftp commands.
      </td>
    </tr>
  </tbody>
</table>

### Device Files Often Used with Redirection and Piping

Device files are file-like access points to hardware devices. There are two device files that are often used with redirection and piping: /dev/tty and /dev/null

<table>
  <thead>
    <tr>
      <td>Device File</td>
      <td>Description</td>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><b>/dev/tty</b></td>
      <td>
        The first terminals were Teletype (abbreviated as
        <i>tty</i> ), which can be compared to a remote
        controlled typewriter. The /dev/tty device file is associated with
        the computer's controlling terminal or the shell's window.
        <ul>
          <li>Data can be both written to and read from this file.</li>
          <li>
            Text written to this file is displayed on the console monitor's
            screen or shell window.
          </li>
          <li>
            Text read from this file originates from the console's keyboard.
          </li>
          <li>
            The <b>/dev/tty</b> device file is similar to a combination of
            stdin and stdout. Both stdin and stdout are accessed as data
            streams, whereas <b>/dev/tty</b> is accessed like a file.
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><b>/dev/null</b></td>
      <td>
        The /dev/null device file is associate with a null device. A null
        device is commonly used for disposing unwanted output streams.
        <ul>
          <li>
            While a command can read from <b>/dev/null</b> , commands
            typically write unwanted output or unwanted error messages to
            <b>/dev/null</b> .
          </li>
          <li>
            A slang word for the <b>/dev/nul</b> device file is bit bucket.
          </li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><b>/dev/zero</b></td>
      <td>
        Similar to /dev/null, /dev/zero discards any input. It also returns
        a "0" for however many times it is accessed. It is most commonly
        used for:
        <ul>
          <li>Initializing a new block device</li>
          <li>Overwriting existing data</li>
        </ul>
      </td>
    </tr>
    <tr>
      <td><b>/dev/urandom</b></td>
      <td>
        Returns a pseudo-random number. Frequently used when performing
        cryptographic (encryption) tasks.
      </td>
    </tr>
  </tbody>
</table>

### /dev/tty

<table>
<thead>
  <tr>
    <td>Example</td>
    <td>Explanation</td>
  </tr>
</thead>
<tbody>
  <tr>
    <td><b>echo "test" &gt; /dev/tty</b></td>
    <td>
      Writes the word <i>test</i> to the console or to a shell windows. This is redundant, since the echo command by itself performs the same action.
    </td>
  </tr>
  <tr>
    <td><b>sort &lt; /dev/tty &gt; sortkeyboard.txt</b></td>
    <td>
      The text entered using the keyboard is sorted and written to the sortkeyboard.txt file.
      <div>
        <div>
          <div>
            <div class="to-icon large" aria-hidden="true" style="width: 20px;">
              <svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div>
            <div><span>The <b>&lt; /dev/tty</b> operation will continue to accept keyboard input until the user enters an end-of-file (EOF) sequence using the Ctrl+D key combination.</span>
            </div>
          </div>
        </div>
      </div>
    </td>
  </tr>
  <tr>
    <td><b>rm deleteme.txt 2&gt; /dev/null</b></td>
    <td>
      Deletes the <b>deleteme.txt</b> file if it exists. If it doesn't exist, don't display an error message.
      <div>
        <div>
          <div>
            <div class="to-icon large" aria-hidden="true" style="width: 20px;"><svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor"
                  d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div><div >
              <span>This logic is often used in shell scripts to suppress error messages that are not important to the script's overall purpose.</span>
            </div>
          </div>
        </div>
      </div>
    </td>
  </tr>
</tbody>
</table>

## 2.7.6 Command Substitution

## 2.7.7 Command Substitution Facts

Command substitution is a feature of the Bash shell that substitutes the output of one shell command as the arguments for another shell command.

This lesson covers the following topics:

- Implement command substitution
- The xargs command

### Implement Command Substitution

#### $(<command>)

<ol>
  <li>
    The shell creates a child process that runs the specified command.
  </li>
  <li>
    The stdout from the first command is redirected back to the shell.
  </li>
  <li>
    The shell parses the output from the first command into words separated
    by white space.
    <div>
      <div >
        <div >
          <div class="to-icon large" aria-hidden="true" style="width: 20px;">
            <svg aria-hidden="true" focusable="false"
              data-prefix="fal"
              data-icon="circle-info"
              class="svg-inline--fa fa-circle-info"
              role="img"
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 512 512"><path fill="currentColor"
                d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg>
          </div>
          <div >
            <span>
              If the command substitution operator <b>$()</b> appears within single quotes (' '), word parsing is not performed on the output.</span>
          </div>
        </div>
      </div>
    </div>
  </li>
  <li>
    The shell creates a new command by substituting the parsed output from
    the first command in place of the
    <b class="fw-bold">$(&lt; <i >command</i> &gt;)</b>
    operator.
  </li>
  <li>
    The shell creates another child process that runs the second command.
  </li>
</ol>

The examples below demonstrate these command substitution concepts.

<table>
  <thead>
    <tr>
      <th scope="col">Example</th>
      <th scope="col">Explanation</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>
        <b>printf "The date and time is: $(date)\n"</b>
      </td>
      <td>
        Command substitution occurs when the shell encounters
        <b>$(date)</b> . The process is as follows:
        <ol>
          <li>
            The shell creates a child process and runs the
            <b>$(date)</b> command.
          </li>
          <li>
            The output from the child process is redirected back to the
            shell, but is not parsed.
          </li>
          <li>
            The <b>$(date)</b> operator in the original command is replaced
            with the output from the child process.
          </li>
          <li>
            Another new process is created that runs the
            <b>printf</b> command with the replaced text.
            <div>
              <div >
                <div >
                  <div
                    class="to-icon large"
                    aria-hidden="true"
                    style="width: 20px;">
                    <svg
                      aria-hidden="true"
                      focusable="false"
                      data-prefix="fal"
                      data-icon="circle-info"
                      class="svg-inline--fa fa-circle-info"
                      role="img"
                      xmlns="http://www.w3.org/2000/svg"
                      viewBox="0 0 512 512"><path
                        fill="currentColor"
                        d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg>
                  </div>
                  <div >
                    <span>
                      The <b>printf</b> command replaces the <b>\n</b> in
                      double quotes with a newline character.</span>
                  </div>
                </div>
              </div>
            </div>
          </li>
        </ol>
      </td>
    </tr>
    <tr>
      <td>
        <b>echo -e "List of logged on users and what they are doing:\n $(w)"</b>
      </td>
      <td>
        Command substitution occurs when the shell encounters
        <b>$(w)</b> . The process is as follows:
        <ol>
          <li>
            The shell creates a child process and runs the
            <b>w</b> command.
            <div>
              <div >
                <div >
                  <div
                    class="to-icon large"
                    aria-hidden="true"
                    style="width: 20px;">
                    <svg
                      aria-hidden="true"
                      focusable="false"
                      data-prefix="fal"
                      data-icon="circle-info"
                      class="svg-inline--fa fa-circle-info"
                      role="img"
                      xmlns="http://www.w3.org/2000/svg"
                      viewBox="0 0 512 512"><path
                        fill="currentColor"
                        d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg>
                  </div>
                  <div >
                    <span>
                      The <b>w</b> command is short for "who" and returns a
                      summary of logged-on users.</span>
                  </div>
                </div>
              </div>
            </div>
          </li>
          <li>
            The output from the child process is redirected back to the
            shell, but is not parsed.
          </li>
          <li>
            The <b>$(w)</b> operator in the original command is replaced
            with the output from the child process.
          </li>
          <li>
            Another new process is created that runs the
            <b>echo</b> command with the replaced text.
            <div>
              <div >
                <div >
                  <div
                    class="to-icon large"
                    aria-hidden="true"
                    style="width: 20px;">
                    <svg
                      aria-hidden="true"
                      focusable="false"
                      data-prefix="fal"
                      data-icon="circle-info"
                      class="svg-inline--fa fa-circle-info"
                      role="img"
                      xmlns="http://www.w3.org/2000/svg"
                      viewBox="0 0 512 512"><path
                        fill="currentColor"
                        d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg>
                  </div>
                  <div >
                    <span>
                      The <b>-e</b> option with the <b>echo</b> command
                      causes the <b>\n</b> in double quotes to be replaced
                      with a newline character.</span>
                  </div>
                </div>
              </div>
            </div>
          </li>
        </ol>
      </td>
    </tr>
  </tbody>
</table>

### The xargs Command

#### xargs

<table><thead><tr><td>Example</td>
<td>Explanation</td></tr></thead>
<tbody><tr><td><b >find /home -name *~ | xargs rm</b></td>
<td>This command deletes all files in all subdirectories of the /home directory that end with the tilde (~) character.
<ol><li>The <b >find /home -name *~</b> command returns a list of all the files in all the subdirectories under the /home directory that end with the tilde (~) character.</li>
<li>The file list is piped as a stream to the <b >xargs</b> command.</li>
<li>The <b >xargs</b> command collects the first 128-KB chunk from the stream.</li>
<li>The <b >rm</b> command is run using the 128-KB chunk as an argument.</li>
<li>The <b >xargs</b> command continues to collect 128-KB chunks from the stream and continues to run the <b >rm</b> command using the chunks until the end of the stream.</li></ol></td></tr>
   <tr><td><b >ls -S *.txt | xargs wc</b></td>
<td>When there are large number of *.txt files in a directory, this command displays a list of all the files along with the
number of lines/words/characters in each. The list is sorted by size, with the largest files shown first.
<ol><li>The <b >ls -S *.txt</b> command returns the list of files sorted from largest to smallest.</li>
<li>The file list is piped as a stream to the <b >xargs</b> command.</li>
<li>The <b >xargs</b> command collects the first 128-KB chunk from the stream.</li>
<li>The <b >wc</b> command is run using the 128-KB chunk as an argument.</li>
<li>The <b >xargs</b> command continues to collect 128-KB chunks from the stream and continues to run the <b >wc</b> command using the chunks until the end of the stream.</li></ol></td></tr></tbody></table>
