---
lang: zh-CN
title: Section 2.1 The Linux Shell
description: some description
---

As you study this section, answer the following questions:

<ul><li>What is a shell?</li>
    <li>What are the basic differences between common shells?</li>
    <li>Which common commands are used to navigate through shells?</li>
<li>Which items can you use the Tab key to complete after beginning to type the name?</li>
<li>What does the tilde symbol ( <b class="fw-bold">~</b> ) in the prompt indicate?</li></ul>
    
In this lesson, you will learn to:

<ul><li>Enter shell commands</li>
<li>Work with the Linux shell</li></ul>

Key terms for this section include the following:

<table class="terms">
   <thead><tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Term</th>
    <th scope="col" class="fw-bold">
     Definition</th></tr></thead>
   <tbody><tr><td>Linux shell</td>
     <td>A command line interface (CLI) or text user interface (TUI) 
		for the Linux operating system.</td></tr>
    <tr><td>Shell prompt</td>
     <td>A character or set of characters at the start of the command line that indicates that the shell is
        ready to receive commands.</td></tr>
    <tr><td>PATH environment variable</td>
     <td>An shell environment variable that contains the set of directories that are searched when you type an
        executable file at the shell prompt.</td></tr>
    <tr><td>Tab complete</td>
     <td>A shell feature that attempts to complete a command, 
		file, or directory after pressing the Tab key when
        the first few characters of a command, file, or directory are typed at the shell prompt.</td></tr>
    <tr><td>Command history</td>
     <td>A shell feature that stores shell commands and displays them when you press the Up and Down arrow
        keys.</td></tr></tbody></table>

This section helps you prepare for the following certification exam objectives:

<table class="objectives">
   <thead><tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Exam</th>
    <th scope="col" class="fw-bold">
     Objective</th></tr></thead>
   <tbody><tr><td>TestOut Linux Pro</td>
     <td>1.2 Configure and use Linux shell environments
      <br>
      <ul><li>Manage environment variables</li>
       <li>View available shells</li></ul></td></tr>
    <tr><td>CompTIA Linux+ XK0-005</td>
     <td>1.2 Given a scenario, manage files and directories
      <ul><li>File and directory operations
        <ul><li>ls</li>
         <li>pwd</li>
         <li>cd</li>
         <li>~</li>
         <li>.</li></ul></li></ul>
      <p>2.2 Given a scenario, implement identity management</p>
      <ul><li>Account creation and deletion
        <ul><li>Default shell</li>
         <li>Configuration files
          <ul><li>/etc/passwd</li></ul></li></ul></li></ul>
      <p>2.4 Given a scenario, configure and execute remote connectivity for 
			system management</p>
      <ul><li>Commands
        <ul><li>su -</li></ul></li></ul>
      <p>2.5 Given a scenario, apply the appropriate access controls</p>
      <ul><li>Command-line utilities
        <ul><li>ls</li></ul></li></ul>
      <p>3.1 Given a scenario, create simple shell scripts to automate common tasks.</p>
      <ul><li>Shell script elements
        <ul><li>Shell built-in commands
          <ul><li>echo</li></ul></li></ul></li>
       <li>Environment variables
        <ul><li>$PATH</li>
         <li>$SHELL
          <br></li></ul></li></ul></td></tr></tbody></table>

## 2.1.1 Linux Shell Overview

### Introduction 00:00-00:27

In this lesson, we're going to talk about the Linux shell. In order for an operating system to be useful, it must provide some way for the end user to communicate with the operating system itself. Basically, the end user needs a way to tell the operating system what tasks it needs to complete. Maybe we want it to run a program. Maybe we want it to copy a file from one location in the file system to another. Perhaps we're done with the computer and want to shut the operating system down.

### User Interfaces 00:27-01:11

These commands are given to the operating system through a user interface. Most Linux distributions provide two different types of user interfaces that you can employ. The first one's the command-line interface, or the CLI. When using the command-line interface, the end user must communicate with the operating system by typing commands at the command prompt. We type the command we want and hit Enter, which sends it to the operating system, and it does whatever that command is designed to do.

In addition to the command-line interface, Linux (at least most Linux distributions) also offer an easy-to-use and aesthetically pleasing graphical user interface. This interface allows them to interact with the Linux kernel using a keyboard and a mouse (basically, the same environment you're used to when running Windows).

### Command-Line Interface 01:11-01:49

Now, understand that although graphical user interfaces are usually a lot easier to use, most of the tasks you're going to perform in order to administer and support a Linux system have to be done from the command-line. This is because many Linux systems, especially those configured to function as network servers, won't have a graphical user interface enabled. Basically, the idea here is that instead of spending processor cycles continually redrawing a graphical screen, most Linux system administrators configure their systems using the text-based command-line interface. That way, system resources are reallocated to just processing network requests instead of redrawing that graphical screen all the time.

### The Linux Shell 01:49-02:16

To fully understand how the command-line interface works on Linux, you need to understand the concept of a Linux shell. The shell is a command interpreter that allows you to type commands at the keyboard that are then sent to the operating system kernel. Essentially, the shell provides that command-line interface. The neat thing about it is that Linux allows you to choose from a variety of different shells. You can try out several different command-line shells and then pick the one that you like best. That's not the case with most other operating systems.

### View the Current Shell 02:16-02:44

When you first boot your Linux system and log in, your default shell will be loaded. You can identify which shell is your default shell using the command that you see here. At the shell prompt, you enter 'ps -p $$.' The command that you see here is used to display text on the screen. We're telling the interface to go out and get the value of the shell environment variable and display it on the screen. It returns whatever the default shell is. As you can see in this example, the default shell is the Bash shell.

### Changing Shells 02:44-03:35

Now, understand that you're not stuck with the default shell configured on your system. If you want to switch to a different shell, all you have to do is enter the change shell function at the prompt. For example, if you're currently using the Bash shell but want to use the Z shell instead, type CHSH at the prompt. Once you press Enter and add your password, you can change to Z shell with the command chsh /bin/zsh.

You can check the operating shell with ps -p $$. If it still shows as the default shell, reboot Linux and check again, and it will show the zsh shell.

You can always turn the shell back to the default bash by completing a few steps. First, enter chsh, then you just need to press Enter to return to the default shell. Remember, you have to restart the entire Linux system to see the change from the command ps -p $$.

### GUI Shell Sessions 03:35-03:59

In addition to the text-based environment, you can run terminal sessions within the Linux graphical environment. This is done in much the same way as you would on Windows. You simply run a terminal program, such as Console or Gnome Terminal. Then, in order to run multiple command-line sessions, all you have to do is open up two or more terminal windows. Each shell session runs its own programs independent of those in the other shell sessions.

### Summary 03:59-04:18

That's it for this lesson. In this lesson, we talked about Linux shells. We first talked about what a shell is. Then we reviewed the different types of shells used on Linux distributions. We also learned how to change shells, see the current shell, and open multiple sessions.

## 2.1.2 Linux Shell Facts

The Linux shell is often described as a Command Line Interface (CLI) or Text User Interface (TUI) to the Linux Operating System.

This lesson covers the following topics:

<ul><li>Linux shell definition and use</li>
   <li>Linux shell access methods</li>
   <li>Linux shell types</li>
<li>Linux shell common characteristics</li></ul>

### Linux Shell Definition and Use

A Linux shell is a program that traditionally provides the text user interface (TUI) for Linux. The term shell is descriptive since it is considered an outer layer of the operating system. The shell is the interface between you, a user or administrator, and the internal parts of the operating system, including its very core, which is the kernel. The shell's main function is to read and parse your commands and then execute them through interactions with the Linux kernel.

Most Linux distributions offer a workstation version that includes a graphical user interface (GUI), and many administrative tasks can be completed within the graphical environment. Since a GUI can diminish server performance, many Linux distributions offer a server version where the GUI is either disabled or is not installed. Whether you are managing a Linux workstation version or a server version, you perform much of your administrative tasks using shell commands. In addition, you will find that graphical environments and tools may vary between distributions, but shell commands are more likely to be consistent.

### Linux Shell Access Methods

The Linux shell can be accessed:

<table><thead><tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Access Method</th>
    <th scope="col" class="fw-bold">
     Description</th></tr></thead>
   <tbody><tr><td>From the Console
      <br>
      (The keyboard and monitor
      <br>
      attached to a computer running Linux)</td>
     <td>Press the following key combinations:
      <ul><li><b class="fw-bold">Ctrl+Alt+F1</b> (in some Linux distributions, <b class="fw-bold">Alt+F1</b> )
                will start or switch to the first Linux shell session.</li>
       <li><b class="fw-bold">Ctrl+Alt+F2</b> through <b class="fw-bold">Ctrl+Alt+F6</b> (in some
                Linux distributions, <b class="fw-bold">Alt+F2</b> through <b class="fw-bold">Alt+F6</b> ) will
                switch to the second through sixth shell sessions.</li></ul>
      <div class="info" data-block="
       While Linux distributions will vary, in
              most cases, when a GUI is installed, it will use the first console
              session. Use <b>Ctrl+Alt+F1</b> to switch to a graphical login
              screen. If you are already logged in, <b>Ctrl+Alt+F7</b> will
              switch to the desktop GUI."><div class="to-info-box"><div class="to-info-box-body"><span class="to-icon large" aria-hidden="true"><svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></span><div class="to-info-box-body-content"><span>
       While Linux distributions will vary, in
              most cases, when a GUI is installed, it will use the first console
              session. Use <b>Ctrl+Alt+F1</b> to switch to a graphical login
              screen. If you are already logged in, <b>Ctrl+Alt+F7</b> will
              switch to the desktop GUI.</span></div></div></div></div></td></tr>
    <tr><td>From a desktop GUI</td>
     <td>Open a terminal session from the applications
            menu.</td></tr></tbody></table>

### Linux Shell Types

The following table describes many common shell types:

<table><thead><tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Shell Type</th>
    <th scope="col" class="fw-bold">
     Description</th></tr></thead>
   <tbody><tr><td>sh</td>
     <td>The Bourne shell is the oldest Linux shell but is
            not widely used. This shell was developed for UNIX in the 1970s.</td></tr>
    <tr><td>Bash</td>
     <td>The Bourne-Again shell (Bash) is the default
            shell used by most Linux distributions. It uses commands similar to
            a UNIX shell. The Bash includes:
      <ul><li>Command and file name completion when pressing the Tab key.</li>
       <li>Command history.</li></ul></td></tr>
    <tr><td>zsh</td>
     <td>The Z shell (zsh) is an improved version of Bash
            and is available on many Linux distributions.</td></tr>
    <tr><td>shh</td>
     <td>The Bourne shell (sh) is an earlier version of
            Bash and is similar in many ways. The sh shell was originally
            created by Steve Bourne.</td></tr>
    <tr><td>ksh</td>
     <td>The Korn shell (ksh) provides scripting features
            not found in Bash. Ksh was developed by David Korn.</td></tr>
    <tr><td height="43">
      csh</td>
     <td height="43">
      The C shell (csh) uses syntax similar
            to the syntax used in the C programming language.</td></tr>
    <tr><td>tcsh</td>
     <td>The tcsh shell is an improved version of csh. It
            offers command line editing and completion features that are not
            available in csh.</td></tr></tbody></table>

The following commands can be used to determine the default shell type and the current shell type.

<table><thead><tr><th class_="firstTableHeader" scope="col" class="fw-bold">
     Command</th>
    <th scope="col" class="fw-bold">
     Description</th></tr></thead>
   <tbody><tr><td><b class="fw-bold">echo $SHELL</b></td>
     <td>The <b class="fw-bold">echo $SHELL</b> command returns the
            default or preferred shell. The environment <b class="fw-bold">$SHELL</b> holds the
            user's preferred shell, which is typically set in <b class="fw-bold">/etc/passwd</b> .
            For example, if Bash is the user's preferred shell, <b class="fw-bold">$SHELL</b> will hold the value <b class="fw-bold">/bin/bash</b> . The preferred shell does not
            change when you switch shell types.</td></tr>
    <tr><td><b class="fw-bold">echo $0</b></td>
     <td>The <b class="fw-bold">echo $0</b> command can be used to return
            the current shell type. The special variable <b class="fw-bold">$0</b> normally
            holds the command used to start a script. A shell session is
            initiated by a script. Consequently, <b class="fw-bold">$0</b> will hold the name
            of the script, which is consistent with the shell type. For example, <b class="fw-bold">$0</b> in a console session running bash might hold the value <b class="fw-bold">-bash</b> ,
            $0 in a terminal application opened from a desktop menu might hold
            the value <b class="fw-bold">bash</b> . When you type <b class="fw-bold">ksh</b> , the <b class="fw-bold">ksh</b> script is run, a Korn shell session is opened, and <b class="fw-bold">$0</b> will
            hold the value <b class="fw-bold">ksh</b> .</td></tr></tbody></table>

### Linux Shell Common Characteristics

Despite their differences, all shells share some common characteristics.

<ul><li>The shell provides a command line interface that allows the user to interact with the Linux kernel.</li>
   <li>A Linux system can run multiple shell sessions at the same time.</li>
   <li>One shell session can run within another shell session. This may be done interactively, such as when a user starts a second shell from the first shell's command line or automatically, by scripts or programs.</li>
   <li>Shells use configuration files to establish their operating environments.</li></ul>

## 2.1.3 Shell Commands

### Shell Commands 00:00-00:32

In this lesson, we're going to talk about using shell commands. Even though most modern Linux distributions include some type of graphical user interface, most of the work you're going to do to manage a Linux System will be done from the shell prompt. For example, you may need to enter commands to run a program, finding information, managing files, and creating file systems. Therefore, you must be familiar with how to enter commands at the shell prompt.

Using the shell is done similarly to other operating systems. All you must do is enter the command that you want to run.

### Enter Commands at the Shell Prompt 00:32-01:04

Suppose you want to display a listing of all the files and directories within the current directory. To do this, type the ls command and press Enter at the shell prompt. A listing of all the files and folders is displayed when you do this.

Entering commands at the shell prompt is straightforward. Understand that you must be aware of a couple of issues when entering commands at the shell prompt. The first one is that the Linux shell handles the path to the executable you want to run in a manner that's different from other operating systems. If you've come from a different operating system environment, like a Windows environment, this can be a problem.

Linux utilizes a PATH environment variable, just like a Windows system does.

### PATH Environment Variable 01:04-01:41

When you enter commands at the shell prompt, the Linux shell doesn't look in the current directory first. This can be confusing for a new Linux administrator. The solution is the Linux path environment.

As you can see here, the PATH environment variable contains a list of directories. Each directory is separated by a colon in the PATH. As you can see here, if you want to view the PATH environment variable, you can type echo $PATH at the shell prompt. Remember, this shell won't be able to find files if that directory isn't in your PATH environment variable. Instead, the shell will return an error.

### Execute from the Current Directory 01:41-02:02

Let's suppose you have an executable file named zombie right here, in your user accounts home directory. Then we enter zombie right here, at the shell prompt. When we press Enter, it generates an error. This happens because the shell can't find the file we're trying to run here. Why is this? This user's home directory isn't included, by default, within the PATH environment variable.

### Options for Running Executables 02:02-02:50

There are three options for running executable files. The first one is to enter the full path to the executable file. In the previous example—because it's in my home directory and my username was jpatrick—I could've entered /home/jpatrick/zombie at the shell prompt. By doing that, the shell would then know exactly where that executable file resided in the file system, and then it could run it, whereas before, it couldn't.

A second option is to switch to the directory where the executable resides and then add a dot slash (./) to the beginning of the command. The dot slash characters specify the current directory, whatever it happens to be. By adding these characters to the beginning of the command, you tell the shell to look for the command you're entering in the current directory.

The final option is to add the directory where the executable resides to the list of directories in your PATH environment variable.

### Case Sensitivity 02:50-03:18

In addition to path issues, you also need to be aware that Linux file names and directory names are case-sensitive, and Linux commands are also case-sensitive. Therefore, if the executable file that you're going to run is named zombie with all lowercase characters, like we just saw, then you must enter zombie with all lowercase characters at the shell prompt.

Remember, this rule applies not just to file names, but to directory names as well. If you use the wrong case in a directory name in a path, it will point that shell to a completely different place in the file system.

### Command Completion 03:18-03:49

When entering commands at the Bash shell, there's a feature you'll grow to love called command completion. Some people call it tab complete—it's the same thing.

This feature is very helpful when you enter a very long file name, a very long directory name, or even a very long command name at the command prompt. When you start typing a few characters of the command, file name, or directory name in question and then press the Tab key, the Bash shell will guess what it is you want to type and automatically complete the command. This saves a lot of trouble, especially if you make a lot of typographical errors, as I do.

### Tab Completion Example 03:49-05:00

For example, suppose you have a file in your user's home directory named averylongfilenamefordemonstrationpurposes.txt. That's a long file name. You really don't want to have to type that all out if you're going to edit it. Let's suppose you do need to edit it for some reason. You want to pull it up in your vi editor. Well, one option would be to type out the full command: vi averylongfilenamefordemonstrationpurposes.txt at the shell prompt. However, the chances of typing the file name wrong are very high. To prevent this, you can use command completion to take care of the typing for you.

In this example, we start by typing vi, and then we enter the path of the file, which is in our home directory, so we enter ~/. And then we type the first three, or four, or five letters of the file name right here; we type avery. Then, instead of finishing out the entire file name, I press the Tab key at that point. When I do this, the bash shell will look at all the files within the specified directory and look for any of them that begin with A-V-E-R-Y. When it does this, it will determine that I probably wanted to open the file with the name averylongfilenamefordemonstrationpurposes.txt. So, it will add the full file name right here, at the end of the command. Then, all I must do is press Enter.

### Command History 05:00-06:13

The next feature of the shell that we want to talk about is command history. Understand that every time you enter a command at the shell prompt, that command is saved in a file in your home directory. The name of the file is .bash_history. This file is just a simple text file. It's a hidden file containing all of your previously entered shell commands, one on each line. This file is continuously updated every single time you enter a shell command.

You can display the contents of the .bash_history file by entering the history command at the shell prompt. When you do, a list of all your recent commands is displayed. This is really useful because if I need to run one of these commands again, all I have to do is press the up-arrow key at the shell prompt. When I do, the shell's going to read this file, and it will display the last command that I entered. If I press the up-arrow key, again and again, it will scroll through this list of previously used commands. When I hit the one that I want, all I have to do is press Enter to execute it.

This is useful, especially if you need to retype a very long, complex command. Be aware that if you don't want to arrow through all of your past commands to find the one you want, you can just enter part of the command you need and press Ctrl+R. When you do that, the bash shell is going to look through your command history and display the most recent command that matches the partial command that you started entering.

### Summary 06:13-06:32

That's it for this lesson. In this lesson, we discussed how to enter commands at the shell prompt and organize directories. We also talked about the command completion feature of the shell, using command history, and finally, we looked at several commonly used shell commands.

## 2.1.4 Enter Shell Commands

### Introduction 00:00-00:17

In this demonstration, we're going to learn how to enter commands at the Linux shell prompt. The Linux shell works in much the same way as the command prompt in a Windows environment. If I want to run a command, I type its name at the shell prompt and press Enter.

### The pwd Command 00:17-00:36

For example, if I wanted to run the pwd command, I would type the name of the command and then press Enter. The pwd command stands for print working directory. This command tells us where we are in the Linux file system. If I press Enter, it tells me that I'm currently in the /home/jpatrick directory.

### pwd and Tilde 00:36-01:01

The pwd command says that I'm in /home/jpatrick, but the native shell prompt simply shows a tilde (~) where the name of the directory would typically be listed. That's because the tilde on a Linux system is a shortcut that points to the /home directory of whatever user is currently logged in. I'm currently logged in as the jpatrick user, so my /home directory is /home/jpatrick.

### Full Directory Path 01:01-01:40

No matter what directory you're currently in, in the file system, the pwd command will display the name of that directory along with the full path to that directory. For example, I'm going to type the cd command to change directories to the /tmp directory. Now, if I type pwd, it tells me that I'm in the /tmp directory. If I want to switch back to my /home directory, I can use the tilde character. I type the cd command again to change directory and specify the tilde instead of typing the full path to my home directory, /home/jpatrick. Then press Enter, and I'm back to my jpatrick user's /home directory.

### The whoami Command 01:40-02:17

Another useful command is the whoami command. Whoami displays the name of the current user. You can see that I'm logged in as jpatrick. You might be asking, "Well, what's the significance of that command? Why would you need that?"

In Linux, it's common to switch between user accounts. For example, I may log in to the system with my jpatrick user, but when I need to perform administrative tasks, I'll need to switch to my superuser account, root. If I'm switching back and forth between jpatrick and the root user account, I might forget who I'm currently logged in as. Using the whoami command, I can easily determine which user account I'm currently logged in to.

### The su Command 02:17-02:46

In order to switch between user accounts, I use the su command. su stands for substitute user or super user and can be used to switch between different user accounts on the system. For example, I'm currently logged in as jpatrick. But if I wanted to switch to the ksanders user account on the system, I would type su ksanders. If I don't provide a username when using this command and just type su, the system will default to the super user account.

### The exit Command 02:46-03:19

Once I'm logged in as root, I can perform administrative tasks on the system as the superuser account. When I'm done, I should exit out of the root user account and go back to a standard user account for security reasons. I have two different options for switching back to the jpatrick user account. One would be to type su jpatrick to switch back to the root user account. An easier way to do it is to type exit and press Enter. When I do, I'm logged out of my root user account, and I'm switched back to my jpatrick user account.

### The uname Command 03:19-03:49

Another command that can be useful is the uname command. The uname command displays information about the system. If you just run uname without providing any parameters, all it does is tell you the name of the kernel running on this system. However, if you run uname with the -a option, it returns much more information, including the name of the kernel currently running, the hostname, the kernel release number, and the version date. Also listed are the machine hardware platform and some other system specific information.

### Summary 03:49-04:11

And that's it for this demonstration. In this demo, we discussed several Linux shell commands, such as pwd to show what directory you're in, whoami to show the logged in user, su to switch users, exit to log out of a shell, and uname to show system information.

## 2.1.5 Work with the Linux Shell

### Introduction 00:00-00:18

In this demonstration, we're going to look at several key features of the Linux shell. Specifically, we're going to explore the ls command, command history, tab complete, and several key path components that you should be aware of when using the Linux shell.

### Command History 00:18-00:33

Command history is a useful feature of the Linux shell. When you've already entered a command in a shell, you can reuse it without having to retype it manually every single time. Using the arrow keys, I can select a previously entered command and execute it again.

### The ls Command 00:33-01:15

The ls command is used to list files inside the shell. If we enter the ls command without other options, it will list the files in the current directory. By default, ls displays only non-hidden files. Within my home directory there are several hidden files that ls doesn't reveal unless you use options with it. If I want to view regular files and directories as well as hidden files and directories, I'll enter the ls command with the -a option, which stands for all, and it will display all files, including the hidden ones. A home directory typically has many hidden files. Linux distinguishes hidden files by adding a period before the file name.

### History Functions 01:15-02:10

In this user's home directory, you'll notice the file named .bash_history. This file stores commands you enter at the prompt. Once the command has been stored, I can access it using the up-arrow key. The .bash_history is then read, and you can scroll through previous commands using the arrow keys, listed in order from most recently entered.

For example, if I have previously run the uname -a command and wanted to run the command again, I could use the Up and Down arrow keys until I reach the uname -a command, press Enter, and the output for uname -a is displayed. Using the shell history is very efficient when you need to repeat a long or complex command.

You can see the commands stored in your history file with the history command. Type history at the prompt, and all the commands in the file will be displayed. They're listed in the order the commands were added to the history.

### Tab Complete 02:10-02:40

As you use the Linux shell, you'll often have to type long file names, directory names, or commands. Tab complete is a useful feature that can speed up your typing. Tab complete can be used as you start typing a command or filename in the shell. Instead of typing the entire command or path or filename, type the first few characters and then press the tab key. The shell will look for a matching command or file at the PATH variable or within the directory you specify.

### Tab Complete – In Action 02:40-03:14

For example, let's suppose that I need to change to the /etc directory in the file system. To do this, I would type the cd command, which stands for change directory, then press space, and then start typing the name of the directory that I want to change to. With tab complete, I can type /e and then, if I press Tab, it automatically fills out the rest of the directory name for me. It can do that because there's only one directory at the root of the file system that begins with an e, the /etc directory. Then I can press Enter, and it changes to the /etc directory.

### Tab Complete – Multiple Matches 03:14-04:03

There may be situations when tab complete comes up with more than one match. When that occurs, nothing comes up after I press tab. The reason may be that there are multiple directories or files beginning with the same search criteria. For example, I'm going to type cd Do to switch to my Downloads directory. I press Tab, and nothing happens. To see what the multiple matches are, you can press the Tab key twice. It tells me that there are two matches, Documents and Downloads. To continue using tab complete without typing the entire name, I can add more characters to narrow down the matching files or folders. In our example, if I type cd Dow then press the Tab key, there's only one match. Pressing Enter switches me to the directory I want.

### Paths 04:03-05:01

The last feature we'll cover in this demonstration is the path system. When I type the 'ls' command to view a listing of all files in my /home directory, notice that there's one file here that's in green. The green color identifies the file as an executable; in this case, the file is a script made into an executable that can be run in the shell prompt.

Most operating systems can run an executable located in the current directory. I would just type 'hello', and it should work. However, when type the file name, it fails and says, "Hey, I can't find this file."

This is one of those things that's frustrating for new Linux users because you look and think the hello is in my current directory. Why is that the case? In operating systems, such as windows, the environment will look in the current directory for the command. If it finds it in that directory, it will run. If it doesn't in the current directory, it will look in all directories. Remember, the Linux shell does not do that.

### Path Options 05:01-06:10

If your current directory, in this case /home/jpatrick, is not found in the path environment variable, then it cannot run the executable. What do you do in that situation? There are three different options.

The first is to explicitly specify the directory where the executable file resides, in which case the Linux shell can find the file and run it. In this case, I can enter '/home/jpatrick/hello' and run it. It will work because I told the Linux shell explicitly where that file resides.

Actually, to make things shorter when running commands in your home directory, I could have typed ~/hello. Remember, the tilde is a shortcut for the home directory of the current user.

Another option is to specify the current directory. This can be useful if you're dealing with an executable that's in a folder somewhere in the file system buried many layers deep, and you don't want to find and type out the full path. You can use the ./ shortcut to specify that the command you're about to run exists in the

current directory. ./ always means current directory. So I can enter ./hellohec, and it runs without typing the whole directory.

### Summary 06:10-06:28

And that's it for this demonstration. We talked about the features of the Linux shell. We looked at the command history, hidden files, history functions, tab complete, and ended the demonstration by discussing Linux shell paths.

## 2.1.6 Linux Shell Command Facts

The Linux shell is a text user interface that provides a command line interface (CLI). Users employ the shell to interact with the Linux kernel by typing commands at the shell prompt.

This lesson covers the following topics:

<ul><li>Bash shell command line prompt</li>
   <li>$PATH Linux shell environment variable</li>
   <li>Running an executable file</li>
   <li>Command history feature</li>
   <li>Tab complete feature</li>
<li>Common Linux shell commands</li></ul>

### Bash Shell Command Line Prompt

Each Linux shell type has a customizable command line prompt. For the Bash shell, the default command line prompt varies with each Linux distribution but is generally displayed in the following format:

<ul><li>The username of the current user</li>
   <li>The @ symbol</li>
   <li>The hostname</li>
   <li>A space</li>
   <li>The base name of the current working directory
<br>
<div><div class="to-info-box"><div class="to-info-box-body"><span class="to-icon large" aria-hidden="true"><svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></span><div class="to-info-box-body-content"><span>
If the current working directory is the home directory (the default directory when the user first logs in), the tilde symbol ( <b>~</b> ) is displayed instead.</span></div></div></div></div></li>
<li>A character that indicates the type of user:
<ul><li>The # character typically indicates that the current user is the root user.</li>
<li>The $ character typically indicates that the current user is a normal user.</li></ul></li></ul>

### $PATH Linux Shell Environment Variable

The $PATH environment variable contains the set of directories that are searched when you type an executable file at the shell prompt.

<ul><li>The shell does not look (by default) in the current working directory for the executable file.</li>
<li>To see the list of directories, type <b class="fw-bold">echo $PATH</b> at the shell prompt.</li>
<li>To add a directory to a path, type <b class="fw-bold">PATH=$PATH:[directory_path]</b> and then type <b class="fw-bold">export PATH</b> .</li></ul>

### Running an Executable File

The following table describes how to run executable files.

<table><thead><tr><th scope="col" class="fw-bold">
File Location</th>
<th scope="col" class="fw-bold">
Run Action</th></tr></thead>
<tbody><tr><td>Resides in a directory that is included in the $PATH environment variable.</td>
<td>Type the filename at the shell prompt.</td></tr>
<tr><td>Resides in the current working directory, and the current directory is not included within the path environment variable.</td>
<td>Type <b class="fw-bold">./</b> followed by the filename.</td></tr>
<tr><td>Does not reside in the current working directory,and its directory is not included within the path environment variable.</td>
<td>Type the full or relative path to the executable
file.</td></tr></tbody></table>

> File names and paths are case-sensitive.

### Command History Feature

The Linux shell keeps a history of commands you type at the shell prompt.

<ul><li>The commands are stored as a history queue within the hidden `.bash_history` file in your home directory.</li>
<li>Press the <b class="fw-bold">Up</b> and <b class="fw-bold">Down</b> keys to scroll through your previously typed commands.
<ul><li>You can edit the command or re-run it as is by pressing <b class="fw-bold">Enter</b>.</li></ul></li>
<li>Type <b class="fw-bold">history</b> to display the commands stored in the history queue.</li>
<li>Type <b class="fw-bold">history -c</b> to clear the history queue.</li>
<li>Using a <b class="fw-bold">space</b> before a command prevents the command from appearing in the history.</li></ul>

### Tab Complete Feature

#### Tab

<ul><li>After typing the beginning of a command, file, or directory, press <b class="fw-bold">Tab</b> to complete it.</li>
<li>If pressing Tab does not fully complete the command, file, or directory, press <b class="fw-bold">Tab</b> again.
<ul><li>If there is no matching command, file, or directory name, your
command entry will not change.</li>
<li>If there is more than one matching command, file, or directory name, a list of all matches will be displayed to help you resolve your command entry.</li></ul></li></ul>

### Common Linux Shell Commands

The following table describes several common commands used at the shell prompt.

<table><thead>
<tr><th class_="firstTableHeader" scope="col" class="fw-bold">Command</th>
<th scope="col" class="fw-bold">
Function</th></tr></thead>
<tbody><tr><td><b class="fw-bold">pwd</b></td>
<td>Shows the present working directory.</td></tr>
<tr><td><b class="fw-bold">whoami</b></td>
<td>Displays the current username.</td></tr>
<tr><td><b class="fw-bold">uname</b></td>
<td>Prints system information. The <b class="fw-bold">uname</b> command has the following options:
<ul><li><b class="fw-bold">-a</b> prints all system information.</li>
<li><b class="fw-bold">-o</b> prints the operating system.</li>
<li><b class="fw-bold">-p</b> prints the processor's architecture type.</li></ul></td></tr>
<tr><td><b class="fw-bold">su</b></td>
<td>Switches users in the shell prompt. The <b class="fw-bold">su</b> command has the following options:
<ul><li><b class="fw-bold">su -l</b> <b class="fw-bold">[username]</b> switches to the specified user
and creates a new login shell.</li>
<li><b class="fw-bold">su</b> <b class="fw-bold">[username]</b> (without the dash, but with the
username) switches to the user in the current shell.</li>
<li><b class="fw-bold">su -</b> <b class="fw-bold">[username]</b> (with the dash and the
username) switches to the user and loads that user's
environmental variables.</li>
<li><b class="fw-bold">su -</b> (with the dash but without the username)
switches to the root user and loads the root user's
environmental variables.
<ul><li>The root user account is the Linux system superuser.</li>
<li>The root user can perform any task. Some utilities do not work if the administrator is not logged in as the root user.</li></ul></li>
<li><b class="fw-bold">su</b> (no dash or username) switches to the root user but does not load the root user's environmental variables.</li></ul>
<div><div class="to-info-box"><div class="to-info-box-body"><span class="to-icon large" aria-hidden="true"><svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></span>
<div class="to-info-box-body-content"><span> <b>su</b>requires the password of the user except when switching from root to a normal user.</span></div></div></div></div></td></tr>
<tr><td><b class="fw-bold">exit</b></td>
<td>Exits the current shell (which may close the login
shell) or to go back to the original user after using the <b class="fw-bold">su</b> command.</td></tr>
<tr><td><b class="fw-bold">exec</b></td>
<td>Executes an executable to replace the shell
process with the new process created by the executable file.</td></tr>
<tr><td><b class="fw-bold">cd</b></td>
<td>Changes directories. For example, when the <b class="fw-bold">/usr</b> directory is the current directory:
<ul><li><b class="fw-bold">cd bin</b> changes to the <b class="fw-bold">bin</b> directory in the
current directory.</li>
<li><b class="fw-bold">cd /usr/bin</b> changes to the <b class="fw-bold">/usr/bin</b> directory
from anywhere in the file system.</li></ul></td></tr>
<tr><td><b class="fw-bold">ls</b></td>
<td>Shows names of files and directories in the
current directory. The <b class="fw-bold">ls</b> command has the following options:
<ul><li><b class="fw-bold">-a</b> shows all files and directories, including hidden
files.</li>
<li><b class="fw-bold">-l</b> shows extended information about files, including
size, permissions, owner, and modified date.</li>
<li><b class="fw-bold">-d</b> displays only directories.</li>
<li><b class="fw-bold">-s</b> sorts files by size.</li>
<li><b class="fw-bold">-X</b> sorts by extension.</li></ul>
<p>Many distributions use a color scheme to identify different file
types as follows:</p>
<ul><li>Directories are blue.</li>
<li>Text files are white.</li>
<li>Links are cyan.</li>
<li>Executable files are green.</li>
<li>Compressed files are red.</li></ul></td></tr>
<tr><td><b class="fw-bold">history</b></td>
<td>Shows all the commands in the history queue. The <b class="fw-bold">-c</b> option clears the history list.
<br>
<div><div class="to-info-box"><div class="to-info-box-body"><span class="to-icon large" aria-hidden="true"><svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info " role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></span><div class="to-info-box-body-content"><span>
History command queues are separate for
each user. For example, a command typed as one user cannot be used after using the <b>su</b> command to switch to another user.</span></div></div></div></div></td></tr>
<tr><td><b class="fw-bold">clear</b></td>
<td>Clears the shell screen.</td></tr>
<tr><td><b class="fw-bold">chsh</b></td>
<td>Changes the default shell. The <b class="fw-bold">chsh</b> command has the following options:
<ul><li><b class="fw-bold">-s</b> changes to a different installed shell. The command prompts for a password.</li>
<li><b class="fw-bold">-l</b> lists all installed shells.</li></ul>
For example, <b class="fw-bold">chsh -s /bin/ksh [username]</b> changes the default
shell for the user to the Korn shell if it is installed on the computer.</td></tr></tbody></table>
