---
lang: zh-CN
title: Section 14.3 Bash Scripting Logic
description: some description
---

As you study this section, answer the following questions:

<ul><li>What constructs are used for branching in a bash script?</li>
<li>What is the difference between the if/then/elif/fi construct and the case/esac construct?</li>
<li>What constructs are used for looping in a bash script?</li>
<li>What is the difference between the while, until, and for constructs?</li>
<li>How are exit codes used?</li></ul>

In this lesson, you will learn to:

- Use looping
- Use exit codes
- Use branching

Key terms for this section include the following:

<table class="terms">
<thead>
  <tr>
    <th>Term</th>
    <th>Definition</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>Branching</td>
    <td>
      The logic in a bash script that performs different actions based on
      a specific condition or user input.
    </td>
  </tr>
  <tr>
    <td>Looping</td>
    <td>
      The logic in a bash script that repeatedly runs a set of commands
      according to a specific set of conditions.
    </td>
  </tr>
  <tr>
    <td>Exit code</td>
    <td>
      A value that is set when a bash command or script is executed.
    </td>
  </tr>
</tbody>
</table>

This section helps you prepare for the following certification exam objectives:

<table class="objectives">
<thead>
  <tr>
    <th>Exam</th>
    <th>Objective</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td>CompTIA Linux+ XK0-005</td>
    <td>
      3.1 Given a scenario, create simple shell scripts to automate common
      tasks
      <br />
      <ul>
        <li>Shell script elements</li>
        <ul>
          <li>Loops</li>
          <ul>
            <li>while</li>
            <li>for</li>
            <li>until</li>
          </ul>
          <li>Conditionals</li>
          <ul>
            <li>if</li>
            <li>switch/case</li>
          </ul>
          <li>
            Standard stream redirection
            <ul>
              <li>||</li>
              <li>&amp;&amp;</li>
            </ul>
          </li>
          <li>Exit codes</li>
        </ul>
      </ul>
    </td>
  </tr>
</tbody>
</table>

## 14.3.1 Bash Scripting Logic

Click one of the buttons to take you to that part of the video.

Bash Scripting Logic 00:00-00:32
Let's talk about using control structures within shell scripts. A basic shell script typically executes straight through, from the beginning to the end. This may work fine in some situations. But suppose we needed the script to make decisions based on user input or the output from a command. This can be done by implementing control structures within the script. There are several different types of control structures that we can use, and each one functions in a slightly different way. We're going to look at if-then-else, case, and looping structures that you can use within a script.

The if/then/else/fi Construct 00:32-01:16
Let's begin by looking at the if-then-else structure. Using an if-then-else structure within your shell script gives your script the ability to execute different commands based on whether a particular condition is true or false. The structure is shown here. We enter 'if' followed by a condition. The if part of the structure tells the shell to determine whether or not this condition, right here, evaluates to true or if it evaluates to false. If the condition evaluates to true, then this set of commands will run. If the condition evaluates to false, we execute the commands that fall under "else." This kind of structure can be useful in situations where we need to branch based on user input.

When you're done with the if-then-else statement in the script, you'll end it by spelling if backward, 'fi'.

Input Validation 01:16-02:51
This kind of structure can be useful in situations where we need to branch based on a user's input. It's also useful in situations where we need to validate the input that the end user has entered from the read prompt. Input validation means we want to check and see whether the user entered a valid value at the prompt or whether they entered something that's either incorrect or doesn't match what we're looking for.

For example, let's suppose we've created a script, and the script will ask the end user to enter the name of a directory that he or she wants to add to the end of the PATH environment variable. When we add the directory to the PATH, it would be a good idea to run a quick test and just verify that the directory that the end user entered exists in the file system. If it does, then we should go ahead and add it to the PATH environment variable. If it doesn't exist, we should post an error message on the screen, telling the user that the directory can't be found. This is what this structure here does. In this example, we have our condition right here. This condition calls a utility called test. It tells test to check and see whether the directory contained in the newpath variable exists. This is specified by the -d option. Essentially, this condition runs test -d followed by the path the end user entered in the read prompt in the script. And all the test command does is verify whether the directory exists or not. If it's true—if test runs and it finds this directory that the end user entered—then we run this set of commands. But if it doesn't exist, then we run the "else" part of the if-then-else structure, in which case, we just use the echo command followed by the name of the path they entered. Then we add text, saying, "Hey, this doesn't exist."

The test Command Options 02:51-04:35
The test command we just looked at is extremely useful within an if-then-else structure. There are several other options that you can use with test within an if-then-else structure to perform other types of tests.

We already looked at -d. The -d option checks to see if a particular file exists. If it does, is it a file, or is it actually a directory? If it's a directory, it returns a value of true. If it's not a directory, or if it doesn't even exist, then we get a value of false.

-e checks to see if a file exists. Understand that the -e option doesn't differentiate between files or directories. All it does is look and see if there's an entity in the file system with the name you specify. And if it's there, we return a value of true. If not, we return a value of false.

The -f option is kind of the counterpart of -d. It checks to see if the file that you're looking for exists. And, if it does, is it an actual file and not a directory?

The -G option, capital G, checks to see if the file exists and whether or not that file is owned by a specific group.

The -h or �L option with test will check to see if the file exists and whether or not that file is a symbolic link.

The -O option checks to see if the file we specify exists and whether it's owned by a particular user account.

The -r option checks to see if the file exists and whether the read permission has been granted to that file.

-w checks to see if the file exists and whether or not the write permission has been granted.

-x checks to see if the file exists and whether or not the execute permission has been granted.

As you can see, you can use test to evaluate all kinds of conditions with respect to files and directories in the file system. Test isn't limited to just seeing whether or not a file or directory exists.

Comparing Text and Numbers 04:35-05:11
For example, this command will check to see if text1 is the same as text2. Is it true, or is it false? You can also check to see whether these two text strings aren't the same. We enter 'test' followed by the first text string, then the exclamation point and an equals sign (!=), and then the second text string. In this case, if the two text strings aren't the same, it will evaluate to true. If they're the same, it will evaluate to false.

For example, we can use test to see if num1 equals num2, true or false? We can also test to see whether or not num1 is less than num2, or we can also test to see if num1 is greater than num2.

Case Construct 05:11-06:03
You can also use a related structure in your scripts called a case structure. If-then-else works great if we have a particular condition that can be evaluated in one of two ways, either true or false. But if-then-else doesn't work so great if we need to evaluate a condition that could be evaluated in many different ways. If there are more than two ways a condition could be evaluated, you should use a case statement instead. The structure of a case statement is shown here. We start with 'case,' and then we have a variable. If the variable matches response one, then we run this set of commands. If it's the second response, we run this set of commands. If it's the third response, we run this set of commands. And notice that we end the case statement with case spelled backward, 'esac.'

When you're ready to end your case, you spell case backward, 'esac.' That tells the script, "Hey, we're done with the case statement."

A Case Example 06:03-07:36
Let's look at a simple example.

Here, we have a script that asks users what county they were born in a particular state. Based on their response, we can cause the script to provide a customized response using a case statement.

This script first asks the user what county they were born into, and it reads their response into a variable called mycounty. Then, using the value of mycounty, the case statement determines what part of the state they were born in using a case structure. We reference the mycounty variable in the case statement and then provide different responses.

Notice here that we have three different responses. They're separated by pipe characters; that means "or." If the value of mycounty equals Bingham, Bonneville, or Bannock, then we run the echo command, saying, "Being born in" whatever county they entered, you were born in eastern Idaho." If the value of the mycounty variable is Ada, Owyhee, or Canyon, we run the echo command, saying, "Being born in whatever county you entered, you were born in western Idaho." We do the same thing for Cache, Oneida, and Franklin; tell them they were born in southern Idaho. And we do the same thing, again, for Bonner, Shoshone, and Kootenai, which says that you were born in northern Idaho.

Notice, down here, that we have this response, this star (\*). This is very important because, within the case statement, it's possible that they either provided a response that isn't included in any of the responses here or that they may have misspelled their response and cannot be matched. When this happens, the response will default to the star location, and then it will run the echo command to put this text on the screen.

While Loop 07:36-08:11
If-then-else, as well as case structures, are called branching structures because, depending upon how a condition evaluates, the script branches in one direction or another. You can also use a different kind of structure in your scripts called a looping control structure. Looping control structures come in three different varieties. We have the while loop, the until loop, and the for loop.

Let's take a look at the while loop first. A while loop executes over and over until the specified condition here is no longer true. As long as this condition is true, run these commands. When that condition becomes false, then it will exit out of the loop.

Until Loop 08:11-08:34
In addition to a while loop, you can also use an until loop in your script, which works in the opposite manner of a while loop. An until loop will run over and over as long as this condition here is false. Remember, with a while loop, it runs as long as that condition is true. As long as that condition is false, these commands will run. When that condition becomes true, it will exit out of the loop and continue on.

For Loop 08:34-09:04
A for loop operates in a very different manner than while or until. Remember, the until and while loops will just keep looping indefinitely until the specified condition is met. A for loop, on the other hand, will loop a specified number of times. The structure is 'for i in' whatever we specify, run these commands. And it will keep looping a certain number of times. You'll notice here that we use the sequence command, seq. It's very common to use a sequence command within a for loop to create a sequence of numbers that determines how many times it's going to loop.

The seq Command 09:04-10:20
There are three ways to create a number sequence with the sequence command. For example, if I specify a single value—such as 'seq 10'—then the sequence is going to start at one, and then it's going to increment by one and end at the value I specified so that it will go one, two, three, and so on, until it reaches 10, and then it will stop. This'll cause the for loop to loop ten times. Then it's going to exit out of the loop.

You can also use the sequence command with two numbers. For example, if I enter 'seq 5 10' (with a space between 5 and 10), then the sequence will start at the first value, increment by one, and then end at the second value. In this case, the first number generated by sequence would actually not be one but five, and then we'd go six, seven, and so on until it reaches ten, and then it would end.

You can also specify three values with the sequence command, say, 'seq 1 2 10.' This tells the sequence command to start at the first value, 1, but increment by two and end at 10. In this case, it would start at 1. But then, because we're incrementing by two, the next number would be 3, 5, and so on. It would actually end at 9 in this case. It can't go to 10 because it increments. The next increment would be 11, which is beyond the ending range.

for and seq Command 10:20-11:14
In this example, we're going to create a sequence of numbers from 1 to 15 because we only specified one number. We're going to start at 1, and we're going to increment by one until we reach 15. Notice that the value that we generate with the sequence command is going to be assigned to this variable, right here, named i. Each time we go through the loop, i is going to increment by one.

The first time we run it, it's going to be 1. The second time we run it, i is going to be 2. The third time through the loop, i is going to be 3, and so on. And we reference that value down here with the echo command. We say what the current number in the sequence is followed by whatever the current value of i is.

When we run this script, we'd have 15 lines in the output, each one saying, "The current number in the sequence is," and it would start at 1; then, in the next line, the value of i would be 2; the third line, the value of i would be 3; and so on, until it hits 15, in which case, the for loop would break.

Endless Loop 11:14-11:32
The biggest danger with looping structures is that it's possible to actually get stuck in the loop, where it loops over and over and never breaks. We call this an infinite loop. This happens when the condition never changes to a value that'll break the loop. It will continue to loop for eternity until you manually break out of it using the Ctrl+C key.

Summary 11:32-11:49
In this lesson, we looked at several control structures you can use within a shell script. We first looked at the if-then-else structure. We looked at the case structure. Then we looked at looping structures: while, until, and for.

## 14.3.2 Looping

Click one of the buttons to take you to that part of the video.

Looping 00:00-00:34
In this demonstration, we're going to discuss looping. We often see this used in shell scripts to help automate common tasks. When working with shell scripts, a loop enables you to execute a set of commands repeatedly. The three most common looping types are the for loop, the while loop, and the until loop. Each of these types of loops provides a unique way to deal with different scenarios.

To demonstrate the different kinds of loops more quickly, I'll show them to you interactively instead of taking the time to put them into an actual script.

The for Loop 00:34-00:43
The for loop is probably one of the more common types that's used. The purpose of a for loop is to repeat a list of items, such as text or numbers.

Looped Commands 00:43-02:20
Let's look at a very simple for loop with text. First, we need to specify the type of loop by typing for. Next, we need to specify a variable name that'll hold each item in our list. Let's use a variable name of fruit. Then we use the keyword in. This keyword describes what's going to be coming into our variable next. Then comes our list of items we want to work with: apple, pear, and plum. I could add a semicolon to end this first part of our loop commands, but to make it easier to see, I'll press Enter and add the next statement on a new line.

For the next part of our for loop, we need to specify what to do with each of these items in our list. This is done by adding the word do. In other words, what do I want to do with each item in my list? I'll specify this on the next line, which will be to simply echo or write each item in my list. This is done by telling the echo command to print what's in the variable, using the $ and the name of the variable, which is fruit. To end our loop, we use done. To see how the loop functions, let's press Enter, and we see that the echo command was repeated once for each item in the list.

Now, let's press the up key and modify this script to use numbers. Although we didn't enter them, the semicolons were added as separators for each part of the script. I'll first change the name of the variable to n since we're going to be working with numbers. Then I'll replace all the names of fruits with the numbers 1, 2, 3, 4, and 5. Now when I press Enter, you see that the numbers 1 through 5 are echoed to the screen.

Iteration Options 02:20-03:09
To simplify the construction of the loop, you can use various methods to create your lists. With numbers, you can specify a range. Do this by using the curly brackets to specify a set of numbers. Using the same basic script, let's replace our numbers with {1..5}. When I press Enter, you see that it printed the numbers 1 through 5.

Starting with Bash 4, it's also possible to specify an increment when using ranges. Let's change this loop to use the range of 0 to 25, and then we'll specify an increment by adding two periods and the number 5, meaning that we only want to print every fifth number. Pressing Enter, we see that it printed the first number and then only printed every fifth number until the value of the range had been met.

The C Construct 03:09-04:49
The last variation of the for loop uses a C-style construct. With this type of loop, we're going to look for a test or condition to determine how long the loop should run. Once that test or condition has been met, the loop ends.

We begin with the word for but then use double open parentheses. That tells us we're going to be using expansion. We again use our variable n, but this time we have to define what the starting value, or number, will be. We'll use 0 again, which is followed by a semicolon as a separator. Next, we need to specify at what point do we stop the loop. Let's say that when n is either less than or equal to the number 10, continue to loop. This is again followed by a semicolon.

The last thing we need to do is to specify how the starting value of our variable—in this case, zero—will be incremented. We'll accomplish this by using the variable n followed by two ++. This means that for each loop, increment the value of the variable by adding 1. To end this construct, we need to add two closing parentheses and a semicolon.

The rest of the loop is similar to the way we did things before. I'll press Enter and add do. Now I'll press Enter again and add my task, which is to echo "Number = $n", and then Enter again. And to close the loop, we end it with done. When I press Enter to run the script, we see that it printed the numbers 0 through 10.

Let's run it one more time, but this time, let's set the starting value of n to be 5. And when I press Enter, you see that it started at 5, but still ended at 10.

The while Loop 04:49-06:37
Let's move to the next type of loop, known as the while loop. As the name suggests, this type of loop continues looping while, or as long as, a specific condition is true. This can be used for things like traversing a directory or looking for a specific type of file. As long as the file type can be found, the loop will continue.

You could use a while loop to display an error message as long as a user fails to enter the requested input. The construct of the while loop is similar to the for loop, but in a for loop, we set the beginning value of the variable in the loop. With a while loop, a variable is created outside of the loop itself. To create a variable, let's type n=0 and press Enter.

Now we can configure our loop. We start with the keyword while, and then we'll enter our condition. To begin the condition, we type a left bracket and then a space. For this example, we want the condition to be that the n variable must be less than 10. To do that, we type $n -le for less than, the value of 10 followed by space, and then the closing bracket and a semicolon to end this segment.

Next, we enter the keyword do, just like we did with the for loop. And then what we want to do to is echo the contents for the $n variable, followed by a semicolon. Then, before ending our loop, we need to increment the value of n. This is done by using the two (( and n++, followed by two )) and a semicolon, just like we did before. This will add 1 to the n variable each time it loops. Now to finish the loop, we type done. When I press Enter, we see that the numbers 0 through 10 are printed.

The until Loop 06:37-07:40
The last loop we'll discuss is the until loop. This loop type is the opposite of the while loop. With the while loop, we keep looping while the condition or test is true, but with the until loop, we want to keep looping until the condition is true. Or in other words, we keep looping as long as the condition or test is false.

To see how this works, let's do basically the same thing we did before by first setting our variable, n, to the value of 0. But now, we're going to say until the value of n is equal to 10. We'll go ahead and put our semicolon in again. Let's enter our do statement. Everything else is the same. We'll still echo the value of n and increment it. Okay, now we're done.

Now when I press Enter, you see that the results are almost the same. With the while loop, we printed the values of 0 through 10. But with the until loop, once our variable reached 10, we ended the loop so that the output ended at 9 instead of 10.

Summary 07:40-07:51
Well, that's it for this demonstration. We walked through how to use the for loop, the while loop, and the until loop.

## 14.3.3 Exit Codes

Click one of the buttons to take you to that part of the video.

Exit Codes 00:00-00:10
In this demonstration, we're going to discuss how exit codes can be used to help evaluate or troubleshoot scripts.

Successful Exit Code 00:10-00:40
To illustrate how exit codes work, let's first run a command successfully and then look at its exit code. We'll use the touch command to create a file named myfile.

I can now run the ls myfile command, which runs successfully and lists the file. To see the exit code associated with this command, I'll run echo $?, and the result is zero. Zero (0) indicates that the program or the procedure ended successfully.

Error Exit Code 00:40-01:33
Now let's look at what happens when a command is not run successfully. To show this, I'll run ls, but this time I'll misspell the name of the file by leaving off the last letter. When I press Enter, an error message telling me that the file doesn't exist is shown.

To see the exit code for an unsuccessful command, we'll run echo $? again, and this time the number two is shown. By default, two (2) means, "file not found." With this basic knowledge of how exit codes work, I now want to show you how you can define your own exit code numbers to mean different things.

To see how this works, let's first change to the /usr/local/bin directory. In this directory, I've created two scripts that we can use to see how custom exit codes can be used. I chose this directory because it's in our $PATH environment variable.

PrintCodes Script 01:33-02:16
Let's first look at the PrintCodes script using the cat command. The purpose of this script is to run a different script named ConditionCodes.sh, and then, depending on the exit code when the ConditionCodes script is run, the PrintCodes script will display a different message. For example, if the exit code returned when the ConditionCodes script is run is 101, I want to display, "Error 101, You must be the root user to run."

On the other hand, if the exit code is 102, the message "The configuration file does not exist" will be shown. And finally, when an error code of zero is returned, then we'll be told that the script was "Successfully completed!".

Define Custom Exit Codes 02:16-03:10
To see how these error codes of 101 and 102 are defined, let's cat the ConditionCodes.sh script. In this script, I have several conditions I'm searching for, and depending on the condition found, I've assigned a custom exit code or used a default code. For example, in this first line, I'm checking to see if the person running the script is the root user. If the user is not the root user, then the script will end with an exit code of 101.

In the next section, I have an "else if" line that says that if the user is root, check to see if the file named exe.conf exists in my current directory. If that file doesn't exist, then end the script with an exit code of 102. If both of these other tests are true, meaning I am the root user and the exe.conf file does exist in my current directory, then end with an exit code of zero, meaning the script ran successfully.

Run the Script, Not root User 03:10-03:38
Let's clear the screen and see how all this works. To start, let's see what happens when I try to run the ConditionCodes script as a regular user. To do this, I'll type PrintCodes.sh and press Enter. Notice that since I wasn't the root user, the ConditionCodes script used the first condition and ended the script with an error code of 101. The PrintCodes script then saw this and printed the prompt telling us we needed to be the root user.

Run the Script, No Configuration File 03:38-04:06
Let's try that again, but this time, let's first switch to the root user by running su - and entering my root password. Now when I run PrintCodes.sh, notice that the ConditionCodes script detected that I was the root user, so it then checked to see if the configuration file existed. Since it didn't, the ConditionCodes script ended with an exit code of 102, and then as before, the PrintCodes script saw that code and printed the applicable message.

Run the Script, Successful 04:06-04:31
To test our last condition, let's first create our configuration file by running touch exe.conf. When I run PrintCodes.sh again, the ConditionCodes script sees that not only am I the root user, but my configuration file exists in my current directory, so it ends with an exit code of zero. Then, the PrintCodes script printed a message that the script completed successfully.

Summary 04:31-04:43
That's it for this demonstration. In this demonstration, we showed you how exit codes work and how to test for exit code completion.

## 14.3.4 Branching

Click one of the buttons to take you to that part of the video.

Branching 00:00-01:11
In this demonstration, we will be discussing branching, if-then-else statements along with case and test statements.

First let's look at a script that I've written. We'll go ahead and edit that. We'll call it branching. It's pretty straightforward script. We have the identifier letting the system know it is a script and then I've declared of variable. I've declared the variable 'TODAY', and I've just arbitrarily set it to 'Tuesday'.

Using if-then-else statements, what I did was, I wrote a few tests here to see and determine what day of the week it is. I did this for demonstration purposes, but it would be just as easy to write a routine that will extrapolate the date from the system date. But again, in this case, just for ease of demonstration. I set a variable, and we called it 'TODAY'.

The if Statement 01:11-02:08
My first statement is an if statement, and what I do is I compare the variable TODAY. That's what this dollar sign ($) means. The dollar sign indicates that I'm about to use a variable name. The variable name is 'TODAY' and I'm testing to see if 'TODAY' equals Monday. I could very easily do other tests as well. I can set other variables and test for any equality that may be. We then follow with a semicolon (;), and that's necessary as part of the scripting language, followed by the word then.

I'm testing using 'if '. This is my statement to be true or false. This is saying, "If 'TODAY' is equal to Monday (clearly it's not), then, if it were true, then we would do the next statement, 'echo Monday'." Well, it's not Monday so we can't do that.

The elif Construct 02:08-02:43
In Linux, in bash scripting, there's another command called 'elif'. What the 'elif' does, it's a combination of else and if. Basically, what it's saying here is 'elif'. In other words, I already know it's not Monday. So now I'm going to test something else. I'm going to say else, if, 'elif TODAY' is equal to Tuesday. If that's true then I go ahead and 'echo Tuesday'. So that's true. What happens is it skips all the rest of the statements.

The fi Construct 02:43-03:46
In scripting, every if ends with a 'fi', a backwards 'if'. That's the way it's done in bash scripting. The 'if' statement checks for equality follows the 'then', if the statement is true. Otherwise, it follows the 'else'. 'else' is optional. 'elif' is optional. I can just do a test. I could have said, if 'TODAY' is equal to Monday, then 'echo Monday', 'fi', and that's all it would've done. Basically it wouldn't have done anything.

If you look through, I have the 'if', a variable, test for equality, test the string itself, 'Monday', and this is what I do if it's true, this is what I do if it's false. I just continue that. I do another test, test for equality, if it's true, I do this, if it's false, I do this. And I do that continuously throughout this test. So that's how 'if', 'then', and 'else' works.

The case Statement 03:46-05:05
To show something else, I changed a little bit. I'm using a 'case'. I've change the day, so 'TODAY' is equal to 'Sunday'. Now I'm doing a bunch of tests in one. The first thing is the word 'case', the 'case' statement defines multiple tests. The first thing I do is determine what it is I'm testing against. What is it I'm trying to find. Then the word 'in', and then I specify all of the different values that I want to test against. It's a value, followed by a closed parentheses, or parens.

Then, I have my commands. I can have one. I can have many, and they all end with the double semicolon (;;). Then, I can go on and test the next thing. This is often used when testing for a particular parameter, or particular keyword. We use cases quite a bit. Again, this last one here, I'm using the vertical pipe which in this case means 'or'. If 'TODAY' is equal to 'Saturday' or 'TODAY' is equal to 'Sunday', then I'm going to 'echo' the 'Weekend'.

Run the Script 05:05-05:47
Let's see how this runs. I'll go ahead and exit out, and I will go ahead and run branching. The first test shows us 'Tuesday'. The second shows us 'Weekend'. One more time we'll look at the script, and you'll see that at the beginning, 'TODAY' is defined as 'Tuesday'. After the if, else-if statements are are finished, I then change the value to 'TODAY' is 'Sunday'. If 'TODAY' is 'Saturday' or 'TODAY' is 'Sunday', then 'echo Weekend', and that's exactly what we saw.

The test Statement 05:47-06:46
There is third type of value, and that's called test. The test command is good for a single test, a single examination or validation, to determine if something is either true or false. Often it's used to determine whether a file or a directory exists, as one example. What's different between this and the 'if' statement and/or the 'case' statement, is we can really only test one thing at a time to make this make sense. What I've seen it used for is to test to see if a file exists. Let's do that. The keyword is 'test', then I do my equality. I test for the existence. I can check for existence, nonexistence, directory name, filename, zero-byte file. There's many, many tests that I can do, For this example, I'm just seeing if a file exists.

Double Ampersand and Double Vertical Bar 06:46-07:52
As we saw before, I created the 'branching' script. We'll just see if that branching script exists. Obviously, we know it does. The next part is a double ampersand (&&), and what the double ampersand (&&) means is the same thing is that then, in an if-then-else statement. The test is going to determine whether or not something is true. This keyword test is the command itself. What I'm testing is to see if the file 'branching' exists, so that's my test, '&& echo "File exists"'.

We need the else component. Well, what if the file does not exist. What if this test here is false. Then, over here we use a double vertical bar (||). That's the same thing as an else in the if-then-else statement. Anything following this means that the test was false.

Review and Run 07:52-09:03
The keyword is test, that's the command. I'm testing to see if the file 'branching' exists. If it does, if the result is true, then I'm echoing the 'File Exists'. If the result is false, then I'm echoing, 'No file'. Press Enter, and sure enough the file does exist.

Well, let's just test something just to show you how this works. So 'test', I'm going to check for the existence of 'testout'. We know that doesn't exist. Again, I'll do the exact same thing, 'echo "File exists"', else, 'echo "No file"'. This time, pressing enter, of course, since 'testout' does not exist, 'No file' is what is displayed. So again, command, This is what were testing for, either true or false. If true, do this, if false, do this.

Summary 09:03-09:22
In this demonstration, we showed you the if statement, and how that works with the 'if-then-else-elif', and compared that with the 'case' statement and showed you how to use the 'test' command.

## 14.3.5 Bash Scripting Logic Facts

In addition to basic commands, scripts can contain scripting logic constructs to control the flow of the script.

This lesson covers the following topics:

- Branching constructs
- Looping constructs
- Exit codes

### Branching Constructs

There are two branching constructs that perform different actions based on specific conditions or user input.

<table>
<thead>
  <tr>
    <th>Construct</th>
    <th>Description</th>
    <th>Examples</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td><b>if/then/else/fi</b></td>
    <td>
      Use the <b>if/then/elif/else/fi</b> construct to evaluate conditions
      and branches based on the results.
      <ul>
        <li>
          The <b>if</b> statement defines the condition to be evaluated.
        </li>
        <li>
          The <b>then</b> statement specifies the commands to perform if
          the condition evaluates to true.
        </li>
        <li>
          The <b>elif</b> statement is run if the condition in the if
          statement evaluates to false. It also supplies another condition
          and specifies the commands to perform if the
          <b>elif</b> condition evaluates to true.
        </li>
        <li>
          The <b>else</b> statement specifies the commands to perform if
          the condition evaluates to false.
        </li>
        <li>
          Operands include:
          <ul>
            <li><b>=</b> (equal to)</li>
            <li><b>!=</b> (not equal to)</li>
            <li><b>&gt;</b> (greater than)</li>
            <li><b>&lt;</b> (less than)</li>
          </ul>
        </li>
        <li>
          The <b>if</b> command requires spaces between the conditions and
          the operand.
        </li>
        <li>
          The <b>if</b> command also requires spaces between the
          conditions and the brackets ('[' and ']').
        </li>
        <li>
          The construct must be closed with the
          <b>fi</b> command.
        </li>
      </ul>
      The <b>test</b> command can be used within an
      <b>if/then/else/fi</b> construct to evaluate whether a condition
      evaluates to true or false. The <b>test</b> command options are
      listed below.
      <ul>
        <li><b>-d</b> tests whether a directory exists.</li>
        <li><b>-e</b> tests whether a file exists.</li>
        <li><b>-f</b> tests whether a regular file exists.</li>
        <li>
          <b>-G</b> tests whether the specified file exists and is owned
          by a specific group.
        </li>
        <li>
          <b>-h</b> or <b>-L</b> tests whether the specified file exists
          and if it is a symbolic link.
        </li>
        <li>
          <b>-O</b> tests whether the specified file exists and if it is
          owned by a specific user.
        </li>
        <li>
          <b>-r</b> tests whether the specified file exists and if the
          read permission is granted.
        </li>
        <li>
          <b>-w</b> tests whether the specified file exists and if the
          write permission is granted.
        </li>
        <li>
          <b>-x</b> tests whether the specified file exists and if the
          execute permission is granted.
        </li>
      </ul>
      <h2>test</h2>
      <ul>
        <li><b>=</b> tests whether strings are equivalent.</li>
        <li><b>!=</b> tests whether strings are not equivalent.</li>
        <li>
          <b>-o</b> is used to specify that either of the options can be
          equivalent.
        </li>
        <li><b>-eq</b> tests whether integers are equivalent.</li>
        <li><b>-ne</b> tests whether integers are not equivalent.</li>
        <li>
          <b>-gt</b> tests whether the first integer is greater than the
          second.
        </li>
        <li>
          <b>-lt</b> tests whether the first integer is less than the
          second.
        </li>
      </ul>
    </td>
    <td>
      <b>#!/bin/bash
        <br />
        echo "What is your name?"
        <br />
        read NAME
        <br />
        if [ $NAME = "George" ]
        <br />
        then
        <br />
        echo "That's my name, too."
        <br />
        else
        <br />
        echo "Hello" $NAME "I'm George."
        <br />
        fi
        <br />
        exit 0</b>
      <h2>else</h2>
      <div>
        <div class="to-info-box">
          <div class="to-info-box-body">
            <div class="to-icon large" aria-hidden="true" style="width: 20px;"><svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div>
            <div class="to-info-box-body-content">
              <span>
                The if statement could also be written using the
                <b>test</b> command.
                <br />
                For example, <b>if test $NAME = "George"</b></span>
            </div>
          </div>
        </div>
      </div>
      <h2>test -f ~/myfile.txt</h2>
    </td>
  </tr>
  <tr>
    <td><b>case/esac</b></td>
    <td>
      Use the <b>case/esac</b> construct to branch a script when the
      condition being evaluated has several possible outcomes.
      <ul>
        <li>
          The case construct can have an unlimited number of possible
          options.
        </li>
        <li>
          When the script evaluates an option as being true, all remaining
          options are skipped.
        </li>
        <li>Each option can execute several lines of commands.</li>
        <li>Close each case with two semi-colons.</li>
        <li>
          Case structures must be closed using
          <b>esac</b> (case spelled backwards.)
        </li>
      </ul>
    </td>
    <td>
      <b>#!/bin/bashsh
        <br />
        echo "What is your favorite season?"
        <br />
        read season
        <br />
        case $season in
        <br />
        spring)
        <br />
        echo "The thing I like best about spring is the flowers."
        <br />
        ;;
        <br />
        summer)
        <br />
        echo "I wish I could go swimming, but being a computer, that might
        not work out so well."
        <br />
        ;;
        <br />
        fall)
        <br />
        echo "Fall leaves, crisp morning air...what's not to like?"
        <br />
        ;;
        <br />
        autumn)
        <br />
        echo "Fall leaves, crisp morning air...what's not to like?"
        <br />
        ;;
        <br />
        winter)
        <br />
        echo "Skiing looks fun, but snowstorms interfere with my reception
        of the neighbor's Wi-Fi."
        <br />
        ;;
        <br />
        *)
        <br />
        echo $SEASON "is not listed in my database as being a season.
        Choose: spring, summer, fall, autumn, or winter."
        <br />
        ;;
        <br />
        esac
        <br />
        exit 0</b>
      <p>
        The script asks the user about season preferences and has a
        response for each common answer. The last option is a catch-all
        for any answer other than those specified in the script.
      </p>
    </td>
  </tr>
</tbody>
</table>

### Looping Constructs

There are three looping constructs that repeatedly run a set of commands according to a specified set of conditions.

<table>
<thead>
<tr>
  <th>Construct</th>
  <th>Description</th>
  <th>Examples</th>
</tr>
</thead>
<tbody>
<tr>
  <td><b>while/do/done</b></td>
  <td>
    The <b>while/do/done</b> construct implements a <b>while</b> loop. A
    <b>while</b> loop continuously executes all commands between the
    <b>do</b> and <b>done</b> statements while a specific condition
    evaluates to true. The <b>while</b> loop is useful for repeating an
    action until a specified condition is met.
    <ul>
      <li>A <b>while</b> loop requires do and done statements.</li>
      <li>
        A <b>while</b> loop can create infinite loops if the condition
        never evaluates to false.
      </li>
    </ul>
  </td>
  <td>
    <b>#!/bin/bash
      <br />
      declare -i num
      <br />
      echo "I'm thinking of a number between 1 and 100."
      <br />
      # Give num a value to prevent errors.
      <br />
      num=0
      <br />
      while test $num -ne 23
      <br />
      do
      <br />
      echo "What is your guess?"
      <br />
      read num
      <br />
      if test $num -lt 23
      <br />
      then
      <br />
      echo "The number is higher."
      <br />
      fi
      <br />
      if test $num -gt 23
      <br />
      then
      <br />
      echo "The number is lower."
      <br />
      fi
      <br />
      done
      <br />
      echo "You guessed it."
      <br />
      exit 0</b>
    <h2>while</h2>
  </td>
</tr>
<tr>
  <td><b>until/do/done</b></td>
  <td>
    The <b>until/do/done</b> construct implements an until loop. An
    <b>until</b> loop is nearly identical to a <b>while</b> loop, but
    evaluates the condition using the opposite logic:
    <ul>
      <li>
        A <b>while</b> loop executes commands while a condition is true.
      </li>
      <li>
        An <b>until</b> loop executes commands until a condition is
        true.
      </li>
    </ul>
  </td>
  <td>
    <b>#!/bin/bash
      <br />
      declare -i num
      <br />
      echo "I'm thinking of a number between 1 and 100."t;
      <br />
      # Give num a value to prevent errors.
      <br />
      num=0
      <br />
      until test $num -eq 23
      <br />
      dodo
      <br />
      echo "What is your guess?"
      <br />
      read num
      <br />
      if test $num -lt 23
      <br />
      thenen
      <br />
      echo "The number is higher."
      <br />
      fi
      <br />
      if test $num -gt 23
      <br />
      thenen
      <br />
      echo "The number is lower."
      <br />
      fi
      <br />
      done
      <br />
      echo "You guessed it."
      <br />
      exit 0</b>
  </td>
</tr>
<tr>
  <td><b>for/do/done</b></td>
  <td>
    The <b>for/do/done</b> construct implements a <b>for</b> loop. A
    <b>for</b> loop executes a set of commands a set number of times. A
    for loop:
    <ul>
      <li>
        Is useful when a specific action needs to be done a set number
        of times.
      </li>
      <li>
        Executes all commands between the do and done statements. These
        are required.
      </li>
      <li>
        Can be used with a list of items with one action being done for
        each item in the list.
      </li>
    </ul>
    The <b>seq</b> command can be used to create a sequence of numbers
    for use in a for loop:
    <ul>
      <li>
        When using only one number in the command,
        <b>seq</b> starts at 1 and counts to the specified number.
      </li>
      <li>
        When two numbers are given in the command,
        <b>seq</b> begins with the first number and counts up to the
        second number.
      </li>
      <li>
        When three numbers are given in the command,
        <b>seq</b> starts at the first number and counts in increments
        of the second number up to the third number.
      </li>
    </ul>
  </td>
  <td>
    <b>#!/bin/bash
      <br />
      declare -i num
      <br />
      echo "Multiplication quiz!!!";
      <br />
      echo "Which set of multiplication tables do you want to drill?"
      <br />
      read num
      <br />
      echo "OK. We'll work on 0X"$num "through 12X"$num"."
      <br />
      for looper in $(seq 0 12)
      <br />
      do
      <br />
      echo "What is" $num "X" $looper"?"
      <br />
      read answer
      <br />
      if test $ANSWE -eq $[$num*$looper]
      <br />
      then
      <br />
      echo "That is correct!"
      <br />
      else
      <br />
      echo "That's not it. The correct answer is" $[$num*$looper]"."
      <br />
      fi
      <br />
      done
      <br />
      exit 0</b>
    <h2>for</h2>
    <h2>seq 10</h2>
    <div>
      <div class="to-info-box">
        <div class="to-info-box-body">
          <div class="to-icon large" aria-hidden="true" style="width: 20px;"><svg aria-hidden="true" focusable="false" data-prefix="fal" data-icon="circle-info" class="svg-inline--fa fa-circle-info" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentColor" d="M256 32a224 224 0 1 1 0 448 224 224 0 1 1 0-448zm0 480A256 256 0 1 0 256 0a256 256 0 1 0 0 512zM208 352c-8.8 0-16 7.2-16 16s7.2 16 16 16l96 0c8.8 0 16-7.2 16-16s-7.2-16-16-16l-32 0 0-112c0-8.8-7.2-16-16-16l-40 0c-8.8 0-16 7.2-16 16s7.2 16 16 16l24 0 0 96-32 0zm48-168a24 24 0 1 0 0-48 24 24 0 1 0 0 48z"></path></svg></div>
          <div class="to-info-box-body-content">
            <span>
              Other methods used to create a <b>for</b> loop include:
              <ul>
                <li>
                  <b>for looper in 1 2 3 4 5</b> counts from 1 to 5.
                </li>
                <li><b>for looper in {1..5}</b> counts from 1 to 5.</li>
                <li>
                  <b>for looper in {0..10..2}</b> counts from 0 to 10 in
                  increments of 2.
                </li>
              </ul></span>
          </div>
        </div>
      </div>
    </div>
  </td>
</tr>
</tbody>
</table>

### Exit Codes

Every command terminates with an exit code. The `$?` special variable contains the exit code from the last executed command. In addition the `exit` command will both exit a script or routine and set an exit code.

The following examples illustrate how the `$?` special variable and the `exit` command can be used in scripts.

### `$?`

<table>
<thead>
<tr>
  <th>Example</th>
  <th>Description</th>
</tr>
</thead>
<tbody>
<tr>
  <td>
    <b>#!/bin/bash
      <br />
      <br />
      echo "Enter the file to find:"
      <br />
      read filename
      <br />
      <br />
      find $filename
      <br />
      result=$?
      <br />
      <br />
      case $result in
      <br />
      0)
      <br />
      echo "The $filename file was found"
      <br />
      ;;
      <br />
      1)
      <br />
      echo "The $filename file was not found"
      <br />
      ;;
      <br />
      *)
      <br />
      echo "Unexpected error code: $result"
      <br />
      ;;
      <br />
      esac
      <br />
      <br />
      exit 0</b>
  </td>
  <td>
    The <b>find</b> command returns an exit code of 0 when a given
    filename is found. If it doesn't find the file, it returns with an
    exit code of 1. The exit code is captured in the
    <b>result=$?</b> command and used in the case structure.
  </td>
</tr>
<tr>
  <td>
    <b>#!/bin/bash
      <br />
      <br />
      if ! [ $(id -u) = 0 ]; then
      <br />
      echo "The $0 script must be run as root"
      <br />
      exit 101
      <br />
      <br />
      elif ! [ -e /etc/aconffile.conf ]; then
      <br />
      echo "The configuration file /etc/aconffile.conf is missing"
      <br />
      exit 102
      <br />
      <br />
      else
      <br />
      echo "Performing normal processing"
      <br />
      # commands to be performed by root ...
      <br />
      fi
      <br />
      <br />
      exit 0</b>
  </td>
  <td>
    The results of the <b>id -u</b> command is zero (0) if the root
    account is being used. If root is not being used, the script exits
    with a code of 101. The <b>elif</b> statement checks if a
    configuration file exits. If not, the script exits with a code of
    102. Otherwise ( <b>else</b> ), normal processing commands are run
    and the script exits with a code of zero (0).
  </td>
</tr>
</tbody>
</table>
