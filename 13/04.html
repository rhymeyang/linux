<!doctype html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <meta name="generator" content="VuePress 2.0.0-rc.15" />
    <style>
      :root {
        --vp-c-bg: #fff;
      }

      [data-theme='dark'] {
        --vp-c-bg: #1b1b1f;
      }

      html,
      body {
        background-color: var(--vp-c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme')
      const systemDarkMode =
        'matchMedia' in window
          ? window.matchMedia('(prefers-color-scheme: dark)').matches
          : false

      if (userMode === 'light') {
        document.documentElement.dataset.theme = 'light'
      } else if (userMode === 'dark' || systemDarkMode) {
        document.documentElement.dataset.theme = 'dark'
      }
    </script>
    <title>Section 13.4 Containers | Linux Pro</title><meta name="description" content="some description">
    <link rel="preload" href="/linux/assets/style-DY6JTdq5.css" as="style"><link rel="stylesheet" href="/linux/assets/style-DY6JTdq5.css">
    <link rel="modulepreload" href="/linux/assets/app-D-CuBheB.js"><link rel="modulepreload" href="/linux/assets/04.html-DOqYPXmL.js">
    <link rel="prefetch" href="/linux/assets/index.html--hWB_ATi.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-Dz01UT4i.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-BjAvmRsl.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-ww-lpVJn.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-Cd-ZoDC0.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-CJPYwBBj.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-BJB344lo.js" as="script"><link rel="prefetch" href="/linux/assets/04.html-BbwOlZq_.js" as="script"><link rel="prefetch" href="/linux/assets/05.html-ACLp6KiH.js" as="script"><link rel="prefetch" href="/linux/assets/06.html-CwyzCaZx.js" as="script"><link rel="prefetch" href="/linux/assets/07.html-0d75F1qr.js" as="script"><link rel="prefetch" href="/linux/assets/08.html-ByPQG-m9.js" as="script"><link rel="prefetch" href="/linux/assets/09.html-BoAZnh-J.js" as="script"><link rel="prefetch" href="/linux/assets/10.html-A3ZWErsC.js" as="script"><link rel="prefetch" href="/linux/assets/11.html-BE5KdOhJ.js" as="script"><link rel="prefetch" href="/linux/assets/12.html-C0aZ1q4f.js" as="script"><link rel="prefetch" href="/linux/assets/13.html-CV4sH6Sg.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-Dwb1_Q6W.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-B4fnEs9_.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-CZIAunEe.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-DwccYv6N.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-D1zLjfCj.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-CSdR0WIK.js" as="script"><link rel="prefetch" href="/linux/assets/04.html-DptRvqIe.js" as="script"><link rel="prefetch" href="/linux/assets/05.html-Dsh7fsdo.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-D_NGpEqg.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-Dk_ogPfG.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-B0U6Q3HK.js" as="script"><link rel="prefetch" href="/linux/assets/04.html-BXim3AVp.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-C6bPNZdV.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-D_VnBwFv.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-BwnANWd8.js" as="script"><link rel="prefetch" href="/linux/assets/04.html-CstyCFM3.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-Jrkn32wh.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-DluyVuvs.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-B8FVDG_i.js" as="script"><link rel="prefetch" href="/linux/assets/04.html-BdSlSIUI.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-xyAe8AIL.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-D8_ZMBWh.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-C7Wra94I.js" as="script"><link rel="prefetch" href="/linux/assets/04.html-C3lEqUOr.js" as="script"><link rel="prefetch" href="/linux/assets/05.html-F-FQz5R6.js" as="script"><link rel="prefetch" href="/linux/assets/06.html-Dz1DGMZM.js" as="script"><link rel="prefetch" href="/linux/assets/07.html-znsQji-y.js" as="script"><link rel="prefetch" href="/linux/assets/08.html-CBLjL1ZI.js" as="script"><link rel="prefetch" href="/linux/assets/09.html-jIzwh2os.js" as="script"><link rel="prefetch" href="/linux/assets/10.html-C_lt7LgD.js" as="script"><link rel="prefetch" href="/linux/assets/11.html-TTklBJZE.js" as="script"><link rel="prefetch" href="/linux/assets/12.html-ZiptgeiF.js" as="script"><link rel="prefetch" href="/linux/assets/13.html-Dz4CIcSG.js" as="script"><link rel="prefetch" href="/linux/assets/14.html-BTR2P_Bw.js" as="script"><link rel="prefetch" href="/linux/assets/15.html-BlTL_y7B.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-DuqQQk9k.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-CBkLTonc.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-dm-r8_En.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-BbRxonLI.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-CSivpnqs.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-Bn_HQE-j.js" as="script"><link rel="prefetch" href="/linux/assets/04.html-pY-zih6t.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-BlXXkeVg.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-2I8SNFK0.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-DEDdnt4Y.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-OLisIOqI.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-TC75vzFm.js" as="script"><link rel="prefetch" href="/linux/assets/04.html-DmtQ657Z.js" as="script"><link rel="prefetch" href="/linux/assets/05.html-VGnhee2L.js" as="script"><link rel="prefetch" href="/linux/assets/06.html-BxKUko7V.js" as="script"><link rel="prefetch" href="/linux/assets/07.html-DEAYVxVe.js" as="script"><link rel="prefetch" href="/linux/assets/08.html-iqlWilCE.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-BXnSne_t.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-C5ZHAnTi.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-CZyUXXDs.js" as="script"><link rel="prefetch" href="/linux/assets/05.html-Dx1hnvzP.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-BC5RRv5R.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-CfaR1348.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-BGornJef.js" as="script"><link rel="prefetch" href="/linux/assets/04.html-TmnySKlq.js" as="script"><link rel="prefetch" href="/linux/assets/05.html-C13LcQMi.js" as="script"><link rel="prefetch" href="/linux/assets/01.html-DhirAxoS.js" as="script"><link rel="prefetch" href="/linux/assets/02.html-iSHcsvSQ.js" as="script"><link rel="prefetch" href="/linux/assets/03.html-CVWG75lM.js" as="script"><link rel="prefetch" href="/linux/assets/04.html-D9u55XMs.js" as="script"><link rel="prefetch" href="/linux/assets/05.html-0OZAUS22.js" as="script"><link rel="prefetch" href="/linux/assets/06.html-BVB3CDy8.js" as="script"><link rel="prefetch" href="/linux/assets/07.html-DeJXuI-v.js" as="script"><link rel="prefetch" href="/linux/assets/08.html-ByMHEKHr.js" as="script"><link rel="prefetch" href="/linux/assets/09.html-g7VUDRH6.js" as="script"><link rel="prefetch" href="/linux/assets/10.html-oNY_784G.js" as="script"><link rel="prefetch" href="/linux/assets/11.html-B0td1Voi.js" as="script"><link rel="prefetch" href="/linux/assets/12.html-UT4Yk5O4.js" as="script"><link rel="prefetch" href="/linux/assets/13.html-eL8MUJ6b.js" as="script"><link rel="prefetch" href="/linux/assets/14.html-BvZil1oN.js" as="script"><link rel="prefetch" href="/linux/assets/temp.html-BDKWHNuS.js" as="script"><link rel="prefetch" href="/linux/assets/404.html-CxeNL8BR.js" as="script">
  </head>
  <body>
    <div id="app"><!--[--><div class="vp-theme-container external-link-icon" vp-container><!--[--><header class="vp-navbar" vp-navbar><div class="vp-toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a class="route-link" href="/linux/"><img class="vp-site-logo" src="/linux/images/leaf.svg" alt="Linux Pro"><span class="vp-site-name vp-hide-mobile" aria-hidden="true">Linux Pro</span></a></span><div class="vp-navbar-items-wrapper" style=""><!--[--><!--]--><nav class="vp-navbar-items vp-hide-mobile" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../linux/" aria-label="Linux Pro"><!---->Linux Pro<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../security_pro/" aria-label="Security Pro"><!---->Security Pro<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../tools/" aria-label="Tools"><!---->Tools<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../english-starter/" aria-label="English"><!---->English<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../Se/" aria-label="Semester 3"><!---->Semester 3<!----></a></div><!--]--></nav><!--[--><!--]--><button type="button" class="vp-toggle-color-mode-button" title="toggle color mode"><svg class="light-icon" viewbox="0 0 32 32" style=""><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg class="dark-icon" viewbox="0 0 32 32" style="display:none;"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><!--]--><div class="vp-sidebar-mask"></div><!--[--><aside class="vp-sidebar" vp-sidebar><nav class="vp-navbar-items" aria-label="site navigation"><!--[--><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../linux/" aria-label="Linux Pro"><!---->Linux Pro<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../security_pro/" aria-label="Security Pro"><!---->Security Pro<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../tools/" aria-label="Tools"><!---->Tools<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../english-starter/" aria-label="English"><!---->English<!----></a></div><div class="vp-navbar-item"><a class="route-link auto-link" href="/linux/../Se/" aria-label="Semester 3"><!---->Semester 3<!----></a></div><!--]--></nav><!--[--><!--]--><ul class="vp-sidebar-items"><!--[--><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">Info <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/" aria-label="Linux Pro"><!---->Linux Pro<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">0.0 Linux Pro Introduction <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/00/01.html" aria-label="Section 0.1 Course Introduction"><!---->Section 0.1 Course Introduction<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/00/02.html" aria-label="Section 0.2 The TestOut Lab Simulator"><!---->Section 0.2 The TestOut Lab Simulator<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">1.0 Linux Overview <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/01/01.html" aria-label="Section 1.1 Linux Introduction"><!---->Section 1.1 Linux Introduction<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">2.0 Using Linux <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/01.html" aria-label="Section 2.1 The Linux Shell"><!---->Section 2.1 The Linux Shell<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/02.html" aria-label="Section 2.2 Linux Help"><!---->Section 2.2 Linux Help<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/03.html" aria-label="Section 2.3 Text Editors"><!---->Section 2.3 Text Editors<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/04.html" aria-label="Section 2.4 Aliases"><!---->Section 2.4 Aliases<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/05.html" aria-label="Section 2.5 Environment Variables"><!---->Section 2.5 Environment Variables<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/06.html" aria-label="Section 2.6 Shell Configuration Files"><!---->Section 2.6 Shell Configuration Files<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/07.html" aria-label="Section 2.7 Redirection, Piping and Command Substitution"><!---->Section 2.7 Redirection, Piping and Command Substitution<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/08.html" aria-label="Section 2.8 Directories"><!---->Section 2.8 Directories<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/09.html" aria-label="Section 2.9 Files"><!---->Section 2.9 Files<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/10.html" aria-label="Section 2.10 Links"><!---->Section 2.10 Links<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/11.html" aria-label="Section 2.11 Filesystem Hierarchy Standard (FHS)"><!---->Section 2.11 Filesystem Hierarchy Standard (FHS)<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/12.html" aria-label="Section 2.12 Locating and Searching Files"><!---->Section 2.12 Locating and Searching Files<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/02/13.html" aria-label="Section 2.13 Text Stream Processing"><!---->Section 2.13 Text Stream Processing<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">3.0 Installation and Localization <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/03/01.html" aria-label="Section 3.1 Linux System Design"><!---->Section 3.1 Linux System Design<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/03/02.html" aria-label="Section 3.2 Linux Installation"><!---->Section 3.2 Linux Installation<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/03/03.html" aria-label="Section 3.3 Localization"><!---->Section 3.3 Localization<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">4.0 Boot and Shutdown <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/04/01.html" aria-label="Section 4.1 Linux Boot Process"><!---->Section 4.1 Linux Boot Process<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/04/02.html" aria-label="Section 4.2 Bootloaders"><!---->Section 4.2 Bootloaders<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/04/03.html" aria-label="Section 4.3 systemd Boot Targets"><!---->Section 4.3 systemd Boot Targets<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/04/04.html" aria-label="Section 4.4 System Services"><!---->Section 4.4 System Services<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/04/05.html" aria-label="Section 4.5 System Shutdown"><!---->Section 4.5 System Shutdown<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">5.0 Graphical User Interfaces and Desktops <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/05/01.html" aria-label="Section 5.1 Graphical User Interfaces"><!---->Section 5.1 Graphical User Interfaces<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/05/02.html" aria-label="Section 5.2 Linux Desktops"><!---->Section 5.2 Linux Desktops<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/05/03.html" aria-label="Section 5.3 Remote Desktop"><!---->Section 5.3 Remote Desktop<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/05/04.html" aria-label="Section 5.4 Accessibility"><!---->Section 5.4 Accessibility<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">6.0 Software Installation <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/06/01.html" aria-label="Section 6.1 Red Hat Package Manager (RPM)"><!---->Section 6.1 Red Hat Package Manager (RPM)<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/06/02.html" aria-label="Section 6.2 Online Package Installation"><!---->Section 6.2 Online Package Installation<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/06/03.html" aria-label="Section 6.3 Debian Package Manager (dpkg)"><!---->Section 6.3 Debian Package Manager (dpkg)<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/06/04.html" aria-label="Section 6.4 Shared Libraries"><!---->Section 6.4 Shared Libraries<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">7.0 Users and Groups <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/07/01.html" aria-label="Section 7.1 User and Group Overview"><!---->Section 7.1 User and Group Overview<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/07/02.html" aria-label="Section 7.2 User Management"><!---->Section 7.2 User Management<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/07/03.html" aria-label="Section 7.3 Group Management"><!---->Section 7.3 Group Management<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/07/04.html" aria-label="Section 7.4 Troubleshoot User Issues"><!---->Section 7.4 Troubleshoot User Issues<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">8.0 Disk and File System Management <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/01.html" aria-label="Section 8.1 Storage Concepts"><!---->Section 8.1 Storage Concepts<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/02.html" aria-label="Section 8.2 MBR Disk Partitions"><!---->Section 8.2 MBR Disk Partitions<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/03.html" aria-label="Section 8.3 GUID Partitions"><!---->Section 8.3 GUID Partitions<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/04.html" aria-label="Section 8.4 Logical Volume Manager"><!---->Section 8.4 Logical Volume Manager<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/05.html" aria-label="Section 8.5 File Systems"><!---->Section 8.5 File Systems<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/06.html" aria-label="Section 8.6 Mounting File Systems"><!---->Section 8.6 Mounting File Systems<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/07.html" aria-label="Section 8.7 File System Maintenance"><!---->Section 8.7 File System Maintenance<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/08.html" aria-label="Section 8.8 Disk Quotas"><!---->Section 8.8 Disk Quotas<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/09.html" aria-label="Section 8.9 Ownership"><!---->Section 8.9 Ownership<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/10.html" aria-label="Section 8.10 Permissions"><!---->Section 8.10 Permissions<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/11.html" aria-label="Section 8.11 The umask Command"><!---->Section 8.11 The umask Command<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/12.html" aria-label="Section 8.12 Special Permissions"><!---->Section 8.12 Special Permissions<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/13.html" aria-label="Section 8.13 Access Control Lists"><!---->Section 8.13 Access Control Lists<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/14.html" aria-label="Section 8.14 Archive and Backup"><!---->Section 8.14 Archive and Backup<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/08/15.html" aria-label="Section 8.15 Troubleshooting Storage"><!---->Section 8.15 Troubleshooting Storage<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">9.0 Hardware Installation <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/09/01.html" aria-label="Section 9.1 Device Drivers"><!---->Section 9.1 Device Drivers<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/09/02.html" aria-label="Section 9.2 Kernel Module Management"><!---->Section 9.2 Kernel Module Management<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/09/03.html" aria-label="Section 9.3 Hotplug and Coldplug Devices"><!---->Section 9.3 Hotplug and Coldplug Devices<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">10.0 Processes and System Services <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/10/01.html" aria-label="Section 10.1 Processes"><!---->Section 10.1 Processes<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/10/02.html" aria-label="Section 10.2 Process Management"><!---->Section 10.2 Process Management<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/10/03.html" aria-label="Section 10.3 Task Management"><!---->Section 10.3 Task Management<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/10/04.html" aria-label="Section 10.4 System Time Configuration"><!---->Section 10.4 System Time Configuration<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">11.0 System Monitoring <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/11/01.html" aria-label="Section 11.1 System Logging"><!---->Section 11.1 System Logging<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/11/02.html" aria-label="Section 11.2 Resource Monitoring"><!---->Section 11.2 Resource Monitoring<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">12.0 Networking <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/12/01.html" aria-label="Section 12.1 IPv4 Overview"><!---->Section 12.1 IPv4 Overview<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/12/02.html" aria-label="Section 12.2 Network Interface Configuration"><!---->Section 12.2 Network Interface Configuration<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/12/03.html" aria-label="Section 12.3 NetworkManager"><!---->Section 12.3 NetworkManager<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/12/04.html" aria-label="Section 12.4 IPv6 Overview"><!---->Section 12.4 IPv6 Overview<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/12/05.html" aria-label="Section 12.5 Routing Configuration"><!---->Section 12.5 Routing Configuration<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/12/06.html" aria-label="Section 12.6 Hostname and DNS Configuration"><!---->Section 12.6 Hostname and DNS Configuration<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/12/07.html" aria-label="Section 12.7 Linux Firewalls"><!---->Section 12.7 Linux Firewalls<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/12/08.html" aria-label="Section 12.8 Network Troubleshooting"><!---->Section 12.8 Network Troubleshooting<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading active">13.0 Cloud, Containers, and Virtualization <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/13/01.html" aria-label="Section 13.1 Cloud and Virtualization Overview"><!---->Section 13.1 Cloud and Virtualization Overview<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/13/02.html" aria-label="Section 13.2 Virtual Machines"><!---->Section 13.2 Virtual Machines<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/13/03.html" aria-label="Section 13.3 Sandboxed Applications"><!---->Section 13.3 Sandboxed Applications<!----></a><!----></li><li><a class="route-link route-link-active auto-link vp-sidebar-item active" href="/linux/13/04.html" aria-label="Section 13.4 Containers"><!---->Section 13.4 Containers<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/13/05.html" aria-label="Section 13.5 Virtual Networking"><!---->Section 13.5 Virtual Networking<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">14.0 Scripting and Automation <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/14/01.html" aria-label="Section 14.1 Bash Shell Scripting"><!---->Section 14.1 Bash Shell Scripting<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/14/02.html" aria-label="Section 14.2 Shell Environments, Bash Variables and Parameters"><!---->Section 14.2 Shell Environments, Bash Variables and Parameters<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/14/03.html" aria-label="Section 14.3 Bash Scripting Logic"><!---->Section 14.3 Bash Scripting Logic<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/14/04.html" aria-label="Section 14.4 Version Control Using Git"><!---->Section 14.4 Version Control Using Git<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/14/05.html" aria-label="Section 14.5 Orchestration Processes and Concepts"><!---->Section 14.5 Orchestration Processes and Concepts<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">15.0 Security <!----></p><ul style="" class="vp-sidebar-children"><!--[--><li><a class="route-link auto-link vp-sidebar-item" href="/linux/15/01.html" aria-label="Section 15.1 Root Usage"><!---->Section 15.1 Root Usage<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/15/02.html" aria-label="Section 15.2 User Security and Restriction"><!---->Section 15.2 User Security and Restriction<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/15/03.html" aria-label="Section 15.3 Login Blocking"><!---->Section 15.3 Login Blocking<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/15/04.html" aria-label="Section 15.4 Network Security"><!---->Section 15.4 Network Security<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/15/05.html" aria-label="Section 15.5 OpenSSH"><!---->Section 15.5 OpenSSH<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/15/06.html" aria-label="Section 15.6 SSH Port Tunneling"><!---->Section 15.6 SSH Port Tunneling<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/15/07.html" aria-label="Section 15.7 Security-Enhanced Linux (SELinux)"><!---->Section 15.7 Security-Enhanced Linux (SELinux)<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/15/08.html" aria-label="Section 15.8 Application Armor (AppArmor)"><!---->Section 15.8 Application Armor (AppArmor)<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/15/09.html" aria-label="Section 15.9 Public Key Authentication"><!---->Section 15.9 Public Key Authentication<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/15/10.html" aria-label="Section 15.10 VPN Access and Authentication"><!---->Section 15.10 VPN Access and Authentication<!----></a><!----></li><li><a class="route-link auto-link vp-sidebar-item" href="/linux/15/11.html" aria-label="Section 15.11 Security Best Practices"><!---->Section 15.11 Security Best Practices<!----></a><!----></li><!--]--></ul></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">A0 Linux Pro - Practice Exams <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">B0 Linux Pro - CompTIA Linux+ <!----></p><!----></li><li><p tabindex="0" class="vp-sidebar-item vp-sidebar-heading">Glossary <!----></p><!----></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="vp-page"><!--[--><!--]--><div class="theme-default-content" vp-content><!--[--><!--]--><div><p>As you study this section, answer the following questions:</p><ul><li>What is the difference between virtual machines and containers?</li><li>What is a container?</li><li>What are some of the popular container management solutions?</li><li>What is a repository?</li><li>What does container orchestration mean?</li><li>What are some popular container orchestration engines?</li></ul><p>In this section, you will learn to:</p><ul><li>Use containers</li><li>Manage containers</li></ul><p>The key terms for this section include:</p><table class="terms"><thead><tr><th>Term</th><th>Definition</th></tr></thead><tbody><tr><td>Container</td><td> An application isolated in a lightweight package that allows the user to use the program similar to how you would use a virtual machine. </td></tr><tr><td>Container engine</td><td> Similar to a hypervisor, a container engine is installed on top of the host operating system. </td></tr><tr><td>Container orchestration</td><td> Container orchestration is the process of automating, managing, scaling, and networking containers. </td></tr></tbody></table><p>This section helps you prepare for the following certification exam objectives:</p><table class="objectives"><thead><tr><th>Exam</th><th>Objective</th></tr></thead><tbody><tr><td>CompTIA Linux+ XK0-005</td><td> 3.2 Given a scenario, perform basic container operations <ul><li>Container management</li><ul><li>Starting/stopping</li><li>Inspecting</li><li>Listing</li><li>Deploying existing images</li><li>Connecting to containers</li><li>Logging</li><li>Exposing ports</li></ul><li>Container image operations</li><ul><li>build</li><li>push</li><li>pull</li><li>list</li><li>rmi</li></ul></ul><p>3.5 Summarize container, cloud, and orchestration concepts</p><ul><li>Kubernetes benefits and application use cases</li><ul><li>Pods</li><li>Sidecars</li><li>Ambassador containers</li></ul><li> Container networks <ul><li>Overlay networks</li><li>Bridging</li><li>Network address translation (NAT)</li><li>Host</li></ul></li><li>Service mesh</li><li>Bootstrapping</li><li>Container registries</li></ul></td></tr></tbody></table><h2 id="_13-4-1-containers-on-linux" tabindex="-1"><a class="header-anchor" href="#_13-4-1-containers-on-linux"><span>13.4.1 Containers on Linux</span></a></h2><p>Click one of the buttons to take you to that part of the video.</p><p>Containers 00:00-00:14 In this video, we&#39;re going to take a look at how containers work. You may hear the word Docker when the subject of containers comes up. Docker is software that&#39;s used to create, manage, and distribute containers.</p><p>Virtual Machines vs Containers 00:14-00:49 Containers are commonly compared to virtual machines. Like virtual machines, they have a base hardware and operating system.</p><p>These physical devices have all the components that make a computer work: a processor, RAM, Hard Drive, input devices, and a graphical user interface, or GUI.</p><p>When you create a virtual machine, you allocate a portion of your hardware resources to run another</p><p>virtual computer within your system, often with a GUI of its own. This can become very difficult to support and manage. As you create more virtual machines, you end use more resources.</p><p>How Containers Work 00:49-01:45 Containers help with this problem. Instead of creating a separate virtual machine for each program or service you want to run, ye create a minimalistic environment built for a dedicated task. This environment only has the software libraries and packages needed to run the intended software, nothing else. You get the same individualized and isolated environment you do with a virtual machine, but without having to allocate large portions of your hardware to utilize it.</p><p>Let&#39;s take a closer look at this setup. With containers, we have our system hardware. This is what all the software will run on, of course. We install the Linux Operating System on top of our hardware. Then we install container software, like Docker, which aids in downloading, initializing, and managing our containers. Finally, we run our intended software via containers.</p><p>When we compare our running our applications in a container environment to a virtual machine environment, we see that containers can utilize less resources.</p><p>Parts of a container 01:45-02:23 A container consists of three parts. We have the software that&#39;s used to download, run, and manage containers. This is software such as Docker. Next is a container image. This is an image of the intended application. Think of it as a software package you download from the internet. This image will have all the necessary parts for the containerized application to run.</p><p>The final piece is the actual application container. The container software will use the container image to build the container from a base OS and initialize the intended application. This process may seem difficult, but it&#39;s fairly simple, like downloading and installing software.</p><p>Container Pros 02:23-03:03 Containers have several key benefits. They allow developers to package applications with all needed dependencies. This includes prerequisite software and libraries. Then they can distribute the application in one image.</p><p>Containers provide consistent environments. The applications within containers are built from the ground up. The developer creates the base OS, libraries, resources, and application. This makes implementation and troubleshooting easier.</p><p>Containers are portable. Since they run independent of the host machine, they can be backed up and moved as needed. Overall, containers have proven to be an extremely effective tool in the technology industry.</p><p>Summary 03:03-03:18 In this lesson, we compared containers and virtual machines. We looked at how the two technologies approach creating independent environments, and we discussed the functions and benefits of containers.</p><h2 id="_13-4-2-using-containers" tabindex="-1"><a class="header-anchor" href="#_13-4-2-using-containers"><span>13.4.2 Using Containers</span></a></h2><h3 id="containers-00-00-00-32" tabindex="-1"><a class="header-anchor" href="#containers-00-00-00-32"><span>Containers 00:00-00:32</span></a></h3><p>We&#39;re going to review how to use containers. Containers are self-contained packages of software. Similar to a virtual machine, they allow users to run virtualized environments. However, the virtual environment for a container is only built with the items necessary to run the intended container package.</p><p>In most cases, an entire operating system isn&#39;t needed. There&#39;s no need for a graphical environment or other tools built into operating systems. Containers are predictable environments that are isolated from all other applications.</p><p>Let&#39;s begin with Docker images.</p><h3 id="docker-images-00-32-01-20" tabindex="-1"><a class="header-anchor" href="#docker-images-00-32-01-20"><span>Docker Images 00:32-01:20</span></a></h3><p>An image is a prepackaged set of instructions used to build containers. They begin with a base operating system and have software packages, configurations, and files built on top. Think of them as executable installers for Windows. Just because the image is downloaded on the computer doesn&#39;t mean the software is installed. Let&#39;s run docker images, and we see that we currently don&#39;t have any images on this system.</p><p>We pull images from repositories. Docker comes preconfigured to pull images from the online Docker repositories. Let&#39;s run docker pull Nginx. Once complete, run docker pull ubuntu. When we rerun the Docker images command, we see that both ubuntu and Nginx are downloaded to the system.</p><h3 id="docker-containers-01-20-02-40" tabindex="-1"><a class="header-anchor" href="#docker-containers-01-20-02-40"><span>Docker Containers 01:20-02:40</span></a></h3><p>Now that we have images ready let&#39;s create the containers. This could be equated to installing software. We type <code>docker create --name test_container ubuntu</code>. We&#39;re creating a container. The <code>--name</code> option allows us to give the container an easy-to-remember name. Otherwise, Docker will create a random name for the container, or we&#39;ll need to identify the container by an ID number. Lastly, we instruct Docker to use the ubuntu image when creating the container.</p><p>Let&#39;s view our new container. Run docker ps to list containers on the system. We don&#39;t see any containers listed on the system. The ps command only shows running or in-use containers. The <code>-a</code> option is needed to show all containers. Let&#39;s run <code>docker ps -a</code>, and we see that our container is listed and its status is Created.</p><p>Run docker start test_container to start the container. Let&#39;s rerun <code>docker ps</code>. We still don&#39;t see the container in the list. When we run <code>docker ps -a</code>, we see the status as Exited.</p><p>When we start a container, there&#39;s coding that runs from the image. If the image isn&#39;t programmed to complete a task, return output or keep running. The container will power on, run the code, and then exit. There are options that we must use with the start command in order to keep the container running.</p><h3 id="connecting-to-containers-02-40-04-13" tabindex="-1"><a class="header-anchor" href="#connecting-to-containers-02-40-04-13"><span>Connecting to Containers 02:40-04:13</span></a></h3><p>Instead of using the create and start command, most users will use the Docker run command. Docker run completes three tasks instead of one. It will pull an image if there isn&#39;t one on the system already. It will create the container, and it will start the container.</p><p>Let&#39;s type <code>docker run --name centos_container -i -t centos:7</code>. The name option allows us to use an easy-to-remember name in lieu of an ID number or randomly generated name. The <code>-i</code> option is short for interactive, and the <code>-t</code> option stands for TTY. This&#39;ll keep the container running and keep shell access available to configure or modify the container. Centos:7 is the name and version of the base operating system image we want the container to run.</p><p>Press Enter. The Docker run command will pull the latest CentOS 7 image from the online Docker repository, create the container, start the container, and drop us in a shell. We see that the shell prompt has changed as well as our hostname. We&#39;re now in the CentOS 7 environment within the container.</p><p>Container images are known as base images. They&#39;re bare-bones versions of our operating systems. Let&#39;s try running the netstat command. Enter netstat, and we see a command not found error. Let&#39;s run <code>yum install net-tools</code> and run the <code>netstat</code> command again. We now see the output for the netstat command.</p><p>We exit the container shell just as we do ssh sessions. Type exit, and we&#39;re returned to our host system shell.</p><h3 id="creating-images-04-13-05-28" tabindex="-1"><a class="header-anchor" href="#creating-images-04-13-05-28"><span>Creating Images 04:13-05:28</span></a></h3><p>When we make changes to a container, they can be saved to a new image. This is how new container software images are created. A base image is pulled, and software is installed, configured, or created. Then we write the container to a new image file.</p><p>The Docker commit command is used to make images from containers. To run this command, we need the container ID. Thankfully, the hostname of our container and the container ID are the same. To create an image of CentOS 7 with the netstat command preinstalled, run <code>docker commit [image name] net-tools-centos</code>.</p><p>We can run the new image just as we did the CentOS one. Type <code>docker run --name custom-image -dit net-tools-centos</code>. The <code>d</code> stands for detach. This&#39;ll allow us to run the container in the background without immediately interacting with the shell. When we run <code>docker ps</code>, we see only the new container we created from our custom image. Its status is up. When we run <code>docker ps -a</code>, we see the three containers we&#39;ve used in this session: the ubuntu that was our first test container, the centos container that we installed <code>net-tools</code> on originally, and the custom-image container we created from our custom image.</p><h3 id="logging-in-containers-05-28-05-55" tabindex="-1"><a class="header-anchor" href="#logging-in-containers-05-28-05-55"><span>Logging in Containers 05:28-05:55</span></a></h3><p>We can view the logs of our containers with the <code>Docker logs</code> command. Run <code>docker logs</code> and the container name centos_container. We see output from our earlier shell session. Let&#39;s rerun the command, but this time on our custom-image container. Nothing loads because we haven&#39;t interacted with that container yet.</p><p>Containers will only log information that has changed since the initial image deployment. Since this image was made with net-tools installed, there are no logs to show.</p><h3 id="stopping-containers-05-55-06-14" tabindex="-1"><a class="header-anchor" href="#stopping-containers-05-55-06-14"><span>Stopping Containers 05:55-06:14</span></a></h3><p>Lastly, let&#39;s look at stopping containers that are running or have a status of up. The command is Docker stop plus the container name. Right now, we know the only container running is our custom-image container. Let&#39;s run docker stop custom-image and list all containers again. We see the container is in an Exited status.</p><h3 id="summary-06-14-06-23" tabindex="-1"><a class="header-anchor" href="#summary-06-14-06-23"><span>Summary 06:14-06:23</span></a></h3><p>In this demonstration, we learned how to pull, run, and create Docker containers.</p><h2 id="_13-4-3-managing-containers" tabindex="-1"><a class="header-anchor" href="#_13-4-3-managing-containers"><span>13.4.3 Managing Containers</span></a></h2><h3 id="containers-00-00-00-17" tabindex="-1"><a class="header-anchor" href="#containers-00-00-00-17"><span>Containers 00:00-00:17</span></a></h3><p>In this demo, we&#39;re going to look at managing containers on a system. If we leave exited containers on a system, that can fill hard disk space quickly. There may also be times when we need to inspect containers for configurations.</p><h3 id="inspect-containers-00-17-02-27" tabindex="-1"><a class="header-anchor" href="#inspect-containers-00-17-02-27"><span>Inspect Containers 00:17-02:27</span></a></h3><p>Let&#39;s run docker images. This system doesn&#39;t have any images ready to work with. Let&#39;s pull an nginx image. Nginx is a webserver. This image will install a container that will run a webserver for my system. We need to inspect the image to see which port the webserver will run on.</p><p>The docker inspect command can provide detailed information about the properties of a docker image. Let&#39;s run docker image inspect nginx. This brings up a lot of information. We can use the <code>-f</code> option to search for a field of information, similar to the grep command. Let&#39;s type <code>docker image inspect nginx -f &#39;{{ .ContainerConfig.ExposedPorts }}&#39;</code> The inspect command defaults to searching and displaying in JSON arrays. We&#39;re searching the image for a container configuration that will show us which port is exposed for any containers built from the image. We see that this is a regular nginx installation that defaults to port 80, http traffic.</p><p>To make this webserver container operational, we need to start the container and provide a bridge between it and the physical system. To do this, we run <code>docker run --name nginx-test -d -P nginx</code>. The <code>-d</code> option runs the container in the background. The <code>-P</code> option will publish all exposed ports to random ports. This means that port 80 on my container will bridge to a random port on my system. When users try to access the webserver, they&#39;ll access my system IP address and the randomly generated port number. My system will take traffic on that port number and pass it to the container on port 80.</p><p>First, run ip a and get the IP address of the system. Then open a web browser and navigate to that IP. We see that nothing loads. Let&#39;s run <code>docker ps -a</code> to view which port number was assigned to the nginx container. We&#39;ll add the port number to the address bar, and we see the nginx landing page.</p><h3 id="build-images-02-27-04-07" tabindex="-1"><a class="header-anchor" href="#build-images-02-27-04-07"><span>Build Images 02:27-04:07</span></a></h3><p>Okay, now let&#39;s talk about building images. It&#39;s a useful option, but it can bloat the size of containers. It&#39;s more common to create a build file that will take a base OS image and run commands and other instructions to create the image.</p><p>Let&#39;s make a directory named build_test and cd into it. Next, create a build file that&#39;s named Dockerfile and enter a text editor. You begin by adding comments detailing your commands. Type #set the base image. On a new line, enter FROM in all caps and ubuntu in lowercase.</p><p>The next line will have #author, and we&#39;ll enter MAINTAINER TestOut on another line. You would type your own name or your company&#39;s name for the author. Next, we add <code>#Metadata</code>. Then type <code>LABEL version=&quot;1.0&quot;&#39;</code> and <code>LABEL description=&quot;Building an image with a Dockerfile&quot;</code> on separate lines. Lastly, we&#39;ll add a comment detailing package management. Then type RUN apt clean, RUN apt update, and RUN <code>apt install cowsay -y</code> on separate lines. Once that&#39;s done, write the file and exit the editor. Our build file is ready.</p><p>Now let&#39;s type <code>docker build -t jmacetestout/testout_image:cowsay</code> . The <code>-t</code> option allows us to tag the image to make it identifiable to other users. In order to properly tag an image, you must have a docker hub account to associate the tags with. Run docker images to see the newly built docker image listed.</p><h3 id="push-docker-images-04-07-04-45" tabindex="-1"><a class="header-anchor" href="#push-docker-images-04-07-04-45"><span>Push Docker Images 04:07-04:45</span></a></h3><p>The next step is to share images with others. The most common way to do this is to push the images to the online docker repository using the docker push command. You must have a docker hub account and be logged in to docker.</p><p>To log in to docker, run docker login and provide your login information. Once we&#39;re logged in, we can push the build image we just created with docker push and your docker hub usersname, then <code>/testout_image:cowsay</code>. The text after the forward slash (<code>/</code>) is the name you want to give the image. The text after the colon consists of tags that can be used to identify and quickly search for your image in the docker repository.</p><h3 id="clean-unused-containers-and-images-04-45-05-44" tabindex="-1"><a class="header-anchor" href="#clean-unused-containers-and-images-04-45-05-44"><span>Clean Unused Containers and Images 04:45-05:44</span></a></h3><p>Lastly, as we work, we&#39;ll want to remove containers and images that are no longer in use. To remove a container, it must be inactive or exited. If you want to remove an image, it must not have a container, active or inactive, loaded from it.</p><p>Let&#39;s list all our containers. We need to stop the nginx container with <code>docker stop nginx-test</code>. Now we can use the <code>docker rm</code> command to remove the container. Let&#39;s run <code>docker rm nginx-test</code>. When we run <code>docker ps -a</code> again, we see that all containers are removed.</p><p>The command to remove images is similar to removing containers. Let&#39;s run docker images. We see three images pulled to our system: our new build image, nginx, and ubuntu. To remove these images, we&#39;ll run docker rmi and the image ID of our custom build image, nginx ubuntu. When we run docker images again, we can see that all images have been removed.</p><h3 id="summary-05-44-06-04" tabindex="-1"><a class="header-anchor" href="#summary-05-44-06-04"><span>Summary 05:44-06:04</span></a></h3><p>And that&#39;s all for this demo on managing containers. We discussed how to inspect docker images, publish ports within a container, build custom images with a Dockerfile script, push images to the docker repository, and remove unnecessary containers and images from a system.</p><h2 id="_13-4-4-container-facts" tabindex="-1"><a class="header-anchor" href="#_13-4-4-container-facts"><span>13.4.4 Container Facts</span></a></h2><p>This lesson covers the following topics:</p><ul><li>Virtual machines vs. containers</li><li>Container management</li><li>Container image operations</li><li>Summarizing orchestration concepts</li></ul><h3 id="virtual-machines-vs-containers" tabindex="-1"><a class="header-anchor" href="#virtual-machines-vs-containers"><span>Virtual Machines vs. Containers</span></a></h3><p>Containers are a way to run programs in a virtual environment. Containers include all the files, libraries, and even any necessary operating system files that might be needed, bundled into one package. Containers use the same principle as virtual machines. They are installed on top of the operating system with an abstraction layer to share resources between the hardware and the containers.</p><p>The following table lists common terms you should be familiar with when working with containers:</p><table><thead><tr><th>Term</th><th>Definition</th></tr></thead><tbody><tr><td>Virtual machine</td><td> A virtual machine uses physical resources like the CPU, memory, and hard drive to run an operating system from within its host. </td></tr><tr><td>Hypervisor</td><td> On a server, the hypervisor is installed on top of the hardware of a server and virtualizes all the hardware resources to different clients in the form of an operating system. </td></tr><tr><td>Container engine</td><td> Instead of installing the hypervisor on top of the hardware, the container engine is installed on top of the host operating system. This allows the containers to use the resources from the host operating system. </td></tr><tr><td>Container</td><td> An application isolated in a lightweight package that allows the user to use the program similar to how you would use a virtual machine. </td></tr><tr><td>Container management</td><td> Because of their size, many individual containers can exist on one operating system. To help manage these containers, you can use either Docker or Podman. </td></tr></tbody></table><h3 id="container-management" tabindex="-1"><a class="header-anchor" href="#container-management"><span>Container Management</span></a></h3><p>Containers are managed by software, much like a hypervisor manages virtual machines. Docker and Podman are two popular solutions.</p><h3 id="docker" tabindex="-1"><a class="header-anchor" href="#docker"><span>Docker:</span></a></h3><p>Docker is a lightweight package that was created by Docker Inc. and released as open source. Docker runs on top of a host system, such as Linux. Some facts about Docker and managing Docker are:</p><ul><li>Docker runs as the root user.</li><li>Docker is used to build and manage container images.</li><li> Docker is monolithic in architecture, meaning that it is independent and self-contained. </li><li> Once a container is deployed in Docker, it can be stopped and started by using the <b class="fw-bold">docker start</b> and <b class="fw-bold">docker stop</b> commands. </li><li> To inspect and gather detailed information about a container in Docker, use the <b class="fw-bold">docker inspect</b> command. This command will produce a lot of information. It&#39;s recommended to output the contents and use <b class="fw-bold">grep</b> to inspect the information. </li><li> To list all the containers in Docker, use the <b class="fw-bold">docker ps</b> command. This command will list contents in columns and will include, container ID, name of image, command used to start container, when the container was started, current status of container, ports used, and name. </li><li> Docker images are deployed using the command: <b class="fw-bold">docker run -name</b><i class="fs-italicize">NAME</i> <b class="fw-bold">-p</b><i class="fs-italicize">PORTS IMAGE.</i> NAME is the name of the container, PORTS is the port your want to expose, IMAGE is the name of the image. </li><li> Connecting to running containers is done by using the <b class="fw-bold">docker exec</b> command in the Docker image. Type <b class="fw-bold">exit</b> to break the connection. </li><li> To view logs of a container, use the <b class="fw-bold">docker log</b> command. </li></ul><h3 id="podman" tabindex="-1"><a class="header-anchor" href="#podman"><span>Podman:</span></a></h3><p>Podman is a tool and is considered daemonless, which is the main difference from Docker. It is open-source that is used to find, run, build, share, and deploy applications on Linux systems. Some facts about Podman are:</p><ul><li>Podman can run rootless.</li><li> Podman can not be used to build images. A separate tool called Buildah is needed. Another tool, Skopeo, moves container images between different types of storage systems. </li><li>Podman is modular.</li><li>Podman uses a command line interface.</li></ul><h3 id="container-image-operations" tabindex="-1"><a class="header-anchor" href="#container-image-operations"><span>Container Image Operations</span></a></h3><p>You are able to build and create your own images. You can also find existing container images in repositories . When working with your images, you will use operations to store and retrieve images. Keep in mind the following facts about container image operations.</p><ul><li> To build your own Docker image, you can use a Dockerfile. A Dockerfile is a text file that has instructions that tell Docker what to do when creating an image. The text file will detail the parent image and initial state where it should start. It will contains metadata about the author and properties of the image. Will contain the commands to run during the build. Specify details about the image that will be created. </li><li> When you want an image to be stored in a repository, you <b class="fw-bold">push</b> the image. Pushing an image is the process of copying it from your local machine to the repository. Pushing can be done from a command line or from a program designed to do so. Images are often tagged with the latest version during the push process. </li><li> Pulling an image is the reverse process of pushing. You <b class="fw-bold">pull</b> an image when you want to bring the current version to your local machine. </li><li> To view a list of Docker images on your system, use the <b class="fw-bold">docker images</b> command or <b class="fw-bold">docker image ls</b> command. </li><li> You can remove Docker images with the <b class="fw-bold">docker rmi</b> command. </li></ul><h3 id="summarizing-orchestration-concepts" tabindex="-1"><a class="header-anchor" href="#summarizing-orchestration-concepts"><span>Summarizing Orchestration Concepts</span></a></h3><p>As a review, containers are a way to run programs in a virtual environment. Containers include all the files, libraries, and even any necessary operating system files that might be needed, bundled into one package. Once you have many containers, you need a way to manage them. This is where the term orchestration comes in. Container orchestration is the process of automating, managing, scaling, and networking containers. There are several orchestration engines that can be used for this, including Docker Swarm, Apache Mesos, and Kubernetes. It&#39;s important to note that sometimes automation and orchestration are confused with each others. Automation is typically used to automate a single task to reduce the manual interaction by a human. Orchestration is the process of automating processes and workflows that involves many different tasks and many different systems.</p><p>The following table lists and compares some of these orchestration engines:</p><table><thead><tr><th>Orchestration Engine</th><th>Concepts</th></tr></thead><tbody><tr><td width="151">Kubernetes</td><td width="1384"> Kubernetes is an open-source orchestration system. Kubernetes was originally created by Google, but is now maintained by the Cloud Native Computing Foundation. Most consider Kubernetes the gold standard in orchestration systems. Below are some facts about Kubernetes. <ul><li>Works with Docker, Containerd, and CRI-O.</li><li> Monitors the health of containers and responds if the containers are not responding or performing poorly. </li><li>Can run multiple containers at the same time.</li><li>Works with on-premises or cloud systems.</li><li>Can by used for load balancing.</li><li> Is highly scalable, meaning that you can add more containers if needed. </li><li> Can be used to manage updates, including rolling back updates. </li></ul><p>Several key concepts used by Kubernetes are:</p><ul><li> With Kubernetes, you can use what are referred to as <i class="fs-italicize">pods</i> . Pods are a group of containers when resources are shared. The shared recourse could be something like a storage pool. The pods are all able to access the same storage. </li><li> Using the above storage example, if you need to make changes to the storage, you can use just one of the Kubernetes containers in the pod to do so. This container is referred to as a <i class="fs-italicize">sidecar</i> . </li><li> Sidecars are containers used to perform a task on behalf of other containers. We can refer to this sidecar as an <i class="fs-italicize">Ambassador containe</i> r, meaning that this container is sort of the spokesperson for all the containers in the pod. Remember, we want containers to focus on one task, so having a dedicated container to perform tasks such as communication with other containers is considered best practice. </li><li> We know that containers are used typically to perform one task. Sometimes, to perform a series of tasks requirement multiple containers, each doing something different. When these containers are combined into pods, this is referred to as <i class="fs-italicize">microservices</i> . When microsservices need to work together, it&#39;s referred to as a <i class="fs-italicize">service mesh</i> . Finally, the service mesh is established by using sidecars. </li></ul></td></tr><tr><td width="151">Docker Swarm</td><td width="1384"> Docker Swarm is used to cluster Docker containers. In general, a swarm is to move something in large numbers. Docker Swarm: <ul><li>Is integrated with Docker.</li><li> Uses a command line interface to manage the containers in the swarm. </li><li>Allows scaling of the swarm.</li><li>Can be used for load balancing.</li><li>Allows for rolling out updates.</li></ul></td></tr><tr><td width="151">Apache Mesos</td><td width="1384"> Apache Mesos is used to manage computer clusters. Apache Mesos was developed by the University of Berkeley and is open source. Apache Mesos: <ul><li> Is a container management tool used to isolate CPU, memory, and file systems on Linux systems. </li><li>Can run Hadoop, Jenkins, Spark, Aurora, and other tools.</li><li> Is combined with Marathon to provide a more complete solution to orchestration. </li><li>Can be used to manage Docker containers.</li></ul></td></tr></tbody></table><p>We have summarized some of the specific features for orchestration engines. The following table lists other orchestration terms and concepts:</p><table><thead><tr><th>Term</th><th>Definition</th></tr></thead><tbody><tr><td width="151">Single-node and multi-node uses</td><td width="1384"> With Kubernetes, you use pods to combine containers to work together to handle tasks as we scale. A use case example of when this happens is a website that handles all the web traffic for your business. One day, your business becomes very popular, and you need to add more containers to handle the traffic. This is a simple example of when we went from having a single container, or node, to a pod of containers (multi-node). </td></tr><tr><td width="151">Container persistent storage</td><td width="1384"> In general, persistent storage is a physical storage on a device such as a traditional hard drive or a solid-state drive. It is called persistent because the data on the devices is retained if the devices lose power. By default, containers do not save the data that they produce. When a container loses power, the data is lost, so this is a major concern for containers that need to store data. When containers need to store data, they have to be configured to store the data on a back-end storage system. These systems can be local storage that are mounted. The underlining devices can be a variety of solutions, such as traditional sata drives, solid-state drives, RAID arrays, or storage area networks. </td></tr><tr><td width="151">Container networks</td><td width="1384"> Traditional methods of networking involves having a network card on a device that communicates with other nodes on a network or the internet. Containers and the applications that run on them will most often need access to the network or to the internet. With containers, networks work a bit differently than traditional networking. A few key container networking concepts are: <ul><li> Overlay networks work by using tunnels to talk to other containers on a network. This will allow containers to function as if they are located on the same host. </li><li> Bridging is the establishment of different network segments together. This is typically done by directing traffic through routers. But with bridging, the segments are merged into a single segment. There are different types of bridging: simple bridging merges two segments, multiport merges multiple networks, transparent bridging builds routing tables, and source route builds route based on the source. </li><li> Network address translation (NAT) is the process of translating private IP addresses into public IP addresses. This concept is no different than how it is done traditionally. Some of the types of NAT used with container networking are DNAT, SNAT, and Masquerade NAT. </li><ul><li> DNAT, or destination NAT, is used when servers are behind firewalls, and you want to access them from the internet. </li><li> SNAT, or source NAT, is used when internal networks are using statically assigned IP addresses. Traffic is directed to the internet through device with a access to the internet. </li><li> Masquerade Nat is used in internal networks with dynamic IP addressing. Traffic to the public internet is directed through a single device. </li></ul><li> Often times, your container will only need to communicate with the host that it resides on. If outside communication is needed to reach the container, it will be configured to flow through the host through a virtual network connection. </li></ul></td></tr><tr><td width="151">Bootstrapping</td><td width="1384"> Bootstrapping is the process to self-start without assistance. In computing, the term <i class="fs-italicize">booting</i> refers to a system starting up when it receives power via the bootloader code. Bootstrapping refers to installing a new system from an image or configuration from an existing system through automation. A tool that can be used to do this is called Cloud-int. Cloud-int can be used to configure networking, run scripts, and other tasks. </td></tr><tr><td width="151">Container registries</td><td width="1384"> Container registries or container repositories are a central location where container images are stored. Examples are Docker Hub, Amazon ECR, Harbor, GitHub Container Registry, and Google Container Registry. </td></tr></tbody></table></div><!--[--><!--]--></div><footer class="vp-page-meta"><!----><div class="vp-meta-item git-info"><div class="vp-meta-item last-updated"><span class="meta-item-label">Last Updated: </span><!----></div><!----></div></footer><nav class="vp-page-nav" aria-label="page navigation"><a class="route-link auto-link prev" href="/linux/13/03.html" aria-label="Section 13.3 Sandboxed Applications"><div class="hint"><span class="arrow left"></span> Prev</div><div class="link"><span>Section 13.3 Sandboxed Applications</span></div></a><a class="route-link auto-link next" href="/linux/13/05.html" aria-label="Section 13.5 Virtual Networking"><div class="hint">Next <span class="arrow right"></span></div><div class="link"><span>Section 13.5 Virtual Networking</span></div></a></nav><!--[--><!--]--></main><!--]--></div><!--[--><!----><!--]--><!--]--></div>
    <script type="module" src="/linux/assets/app-D-CuBheB.js" defer></script>
  </body>
</html>
